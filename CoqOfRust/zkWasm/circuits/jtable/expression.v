(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuits.
  Module jtable.
    Module expression.
      Module Impl_delphinus_zkwasm_circuits_jtable_JumpTableConfig_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "delphinus_zkwasm::circuits::jtable::JumpTableConfig") [ F ].
        
        (*
            pub(super) fn enable(&self, meta: &mut VirtualCells<F>) -> Expression<F> {
                nextn!(meta, self.data, JtableOffset::JtableOffsetEnable as i32)
            }
        *)
        Definition enable (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; meta ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let meta := M.alloc (| meta |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                  "query_advice",
                  []
                |),
                [
                  M.read (| meta |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "delphinus_zkwasm::circuits::jtable::JumpTableConfig",
                      "data"
                    |)
                  |);
                  Value.StructTuple
                    "halo2_proofs::poly::Rotation"
                    [
                      M.rust_cast
                        (BinOp.Panic.add (|
                          Integer.Isize,
                          M.get_constant (|
                            "delphinus_zkwasm::circuits::jtable::JtableOffset::JtableOffsetEnable_discriminant"
                          |),
                          Value.Integer 0
                        |))
                    ]
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_enable :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "enable" (enable F).
        
        (*
            pub(super) fn rest(&self, meta: &mut VirtualCells<F>) -> Expression<F> {
                nextn!(meta, self.data, JtableOffset::JtableOffsetRest as i32)
            }
        *)
        Definition rest (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; meta ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let meta := M.alloc (| meta |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                  "query_advice",
                  []
                |),
                [
                  M.read (| meta |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "delphinus_zkwasm::circuits::jtable::JumpTableConfig",
                      "data"
                    |)
                  |);
                  Value.StructTuple
                    "halo2_proofs::poly::Rotation"
                    [
                      M.rust_cast
                        (BinOp.Panic.add (|
                          Integer.Isize,
                          M.get_constant (|
                            "delphinus_zkwasm::circuits::jtable::JtableOffset::JtableOffsetRest_discriminant"
                          |),
                          Value.Integer 0
                        |))
                    ]
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_rest :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "rest" (rest F).
        
        (*
            pub(super) fn next_rest(&self, meta: &mut VirtualCells<F>) -> Expression<F> {
                nextn!(
                    meta,
                    self.data,
                    JtableOffset::JtableOffsetRest as i32 + JtableOffset::JtableOffsetMax as i32
                )
            }
        *)
        Definition next_rest (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; meta ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let meta := M.alloc (| meta |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                  "query_advice",
                  []
                |),
                [
                  M.read (| meta |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "delphinus_zkwasm::circuits::jtable::JumpTableConfig",
                      "data"
                    |)
                  |);
                  Value.StructTuple
                    "halo2_proofs::poly::Rotation"
                    [
                      BinOp.Panic.add (|
                        Integer.I32,
                        M.rust_cast
                          (BinOp.Panic.add (|
                            Integer.Isize,
                            M.get_constant (|
                              "delphinus_zkwasm::circuits::jtable::JtableOffset::JtableOffsetRest_discriminant"
                            |),
                            Value.Integer 0
                          |)),
                        M.rust_cast
                          (BinOp.Panic.add (|
                            Integer.Isize,
                            M.get_constant (|
                              "delphinus_zkwasm::circuits::jtable::JtableOffset::JtableOffsetMax_discriminant"
                            |),
                            Value.Integer 0
                          |))
                      |)
                    ]
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_next_rest :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "next_rest" (next_rest F).
        
        (*
            pub(super) fn entry(&self, meta: &mut VirtualCells<F>) -> Expression<F> {
                nextn!(meta, self.data, JtableOffset::JtableOffsetEntry as i32)
            }
        *)
        Definition entry (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; meta ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let meta := M.alloc (| meta |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                  "query_advice",
                  []
                |),
                [
                  M.read (| meta |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "delphinus_zkwasm::circuits::jtable::JumpTableConfig",
                      "data"
                    |)
                  |);
                  Value.StructTuple
                    "halo2_proofs::poly::Rotation"
                    [
                      M.rust_cast
                        (BinOp.Panic.add (|
                          Integer.Isize,
                          M.get_constant (|
                            "delphinus_zkwasm::circuits::jtable::JtableOffset::JtableOffsetEntry_discriminant"
                          |),
                          Value.Integer 0
                        |))
                    ]
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_entry :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "entry" (entry F).
        
        (*
            pub(super) fn static_bit(&self, meta: &mut VirtualCells<F>) -> Expression<F> {
                fixed_curr!(meta, self.static_bit)
            }
        *)
        Definition static_bit (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ self; meta ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let meta := M.alloc (| meta |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "halo2_proofs::plonk::circuit::VirtualCells") [ F ],
                  "query_fixed",
                  []
                |),
                [
                  M.read (| meta |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "delphinus_zkwasm::circuits::jtable::JumpTableConfig",
                      "static_bit"
                    |)
                  |);
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "halo2_proofs::poly::Rotation",
                      "cur",
                      []
                    |),
                    []
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_static_bit :
          forall (F : Ty.t),
          M.IsAssociatedFunction (Self F) "static_bit" (static_bit F).
      End Impl_delphinus_zkwasm_circuits_jtable_JumpTableConfig_F.
      
      (* Trait *)
      (* Empty module 'JtableLookupEntryEncode' *)
      
      Module Impl_delphinus_zkwasm_circuits_jtable_expression_JtableLookupEntryEncode_where_pairing_bn256_arithmetic_fields_FieldExt_F_F_for_delphinus_zkwasm_circuits_jtable_JumpTableConfig_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "delphinus_zkwasm::circuits::jtable::JumpTableConfig") [ F ].
        
        (*
            fn encode_lookup(
                current_last_jump_eid: Expression<F>,
                next_last_jump_eid: Expression<F>,
                callee_fid: Expression<F>,
                next_fid: Expression<F>,
                next_iid: Expression<F>,
            ) -> Expression<F> {
                encode_frame_table_entry(
                    current_last_jump_eid,
                    next_last_jump_eid,
                    callee_fid,
                    next_fid,
                    next_iid,
                )
            }
        *)
        Definition encode_lookup (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match τ, α with
          | [], [ current_last_jump_eid; next_last_jump_eid; callee_fid; next_fid; next_iid ] =>
            ltac:(M.monadic
              (let current_last_jump_eid := M.alloc (| current_last_jump_eid |) in
              let next_last_jump_eid := M.alloc (| next_last_jump_eid |) in
              let callee_fid := M.alloc (| callee_fid |) in
              let next_fid := M.alloc (| next_fid |) in
              let next_iid := M.alloc (| next_iid |) in
              M.call_closure (|
                M.get_function (|
                  "specs::encode::frame_table::encode_frame_table_entry",
                  [ Ty.apply (Ty.path "halo2_proofs::plonk::circuit::Expression") [ F ] ]
                |),
                [
                  M.read (| current_last_jump_eid |);
                  M.read (| next_last_jump_eid |);
                  M.read (| callee_fid |);
                  M.read (| next_fid |);
                  M.read (| next_iid |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (F : Ty.t),
          M.IsTraitInstance
            "delphinus_zkwasm::circuits::jtable::expression::JtableLookupEntryEncode"
            (Self F)
            (* Trait polymorphic types *) [ (* F *) F ]
            (* Instance *) [ ("encode_lookup", InstanceField.Method (encode_lookup F)) ].
      End Impl_delphinus_zkwasm_circuits_jtable_expression_JtableLookupEntryEncode_where_pairing_bn256_arithmetic_fields_FieldExt_F_F_for_delphinus_zkwasm_circuits_jtable_JumpTableConfig_F.
    End expression.
  End jtable.
End circuits.
