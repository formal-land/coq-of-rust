(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module circuits.
  Module utils.
    (* StructRecord
      {
        name := "Context";
        ty_params := [ "F" ];
        fields :=
          [
            ("region",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [
                  Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("offset", Ty.path "usize");
            ("records",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_delphinus_zkwasm_circuits_utils_Context_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "delphinus_zkwasm::circuits::utils::Context") [ F ].
      
      (*
          pub fn new(region: &Region<'a, F>) -> Self {
              Self {
                  region: Box::new(region.clone()),
                  offset: 0usize,
                  records: vec![],
              }
          }
      *)
      Definition new (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ region ] =>
          ltac:(M.monadic
            (let region := M.alloc (| region |) in
            Value.StructRecord
              "delphinus_zkwasm::circuits::utils::Context"
              [
                ("region",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "halo2_proofs::circuit::Region") [ F ],
                          [],
                          "clone",
                          []
                        |),
                        [ M.read (| region |) ]
                      |)
                    ]
                  |));
                ("offset", Value.Integer 0);
                ("records",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "new" (new F).
      
      (*
          pub fn next(&mut self) {
              self.offset += 1;
          }
      *)
      Definition next (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "delphinus_zkwasm::circuits::utils::Context",
                    "offset"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_next :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "next" (next F).
      
      (*
          pub fn step(&mut self, step: usize) {
              self.offset += step;
          }
      *)
      Definition step (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self; step ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let step := M.alloc (| step |) in
            M.read (|
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "delphinus_zkwasm::circuits::utils::Context",
                    "offset"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), M.read (| step |) |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_step :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "step" (step F).
      
      (*
          pub fn reset(&mut self) {
              self.offset = 0;
              self.records.clear();
          }
      *)
      Definition reset (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "delphinus_zkwasm::circuits::utils::Context",
                    "offset"
                  |),
                  Value.Integer 0
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "clear",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "delphinus_zkwasm::circuits::utils::Context",
                        "records"
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reset :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "reset" (reset F).
      
      (*
          pub fn push(&mut self) {
              self.records.push(self.offset)
          }
      *)
      Definition push (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                "push",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "delphinus_zkwasm::circuits::utils::Context",
                  "records"
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "delphinus_zkwasm::circuits::utils::Context",
                    "offset"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_push :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "push" (push F).
      
      (*
          pub fn pop(&mut self) {
              self.offset = self.records.pop().unwrap();
          }
      *)
      Definition pop (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "delphinus_zkwasm::circuits::utils::Context",
                    "offset"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                          "pop",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "delphinus_zkwasm::circuits::utils::Context",
                            "records"
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pop :
        forall (F : Ty.t),
        M.IsAssociatedFunction (Self F) "pop" (pop F).
    End Impl_delphinus_zkwasm_circuits_utils_Context_F.
    
    (*
    pub fn field_to_bn<F: BaseExt>(f: &F) -> BigUint {
        let mut bytes: Vec<u8> = Vec::new();
        f.write(&mut bytes).unwrap();
        BigUint::from_bytes_le(&bytes[..])
    }
    *)
    Definition field_to_bn (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ F ], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          M.read (|
            let bytes :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "pairing_bn256::arithmetic::fields::BaseExt",
                        F,
                        [],
                        "write",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ]
                      |),
                      [ M.read (| f |); bytes ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "num_bigint::biguint::BigUint",
                  "from_bytes_le",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      []
                    |),
                    [ bytes; Value.StructTuple "core::ops::range::RangeFull" [] ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
    pub fn bn_to_field<F: BaseExt>(bn: &BigUint) -> F {
        let mut bytes = bn.to_bytes_le();
        bytes.resize(32, 0);
        let mut bytes = &bytes[..];
        F::read(&mut bytes).unwrap()
    }
    *)
    Definition bn_to_field (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ F ], [ bn ] =>
        ltac:(M.monadic
          (let bn := M.alloc (| bn |) in
          M.read (|
            let bytes :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "num_bigint::biguint::BigUint",
                    "to_bytes_le",
                    []
                  |),
                  [ M.read (| bn |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "resize",
                    []
                  |),
                  [ bytes; Value.Integer 32; Value.Integer 0 ]
                |)
              |) in
            let bytes :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ bytes; Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::result::Result") [ F; Ty.path "std::io::error::Error" ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "pairing_bn256::arithmetic::fields::BaseExt",
                      F,
                      [],
                      "read",
                      [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ]
                    |),
                    [ bytes ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
  End utils.
End circuits.
