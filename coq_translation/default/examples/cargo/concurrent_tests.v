(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.
Require Import smpl.Smpl.

Definition foo
    `{H' : State.Trait}
    {A : Set}
    (o : core.option.Option A)
    : M (H := H') unit :=
  match o with
  | core.option.Option.Some _a =>
    let* _ :=
      let* α0 := format_arguments::["new_const"] (addr_of [ "some
" ]) in
      std.io.stdio._print α0 in
    Pure tt
  | core.option.Option.None =>
    let* _ :=
      let* α0 := format_arguments::["new_const"] (addr_of [ "nothing
" ]) in
      std.io.stdio._print α0 in
    Pure tt
  end.

Smpl Create expect.

(* Check result.Impl_Result.expect. *)

Ltac apply_expect x1 x2 :=
  eapply result.Impl_Result.expect;
    try exact x1;
    try exact x2.

Smpl Add apply_expect : expect.

Set Printing All.
(* Check result.Impl_Result.expect. *)

Module Method_expect.
  Class Class `{H' : State.Trait} {Self Argument Result : Set} : Set := {
    method : Self -> Argument -> M (H := H') Result;
  }.

  (* Check result.Impl_Result.expect. *)

  Global Instance I `{H' : State.Trait} (T E : Set) : Class := {
    method := result.Impl_Result.expect (T := T) (E := E);
  }.

  Global Instance Method_expect `{State.Trait} (T E : Set) :
    Notation.Dot "expect" := {|
    Notation.dot := result.Impl_Result.expect (T := T) (E := E);
  |}.
End Method_expect.

Module Merged_method_expect.
  Class Class {Self A : Set} : Set := {
    merged_method : Self -> A;
  }.

  (* Check result.Impl_Result.expect. *)

  Global Instance I `{H' : State.Trait} (T E : Set) : Class := {
    merged_method := result.Impl_Result.expect (T := T) (E := E);
  }.
End Merged_method_expect.

Module Explicit_string_method.
  Class Class `{H' : State.Trait}
      (name : str) {Self Argument Result : Set} : Set := {
    method : Self -> Argument -> M (H := H') Result;
  }.

  Global Instance I `{H' : State.Trait} (T E : Set) : Class "expect" := {
    method := result.Impl_Result.expect (T := T) (E := E);
  }.
End Explicit_string_method.

Module tests.
  Definition foo `{H' : State.Trait} : M (H := H') unit :=
    let* file :=
      let* α0 := std.fs.OpenOptions::["new"] in
      let* α1 := α0.["append"] true in
      let* α2 := α1.["create"] true in
      let* α3 := α2.["open"] "ferris.txt" in
      (* α3.["expect"] "Failed to open ferris.txt" in *)
      Method_expect.method α3 "Failed to open ferris.txt" in
    Pure tt.

  Definition foo2 `{H' : State.Trait} : M (H := H') unit :=
    let* file :=
      let* α0 := std.fs.OpenOptions::["new"] in
      let* α1 := α0.["append"] true in
      let* α2 := α1.["create"] true in
      let* α3 := α2.["open"] "ferris.txt" in
      (* α3.["expect"] "Failed to open ferris.txt" in *)
      (* Merged_method_expect.merged_method α3 "Failed to open ferris.txt" in *)
      Explicit_string_method.method (name := "expect") α3 "Failed to open ferris.txt" in
    Pure tt.

  Definition test_file `{H' : State.Trait} :
      M (H := H') (result.Result std.fs.File _) :=
    let* file :=
      let* α0 := std.fs.OpenOptions::["new"] in
      let* α1 := α0.["append"] true in
      let* α2 := α1.["create"] true in
      α2.["open"] "ferris.txt" in
    Pure file.

  (* Print CoqOfRust.Notation.Dot.
  Print CoqOfRust.Notation.dot. *)

  Definition test_file2 `{H' : State.Trait} : M (H := H') std.fs.File :=
    Monad.bind
      test_file
      (fun file =>
        Method_expect.method
          file
          "Failed to open ferris.txt"
      ).

  (* Definition test_file2' `{H' : State.Trait} : M (H := H') std.fs.File :=
    Monad.bind
      test_file
      (fun file =>
        ltac:(apply result.Impl_Result.expect;
          try exact file;
          try exact "Failed to open ferris.txt"
        )
      ).

  Definition test_file3 `{H' : State.Trait}
    (file : result.Result std.fs.File io.Error.t) :
    M (H := H') std.fs.File :=
    file.["expect"] "Failed to open ferris.txt". *)

  (* Set Printing All.
  Print test_file. *)
  
  (* Definition test_file_also `{H' : State.Trait} : M (H := H') unit :=
    let* file :=
      let* α0 := std.fs.OpenOptions::["new"] in
      let* α1 := α0.["append"] true in
      let* α2 := α1.["create"] true in
      let* α3 := α2.["open"] "ferris.txt" in
      α3.["expect"] "Failed to open ferris.txt" in
    let* α0 :=
      {| std.ops.Range.start := 0; std.ops.Range._end := 5; |}.["into_iter"] in
    match α0 with
    | iter =>
      loop
        (let* _ :=
          let* α0 := (addr_of iter).["next"] in
          match α0 with
          | core.option.Option.None  => Break
          | core.option.Option.Some _ =>
            let* _ :=
              let* α0 := "Corro
".["as_bytes"] in
              let* α1 := file.["write_all"] α0 in
              α1.["expect"] "Could not write to ferris.txt" in
            Pure tt
          end in
        Pure tt)
    end. *)
End tests.

(* Definition test_file `{H' : State.Trait} : M (H := H') unit :=
  let* file :=
    let* α0 := std.fs.OpenOptions::["new"] in
    let* α1 := α0.["append"] true in
    let* α2 := α1.["create"] true in
    let* α3 := α2.["open"] "ferris.txt" in
    α3.["expect"] "Failed to open ferris.txt" in
  let* α0 :=
    {| std.ops.Range.start := 0; std.ops.Range._end := 5; |}.["into_iter"] in
  match α0 with
  | iter =>
    loop
      (let* _ :=
        let* α0 := (addr_of iter).["next"] in
        match α0 with
        | core.option.Option.None  => Break
        | core.option.Option.Some _ =>
          let* _ :=
            let* α0 := "Ferris
".["as_bytes"] in
            let* α1 := file.["write_all"] α0 in
            α1.["expect"] "Could not write to ferris.txt" in
          Pure tt
        end in
      Pure tt)
  end.

Definition test_file_also `{H' : State.Trait} : M (H := H') unit :=
  let* file :=
    let* α0 := std.fs.OpenOptions::["new"] in
    let* α1 := α0.["append"] true in
    let* α2 := α1.["create"] true in
    let* α3 := α2.["open"] "ferris.txt" in
    α3.["expect"] "Failed to open ferris.txt" in
  let* α0 :=
    {| std.ops.Range.start := 0; std.ops.Range._end := 5; |}.["into_iter"] in
  match α0 with
  | iter =>
    loop
      (let* _ :=
        let* α0 := (addr_of iter).["next"] in
        match α0 with
        | core.option.Option.None  => Break
        | core.option.Option.Some _ =>
          let* _ :=
            let* α0 := "Corro
".["as_bytes"] in
            let* α1 := file.["write_all"] α0 in
            α1.["expect"] "Could not write to ferris.txt" in
          Pure tt
        end in
      Pure tt)
  end. *)
