(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Choice.
  Section Choice.
    Context `{ℋ : State.Trait}.
    
    Unset Primitive Projections.
    Record t : Set := {
      x0 : u8;
    }.
    Global Set Primitive Projections.
    
    #[refine] Global Instance Get_0 : Notation.Dot "0" := {
      Notation.dot x := let* x := M.read x in Pure x.(x0) : M _;
    }.
    Admitted.
  End Choice.
End Choice.
Definition Choice `{ℋ : State.Trait} : Set := M.val Choice.t.

Module Impl_core_marker_Copy_for_subtle_Choice.
  Section Impl_core_marker_Copy_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    #[refine] Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
    Admitted.
  End Impl_core_marker_Copy_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  Section Impl_core_clone_Clone_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition clone (self : ref Self) : M subtle.Choice :=
      let* _ := M.alloc tt in
      deref self subtle.Choice.
    
    Global Instance AssociatedFunction_clone :
      Notation.DoubleColon Self "clone" := {
      Notation.double_colon := clone;
    }.
    
    #[refine] Global Instance ℐ : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone := clone;
    }.
    Admitted.
  End Impl_core_clone_Clone_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  Section Impl_core_fmt_Debug_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M ltac:(core.fmt.Result) :=
      let* α0 := deref f core.fmt.Formatter in
      let* α1 := borrow_mut α0 core.fmt.Formatter in
      let* α2 := deref (mk_str "Choice") str in
      let* α3 := borrow α2 str in
      let* α4 := deref self subtle.Choice in
      let* α5 := α4.["0"] in
      let* α6 := borrow α5 u8 in
      let* α7 := borrow α6 (ref u8) in
      let* α8 := deref α7 (ref u8) in
      let* α9 := borrow α8 (ref u8) in
      let* α10 := pointer_coercion "Unsize" α9 in
      core.fmt.Formatter::["debug_tuple_field1_finish"] α1 α3 α10.
    
    Global Instance AssociatedFunction_fmt :
      Notation.DoubleColon Self "fmt" := {
      Notation.double_colon := fmt;
    }.
    
    #[refine] Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
    Admitted.
  End Impl_core_fmt_Debug_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice_4.
  Section Impl_subtle_Choice_4.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition unwrap_u8 (self : ref Self) : M u8 :=
      let* α0 := deref self subtle.Choice in
      α0.["0"].
    
    Global Instance AssociatedFunction_unwrap_u8 :
      Notation.DoubleColon Self "unwrap_u8" := {
      Notation.double_colon := unwrap_u8;
    }.
  End Impl_subtle_Choice_4.
End Impl_subtle_Choice_4.

Module Impl_core_convert_From_for_bool.
  Section Impl_core_convert_From_for_bool.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := bool.
    
    Definition from (source : subtle.Choice) : M bool :=
      let* _ :=
        let* α0 := M.alloc true in
        let* α1 := use α0 in
        if (α1 : bool) then
          let* _ :=
            let* α0 := source.["0"] in
            let* α1 := M.alloc 0 in
            let* α2 := eq α0 α1 in
            let* α3 := source.["0"] in
            let* α4 := M.alloc 1 in
            let* α5 := eq α3 α4 in
            let* α6 := bitor α2 α5 in
            let* α7 := not α6 in
            let* α8 := use α7 in
            if (α8 : bool) then
              let* α0 :=
                core.panicking.panic
                  (mk_str
                    "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
              never_to_any α0
            else
              M.alloc tt in
          M.alloc tt
        else
          M.alloc tt in
      let* α0 := source.["0"] in
      let* α1 := M.alloc 0 in
      ne α0 α1.
    
    Global Instance AssociatedFunction_from :
      Notation.DoubleColon Self "from" := {
      Notation.double_colon := from;
    }.
    
    #[refine] Global Instance ℐ :
      core.convert.From.Trait Self (T := subtle.Choice) := {
      core.convert.From.from := from;
    }.
    Admitted.
  End Impl_core_convert_From_for_bool.
  Global Hint Resolve ℐ : core.
End Impl_core_convert_From_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Section Impl_core_ops_bit_BitAnd_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition Output : Set := subtle.Choice.
    
    Definition bitand (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
      let* α0 := self.["0"] in
      let* α1 := rhs.["0"] in
      let* α2 := bitand α0 α1 in
      (core.convert.Into.into (Self := u8)) α2.
    
    Global Instance AssociatedFunction_bitand :
      Notation.DoubleColon Self "bitand" := {
      Notation.double_colon := bitand;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitAnd.Trait Self
        (Rhs := core.ops.bit.BitAnd.Default.Rhs Self) := {
      core.ops.bit.BitAnd.Output := Output;
      core.ops.bit.BitAnd.bitand := bitand;
    }.
    Admitted.
  End Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition bitand_assign
        (self : mut_ref Self)
        (rhs : subtle.Choice)
        : M unit :=
      let* _ :=
        let* α0 := deref self subtle.Choice in
        let* α1 := deref self subtle.Choice in
        let* α2 :=
          (core.ops.bit.BitAnd.bitand (Self := subtle.Choice)) α1 rhs in
        assign α0 α2 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_bitand_assign :
      Notation.DoubleColon Self "bitand_assign" := {
      Notation.double_colon := bitand_assign;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitAndAssign.Trait Self
        (Rhs := core.ops.bit.BitAndAssign.Default.Rhs Self) := {
      core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
    }.
    Admitted.
  End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Section Impl_core_ops_bit_BitOr_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition Output : Set := subtle.Choice.
    
    Definition bitor (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
      let* α0 := self.["0"] in
      let* α1 := rhs.["0"] in
      let* α2 := bitor α0 α1 in
      (core.convert.Into.into (Self := u8)) α2.
    
    Global Instance AssociatedFunction_bitor :
      Notation.DoubleColon Self "bitor" := {
      Notation.double_colon := bitor;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitOr.Trait Self
        (Rhs := core.ops.bit.BitOr.Default.Rhs Self) := {
      core.ops.bit.BitOr.Output := Output;
      core.ops.bit.BitOr.bitor := bitor;
    }.
    Admitted.
  End Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition bitor_assign
        (self : mut_ref Self)
        (rhs : subtle.Choice)
        : M unit :=
      let* _ :=
        let* α0 := deref self subtle.Choice in
        let* α1 := deref self subtle.Choice in
        let* α2 := (core.ops.bit.BitOr.bitor (Self := subtle.Choice)) α1 rhs in
        assign α0 α2 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_bitor_assign :
      Notation.DoubleColon Self "bitor_assign" := {
      Notation.double_colon := bitor_assign;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitOrAssign.Trait Self
        (Rhs := core.ops.bit.BitOrAssign.Default.Rhs Self) := {
      core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
    }.
    Admitted.
  End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Section Impl_core_ops_bit_BitXor_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition Output : Set := subtle.Choice.
    
    Definition bitxor (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
      let* α0 := self.["0"] in
      let* α1 := rhs.["0"] in
      let* α2 := bitxor α0 α1 in
      (core.convert.Into.into (Self := u8)) α2.
    
    Global Instance AssociatedFunction_bitxor :
      Notation.DoubleColon Self "bitxor" := {
      Notation.double_colon := bitxor;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitXor.Trait Self
        (Rhs := core.ops.bit.BitXor.Default.Rhs Self) := {
      core.ops.bit.BitXor.Output := Output;
      core.ops.bit.BitXor.bitxor := bitxor;
    }.
    Admitted.
  End Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition bitxor_assign
        (self : mut_ref Self)
        (rhs : subtle.Choice)
        : M unit :=
      let* _ :=
        let* α0 := deref self subtle.Choice in
        let* α1 := deref self subtle.Choice in
        let* α2 :=
          (core.ops.bit.BitXor.bitxor (Self := subtle.Choice)) α1 rhs in
        assign α0 α2 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_bitxor_assign :
      Notation.DoubleColon Self "bitxor_assign" := {
      Notation.double_colon := bitxor_assign;
    }.
    
    #[refine] Global Instance ℐ :
      core.ops.bit.BitXorAssign.Trait Self
        (Rhs := core.ops.bit.BitXorAssign.Default.Rhs Self) := {
      core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
    }.
    Admitted.
  End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  Section Impl_core_ops_bit_Not_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition Output : Set := subtle.Choice.
    
    Definition not (self : Self) : M subtle.Choice :=
      let* α0 := M.alloc 1 in
      let* α1 := self.["0"] in
      let* α2 := not α1 in
      let* α3 := bitand α0 α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_not :
      Notation.DoubleColon Self "not" := {
      Notation.double_colon := not;
    }.
    
    #[refine] Global Instance ℐ : core.ops.bit.Not.Trait Self := {
      core.ops.bit.Not.Output := Output;
      core.ops.bit.Not.not := not;
    }.
    Admitted.
  End Impl_core_ops_bit_Not_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_ops_bit_Not_for_subtle_Choice.

Definition black_box `{ℋ : State.Trait} (input : u8) : M u8 :=
  let* _ :=
    let* α0 := M.alloc true in
    let* α1 := use α0 in
    if (α1 : bool) then
      let* _ :=
        let* α0 := M.alloc 0 in
        let* α1 := eq input α0 in
        let* α2 := M.alloc 1 in
        let* α3 := eq input α2 in
        let* α4 := bitor α1 α3 in
        let* α5 := not α4 in
        let* α6 := use α5 in
        if (α6 : bool) then
          let* α0 :=
            core.panicking.panic
              (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
          never_to_any α0
        else
          M.alloc tt in
      M.alloc tt
    else
      M.alloc tt in
  let* α0 := borrow input u8 in
  let* α1 := deref α0 u8 in
  let* α2 := addr_of α1 in
  let* α3 := use α2 in
  core.ptr.read_volatile α3.

Module Impl_core_convert_From_for_subtle_Choice.
  Section Impl_core_convert_From_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition from (input : u8) : M subtle.Choice :=
      let* α0 := subtle.black_box input in
      Pure (subtle.Choice.Build_t α0).
    
    Global Instance AssociatedFunction_from :
      Notation.DoubleColon Self "from" := {
      Notation.double_colon := from;
    }.
    
    #[refine] Global Instance ℐ : core.convert.From.Trait Self (T := u8) := {
      core.convert.From.from := from;
    }.
    Admitted.
  End Impl_core_convert_From_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_core_convert_From_for_subtle_Choice.

Module ConstantTimeEq.
  Section ConstantTimeEq.
    Context `{ℋ : State.Trait}.
    
    Class Trait (Self : Set) : Type := {
      ct_eq : (ref Self) -> (ref Self) -> M subtle.Choice;
    }.
    
  End ConstantTimeEq.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_Slice_T.
  Section Impl_subtle_ConstantTimeEq_for_Slice_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
    Definition Self : Set := Slice T.
    
    Definition ct_eq
        (self : ref Self)
        (_rhs : ref (Slice T))
        : M subtle.Choice :=
      let* len :=
        let* α0 := deref self (Slice T) in
        let* α1 := borrow α0 (Slice T) in
        (Slice T)::["len"] α1 in
      let* _ :=
        let* α0 := deref _rhs (Slice T) in
        let* α1 := borrow α0 (Slice T) in
        let* α2 := (Slice T)::["len"] α1 in
        let* α3 := ne len α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* _ :=
            let* α0 := M.alloc 0 in
            let* α1 := (core.convert.From.from (Self := subtle.Choice)) α0 in
            Return α1 in
          let* α0 := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt in
      let* x := M.alloc 1 in
      let* _ :=
        let* α0 := deref self (Slice T) in
        let* α1 := borrow α0 (Slice T) in
        let* α2 := (Slice T)::["iter"] α1 in
        let* α3 := deref _rhs (Slice T) in
        let* α4 := borrow α3 (Slice T) in
        let* α5 := (Slice T)::["iter"] α4 in
        let* α6 :=
          (core.iter.traits.iterator.Iterator.zip
              (Self := (core.slice.iter.Iter T)))
            α2
            α5 in
        let* α7 :=
          (core.iter.traits.collect.IntoIterator.into_iter
              (Self :=
                (core.iter.adapters.zip.Zip
                  (core.slice.iter.Iter T)
                  (core.slice.iter.Iter T))))
            α6 in
        let* α8 :=
          match α7 with
          | iter =>
            loop
              (let* _ :=
                let* α0 :=
                  borrow_mut
                    iter
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter T)
                      (core.slice.iter.Iter T)) in
                let* α1 :=
                  deref
                    α0
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter T)
                      (core.slice.iter.Iter T)) in
                let* α2 :=
                  borrow_mut
                    α1
                    (core.iter.adapters.zip.Zip
                      (core.slice.iter.Iter T)
                      (core.slice.iter.Iter T)) in
                let* α3 :=
                  (core.iter.traits.iterator.Iterator.next
                      (Self :=
                        (core.iter.adapters.zip.Zip
                          (core.slice.iter.Iter T)
                          (core.slice.iter.Iter T))))
                    α2 in
                match α3 with
                | core.option.Option  =>
                  let* α0 := Break in
                  never_to_any α0
                | core.option.Option (ai, bi) =>
                  let* _ :=
                    let* α0 := deref ai T in
                    let* α1 := borrow α0 T in
                    let* α2 := deref bi T in
                    let* α3 := borrow α2 T in
                    let* α4 :=
                      (subtle.ConstantTimeEq.ct_eq (Self := T)) α1 α3 in
                    let* α5 := borrow α4 subtle.Choice in
                    let* α6 := subtle.Choice::["unwrap_u8"] α5 in
                    assign_op bitand x α6 in
                  M.alloc tt
                end in
              M.alloc tt)
          end in
        use α8 in
      (core.convert.Into.into (Self := u8)) x.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_Slice_T.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_Slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Section Impl_subtle_ConstantTimeEq_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition ct_eq
        (self : ref Self)
        (rhs : ref subtle.Choice)
        : M subtle.Choice :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref rhs subtle.Choice in
      let* α2 := (core.ops.bit.BitXor.bitxor (Self := subtle.Choice)) α0 α1 in
      (core.ops.bit.Not.not (Self := subtle.Choice)) α2.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  Section Impl_subtle_ConstantTimeEq_for_u8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u8.
    
    Definition ct_eq (self : ref Self) (other : ref u8) : M subtle.Choice :=
      let* x := (core.ops.bit.BitXor.bitxor (Self := (ref u8))) self other in
      let* y :=
        let* α0 := u8::["wrapping_neg"] x in
        let* α1 := bitor x α0 in
        let* α2 := M.alloc 8 in
        let* α3 := M.alloc 1 in
        let* α4 := sub α2 α3 in
        shr α1 α4 in
      let* α0 := M.alloc 1 in
      let* α1 := use α0 in
      let* α2 := bitxor y α1 in
      let* α3 := use α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_u8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  Section Impl_subtle_ConstantTimeEq_for_i8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i8.
    
    Definition ct_eq (self : ref Self) (other : ref i8) : M subtle.Choice :=
      let* α0 := deref self i8 in
      let* α1 := cast α0 in
      let* α2 := borrow α1 u8 in
      let* α3 := deref other i8 in
      let* α4 := cast α3 in
      let* α5 := borrow α4 u8 in
      let* α6 := deref α5 u8 in
      let* α7 := borrow α6 u8 in
      (subtle.ConstantTimeEq.ct_eq (Self := u8)) α2 α7.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_i8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  Section Impl_subtle_ConstantTimeEq_for_u16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u16.
    
    Definition ct_eq (self : ref Self) (other : ref u16) : M subtle.Choice :=
      let* x := (core.ops.bit.BitXor.bitxor (Self := (ref u16))) self other in
      let* y :=
        let* α0 := u16::["wrapping_neg"] x in
        let* α1 := bitor x α0 in
        let* α2 := M.alloc 16 in
        let* α3 := M.alloc 1 in
        let* α4 := sub α2 α3 in
        shr α1 α4 in
      let* α0 := M.alloc 1 in
      let* α1 := use α0 in
      let* α2 := bitxor y α1 in
      let* α3 := cast α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_u16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  Section Impl_subtle_ConstantTimeEq_for_i16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i16.
    
    Definition ct_eq (self : ref Self) (other : ref i16) : M subtle.Choice :=
      let* α0 := deref self i16 in
      let* α1 := cast α0 in
      let* α2 := borrow α1 u16 in
      let* α3 := deref other i16 in
      let* α4 := cast α3 in
      let* α5 := borrow α4 u16 in
      let* α6 := deref α5 u16 in
      let* α7 := borrow α6 u16 in
      (subtle.ConstantTimeEq.ct_eq (Self := u16)) α2 α7.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_i16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  Section Impl_subtle_ConstantTimeEq_for_u32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u32.
    
    Definition ct_eq (self : ref Self) (other : ref u32) : M subtle.Choice :=
      let* x := (core.ops.bit.BitXor.bitxor (Self := (ref u32))) self other in
      let* y :=
        let* α0 := u32::["wrapping_neg"] x in
        let* α1 := bitor x α0 in
        let* α2 := M.alloc 32 in
        let* α3 := M.alloc 1 in
        let* α4 := sub α2 α3 in
        shr α1 α4 in
      let* α0 := M.alloc 1 in
      let* α1 := use α0 in
      let* α2 := bitxor y α1 in
      let* α3 := cast α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_u32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  Section Impl_subtle_ConstantTimeEq_for_i32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i32.
    
    Definition ct_eq (self : ref Self) (other : ref i32) : M subtle.Choice :=
      let* α0 := deref self i32 in
      let* α1 := cast α0 in
      let* α2 := borrow α1 u32 in
      let* α3 := deref other i32 in
      let* α4 := cast α3 in
      let* α5 := borrow α4 u32 in
      let* α6 := deref α5 u32 in
      let* α7 := borrow α6 u32 in
      (subtle.ConstantTimeEq.ct_eq (Self := u32)) α2 α7.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_i32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  Section Impl_subtle_ConstantTimeEq_for_u64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u64.
    
    Definition ct_eq (self : ref Self) (other : ref u64) : M subtle.Choice :=
      let* x := (core.ops.bit.BitXor.bitxor (Self := (ref u64))) self other in
      let* y :=
        let* α0 := u64::["wrapping_neg"] x in
        let* α1 := bitor x α0 in
        let* α2 := M.alloc 64 in
        let* α3 := M.alloc 1 in
        let* α4 := sub α2 α3 in
        shr α1 α4 in
      let* α0 := M.alloc 1 in
      let* α1 := use α0 in
      let* α2 := bitxor y α1 in
      let* α3 := cast α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_u64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  Section Impl_subtle_ConstantTimeEq_for_i64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i64.
    
    Definition ct_eq (self : ref Self) (other : ref i64) : M subtle.Choice :=
      let* α0 := deref self i64 in
      let* α1 := cast α0 in
      let* α2 := borrow α1 u64 in
      let* α3 := deref other i64 in
      let* α4 := cast α3 in
      let* α5 := borrow α4 u64 in
      let* α6 := deref α5 u64 in
      let* α7 := borrow α6 u64 in
      (subtle.ConstantTimeEq.ct_eq (Self := u64)) α2 α7.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_i64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  Section Impl_subtle_ConstantTimeEq_for_usize.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := usize.
    
    Definition ct_eq (self : ref Self) (other : ref usize) : M subtle.Choice :=
      let* x := (core.ops.bit.BitXor.bitxor (Self := (ref usize))) self other in
      let* y :=
        let* α0 := usize::["wrapping_neg"] x in
        let* α1 := bitor x α0 in
        let* α2 := core.mem.size_of in
        let* α3 := M.alloc 8 in
        let* α4 := mul α2 α3 in
        let* α5 := M.alloc 1 in
        let* α6 := sub α4 α5 in
        shr α1 α6 in
      let* α0 := M.alloc 1 in
      let* α1 := use α0 in
      let* α2 := bitxor y α1 in
      let* α3 := cast α2 in
      (core.convert.Into.into (Self := u8)) α3.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_usize.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  Section Impl_subtle_ConstantTimeEq_for_isize.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := isize.
    
    Definition ct_eq (self : ref Self) (other : ref isize) : M subtle.Choice :=
      let* α0 := deref self isize in
      let* α1 := cast α0 in
      let* α2 := borrow α1 usize in
      let* α3 := deref other isize in
      let* α4 := cast α3 in
      let* α5 := borrow α4 usize in
      let* α6 := deref α5 usize in
      let* α7 := borrow α6 usize in
      (subtle.ConstantTimeEq.ct_eq (Self := usize)) α2 α7.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_isize.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Section ConditionallySelectable.
    Context `{ℋ : State.Trait}.
    
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: core.marker.Copy.Trait Self;
      conditional_select : (ref Self) -> (ref Self) -> subtle.Choice -> M Self;
    }.
    
  End ConditionallySelectable.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  Section Impl_subtle_ConditionallySelectable_for_u8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u8.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref u8))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref u8))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* _ :=
        let* α0 := deref self u8 in
        let* α1 := deref self u8 in
        let* α2 := deref other u8 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* t :=
        let* α0 := deref a u8 in
        let* α1 := deref b u8 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a u8 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b u8 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_u8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  Section Impl_subtle_ConditionallySelectable_for_i8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i8.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref i8))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref i8))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* _ :=
        let* α0 := deref self i8 in
        let* α1 := deref self i8 in
        let* α2 := deref other i8 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* t :=
        let* α0 := deref a i8 in
        let* α1 := deref b i8 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a i8 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b i8 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_i8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  Section Impl_subtle_ConditionallySelectable_for_u16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u16.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref u16))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref u16))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* _ :=
        let* α0 := deref self u16 in
        let* α1 := deref self u16 in
        let* α2 := deref other u16 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* t :=
        let* α0 := deref a u16 in
        let* α1 := deref b u16 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a u16 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b u16 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_u16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  Section Impl_subtle_ConditionallySelectable_for_i16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i16.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref i16))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref i16))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* _ :=
        let* α0 := deref self i16 in
        let* α1 := deref self i16 in
        let* α2 := deref other i16 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* t :=
        let* α0 := deref a i16 in
        let* α1 := deref b i16 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a i16 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b i16 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_i16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  Section Impl_subtle_ConditionallySelectable_for_u32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u32.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref u32))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref u32))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* _ :=
        let* α0 := deref self u32 in
        let* α1 := deref self u32 in
        let* α2 := deref other u32 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* t :=
        let* α0 := deref a u32 in
        let* α1 := deref b u32 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a u32 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b u32 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_u32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  Section Impl_subtle_ConditionallySelectable_for_i32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i32.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref i32))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref i32))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* _ :=
        let* α0 := deref self i32 in
        let* α1 := deref self i32 in
        let* α2 := deref other i32 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* t :=
        let* α0 := deref a i32 in
        let* α1 := deref b i32 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a i32 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b i32 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_i32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  Section Impl_subtle_ConditionallySelectable_for_u64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u64.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref u64))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref u64))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* _ :=
        let* α0 := deref self u64 in
        let* α1 := deref self u64 in
        let* α2 := deref other u64 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        cast α3 in
      let* t :=
        let* α0 := deref a u64 in
        let* α1 := deref b u64 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a u64 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b u64 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_u64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  Section Impl_subtle_ConditionallySelectable_for_i64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := i64.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* α0 := (core.ops.bit.BitXor.bitxor (Self := (ref i64))) a b in
      let* α1 := bitand mask α0 in
      (core.ops.bit.BitXor.bitxor (Self := (ref i64))) a α1.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    Definition conditional_assign
        (self : mut_ref Self)
        (other : ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* _ :=
        let* α0 := deref self i64 in
        let* α1 := deref self i64 in
        let* α2 := deref other i64 in
        let* α3 := bitxor α1 α2 in
        let* α4 := bitand mask α3 in
        assign_op bitxor α0 α4 in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_assign :
      Notation.DoubleColon Self "conditional_assign" := {
      Notation.double_colon := conditional_assign;
    }.
    
    Definition conditional_swap
        (a : mut_ref Self)
        (b : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* mask :=
        let* α0 := borrow choice subtle.Choice in
        let* α1 := subtle.Choice::["unwrap_u8"] α0 in
        let* α2 := cast α1 in
        let* α3 := neg α2 in
        use α3 in
      let* t :=
        let* α0 := deref a i64 in
        let* α1 := deref b i64 in
        let* α2 := bitxor α0 α1 in
        bitand mask α2 in
      let* _ :=
        let* α0 := deref a i64 in
        assign_op bitxor α0 t in
      let* _ :=
        let* α0 := deref b i64 in
        assign_op bitxor α0 t in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_swap :
      Notation.DoubleColon Self "conditional_swap" := {
      Notation.double_colon := conditional_swap;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_i64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Section Impl_subtle_ConditionallySelectable_for_subtle_Choice.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.Choice.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* α0 := deref a subtle.Choice in
      let* α1 := α0.["0"] in
      let* α2 := borrow α1 u8 in
      let* α3 := deref α2 u8 in
      let* α4 := borrow α3 u8 in
      let* α5 := deref b subtle.Choice in
      let* α6 := α5.["0"] in
      let* α7 := borrow α6 u8 in
      let* α8 := deref α7 u8 in
      let* α9 := borrow α8 u8 in
      let* α10 :=
        (subtle.ConditionallySelectable.conditional_select (Self := u8))
          α4
          α9
          choice in
      Pure (subtle.Choice.Build_t α10).
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module ConditionallyNegatable.
  Section ConditionallyNegatable.
    Context `{ℋ : State.Trait}.
    
    Class Trait (Self : Set) : Type := {
      conditional_negate : (mut_ref Self) -> subtle.Choice -> M unit;
    }.
    
  End ConditionallyNegatable.
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
  Section Impl_subtle_ConditionallyNegatable_for_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.arith.Neg.Trait (ref T)}.
    Definition Self : Set := T.
    
    Definition conditional_negate
        (self : mut_ref Self)
        (choice : subtle.Choice)
        : M unit :=
      let* self_neg :=
        let* α0 := deref self T in
        let* α1 := borrow α0 T in
        let* α2 := use α1 in
        (core.ops.arith.Neg.neg (Self := (ref T))) (α2 : (ref T)) in
      let* _ :=
        let* α0 := deref self T in
        let* α1 := borrow_mut α0 T in
        let* α2 := borrow self_neg T in
        let* α3 := deref α2 T in
        let* α4 := borrow α3 T in
        (subtle.ConditionallySelectable.conditional_assign (Self := T))
          α1
          α4
          choice in
      M.alloc tt.
    
    Global Instance AssociatedFunction_conditional_negate :
      Notation.DoubleColon Self "conditional_negate" := {
      Notation.double_colon := conditional_negate;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallyNegatable.Trait Self := {
      subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
    }.
    Admitted.
  End Impl_subtle_ConditionallyNegatable_for_T.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallyNegatable_for_T.

Module CtOption.
  Section CtOption.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Unset Primitive Projections.
    Record t : Set := {
      value : T;
      is_some : subtle.Choice;
    }.
    Global Set Primitive Projections.
    
    #[refine] Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot x := let* x := M.read x in Pure x.(value) : M _;
    }.
    Admitted.
    #[refine] Global Instance Get_AF_value : Notation.DoubleColon t "value" := {
      Notation.double_colon x := let* x := M.read x in Pure x.(value) : M _;
    }.
    Admitted.
    #[refine] Global Instance Get_is_some : Notation.Dot "is_some" := {
      Notation.dot x := let* x := M.read x in Pure x.(is_some) : M _;
    }.
    Admitted.
    #[refine] Global Instance Get_AF_is_some :
      Notation.DoubleColon t "is_some" := {
      Notation.double_colon x := let* x := M.read x in Pure x.(is_some) : M _;
    }.
    Admitted.
  End CtOption.
End CtOption.
Definition CtOption (T : Set) `{ℋ : State.Trait} : Set :=
  M.val (CtOption.t (T := T)).

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
  Section Impl_core_clone_Clone_for_subtle_CtOption_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : core.clone.Clone.Trait T}.
    Definition Self : Set := subtle.CtOption T.
    
    Definition clone (self : ref Self) : M (subtle.CtOption T) :=
      let* α0 := deref self (subtle.CtOption T) in
      let* α1 := α0.["value"] in
      let* α2 := borrow α1 T in
      let* α3 := deref α2 T in
      let* α4 := borrow α3 T in
      let* α5 := (core.clone.Clone.clone (Self := T)) α4 in
      let* α6 := deref self (subtle.CtOption T) in
      let* α7 := α6.["is_some"] in
      let* α8 := borrow α7 subtle.Choice in
      let* α9 := deref α8 subtle.Choice in
      let* α10 := borrow α9 subtle.Choice in
      let* α11 := (core.clone.Clone.clone (Self := subtle.Choice)) α10 in
      M.alloc
        {| subtle.CtOption.value := α5; subtle.CtOption.is_some := α11; |}.
    
    Global Instance AssociatedFunction_clone :
      Notation.DoubleColon Self "clone" := {
      Notation.double_colon := clone;
    }.
    
    #[refine] Global Instance ℐ : core.clone.Clone.Trait Self := {
      core.clone.Clone.clone := clone;
    }.
    Admitted.
  End Impl_core_clone_Clone_for_subtle_CtOption_T.
  Global Hint Resolve ℐ : core.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
  Section Impl_core_marker_Copy_for_subtle_CtOption_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : core.marker.Copy.Trait T}.
    Definition Self : Set := subtle.CtOption T.
    
    #[refine] Global Instance ℐ : core.marker.Copy.Trait Self := {
    }.
    Admitted.
  End Impl_core_marker_Copy_for_subtle_CtOption_T.
  Global Hint Resolve ℐ : core.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : core.fmt.Debug.Trait T}.
    Definition Self : Set := subtle.CtOption T.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref core.fmt.Formatter)
        : M ltac:(core.fmt.Result) :=
      let* α0 := deref f core.fmt.Formatter in
      let* α1 := borrow_mut α0 core.fmt.Formatter in
      let* α2 := deref (mk_str "CtOption") str in
      let* α3 := borrow α2 str in
      let* α4 := deref (mk_str "value") str in
      let* α5 := borrow α4 str in
      let* α6 := deref self (subtle.CtOption T) in
      let* α7 := α6.["value"] in
      let* α8 := borrow α7 T in
      let* α9 := deref α8 T in
      let* α10 := borrow α9 T in
      let* α11 := pointer_coercion "Unsize" α10 in
      let* α12 := deref (mk_str "is_some") str in
      let* α13 := borrow α12 str in
      let* α14 := deref self (subtle.CtOption T) in
      let* α15 := α14.["is_some"] in
      let* α16 := borrow α15 subtle.Choice in
      let* α17 := borrow α16 (ref subtle.Choice) in
      let* α18 := deref α17 (ref subtle.Choice) in
      let* α19 := borrow α18 (ref subtle.Choice) in
      let* α20 := pointer_coercion "Unsize" α19 in
      core.fmt.Formatter::["debug_struct_field2_finish"] α1 α3 α5 α11 α13 α20.
    
    Global Instance AssociatedFunction_fmt :
      Notation.DoubleColon Self "fmt" := {
      Notation.double_colon := fmt;
    }.
    
    #[refine] Global Instance ℐ : core.fmt.Debug.Trait Self := {
      core.fmt.Debug.fmt := fmt;
    }.
    Admitted.
  End Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Global Hint Resolve ℐ : core.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_for_core_option_Option_T.
  Section Impl_core_convert_From_for_core_option_Option_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Definition Self : Set := core.option.Option T.
    
    Definition from (source : subtle.CtOption T) : M (core.option.Option T) :=
      let* α0 := borrow source (subtle.CtOption T) in
      let* α1 := (subtle.CtOption T)::["is_some"] α0 in
      let* α2 := borrow α1 subtle.Choice in
      let* α3 := subtle.Choice::["unwrap_u8"] α2 in
      let* α4 := M.alloc 1 in
      let* α5 := eq α3 α4 in
      let* α6 := use α5 in
      if (α6 : bool) then
        let* α0 := source.["value"] in
        Pure (core.option.Option.Some α0)
      else
        Pure (core.option.Option.None tt).
    
    Global Instance AssociatedFunction_from :
      Notation.DoubleColon Self "from" := {
      Notation.double_colon := from;
    }.
    
    #[refine] Global Instance ℐ :
      core.convert.From.Trait Self (T := subtle.CtOption T) := {
      core.convert.From.from := from;
    }.
    Admitted.
  End Impl_core_convert_From_for_core_option_Option_T.
  Global Hint Resolve ℐ : core.
End Impl_core_convert_From_for_core_option_Option_T.

Module Impl_subtle_CtOption_T_4.
  Section Impl_subtle_CtOption_T_4.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := subtle.CtOption T.
    
    Definition new
        (value : T)
        (is_some : subtle.Choice)
        : M (subtle.CtOption T) :=
      M.alloc
        {| subtle.CtOption.value := value; subtle.CtOption.is_some := is_some;
        |}.
    
    Global Instance AssociatedFunction_new :
      Notation.DoubleColon Self "new" := {
      Notation.double_colon := new;
    }.
    
    Definition expect (self : Self) (msg : ref str) : M T :=
      let* _ :=
        let* α0 := self.["is_some"] in
        let* α1 := borrow α0 subtle.Choice in
        let* α2 := subtle.Choice::["unwrap_u8"] α1 in
        let* α3 := borrow α2 u8 in
        let* α4 := M.alloc 1 in
        let* α5 := borrow α4 u8 in
        match (α3, α5) with
        | (left_val, right_val) =>
          let* α0 := deref left_val u8 in
          let* α1 := deref right_val u8 in
          let* α2 := eq α0 α1 in
          let* α3 := not α2 in
          let* α4 := use α3 in
          if (α4 : bool) then
            let kind := core.panicking.AssertKind.Eq tt in
            let* _ :=
              let* α0 := deref left_val u8 in
              let* α1 := borrow α0 u8 in
              let* α2 := deref α1 u8 in
              let* α3 := borrow α2 u8 in
              let* α4 := deref right_val u8 in
              let* α5 := borrow α4 u8 in
              let* α6 := deref α5 u8 in
              let* α7 := borrow α6 u8 in
              let* α8 := borrow [ mk_str "" ] (list (ref str)) in
              let* α9 := deref α8 (list (ref str)) in
              let* α10 := borrow α9 (list (ref str)) in
              let* α11 := pointer_coercion "Unsize" α10 in
              let* α12 := borrow msg (ref str) in
              let* α13 := deref α12 (ref str) in
              let* α14 := borrow α13 (ref str) in
              let* α15 := core.fmt.rt.Argument::["new_display"] α14 in
              let* α16 := borrow [ α15 ] (list core.fmt.rt.Argument) in
              let* α17 := deref α16 (list core.fmt.rt.Argument) in
              let* α18 := borrow α17 (list core.fmt.rt.Argument) in
              let* α19 := pointer_coercion "Unsize" α18 in
              let* α20 := core.fmt.Arguments::["new_v1"] α11 α19 in
              core.panicking.assert_failed
                kind
                α3
                α7
                (core.option.Option.Some α20) in
            let* α0 := M.alloc tt in
            never_to_any α0
          else
            M.alloc tt
        end in
      self.["value"].
    
    Global Instance AssociatedFunction_expect :
      Notation.DoubleColon Self "expect" := {
      Notation.double_colon := expect;
    }.
    
    Definition unwrap (self : Self) : M T :=
      let* _ :=
        let* α0 := self.["is_some"] in
        let* α1 := borrow α0 subtle.Choice in
        let* α2 := subtle.Choice::["unwrap_u8"] α1 in
        let* α3 := borrow α2 u8 in
        let* α4 := M.alloc 1 in
        let* α5 := borrow α4 u8 in
        match (α3, α5) with
        | (left_val, right_val) =>
          let* α0 := deref left_val u8 in
          let* α1 := deref right_val u8 in
          let* α2 := eq α0 α1 in
          let* α3 := not α2 in
          let* α4 := use α3 in
          if (α4 : bool) then
            let kind := core.panicking.AssertKind.Eq tt in
            let* _ :=
              let* α0 := deref left_val u8 in
              let* α1 := borrow α0 u8 in
              let* α2 := deref α1 u8 in
              let* α3 := borrow α2 u8 in
              let* α4 := deref right_val u8 in
              let* α5 := borrow α4 u8 in
              let* α6 := deref α5 u8 in
              let* α7 := borrow α6 u8 in
              core.panicking.assert_failed
                kind
                α3
                α7
                (core.option.Option.None tt) in
            let* α0 := M.alloc tt in
            never_to_any α0
          else
            M.alloc tt
        end in
      self.["value"].
    
    Global Instance AssociatedFunction_unwrap :
      Notation.DoubleColon Self "unwrap" := {
      Notation.double_colon := unwrap;
    }.
    
    Definition unwrap_or
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        (self : Self)
        (def : T)
        : M T :=
      let* α0 := borrow def T in
      let* α1 := deref α0 T in
      let* α2 := borrow α1 T in
      let* α3 := self.["value"] in
      let* α4 := borrow α3 T in
      let* α5 := deref α4 T in
      let* α6 := borrow α5 T in
      let* α7 := self.["is_some"] in
      (subtle.ConditionallySelectable.conditional_select (Self := T)) α2 α6 α7.
    
    Global Instance AssociatedFunction_unwrap_or
        {ℋ_0 : subtle.ConditionallySelectable.Trait T} :
      Notation.DoubleColon Self "unwrap_or" := {
      Notation.double_colon := unwrap_or;
    }.
    
    Definition unwrap_or_else
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
        (self : Self)
        (f : F)
        : M T :=
      let* α0 := M.alloc tt in
      let* α1 := (core.ops.function.FnOnce.call_once (Self := F)) f α0 in
      let* α2 := borrow α1 T in
      let* α3 := deref α2 T in
      let* α4 := borrow α3 T in
      let* α5 := self.["value"] in
      let* α6 := borrow α5 T in
      let* α7 := deref α6 T in
      let* α8 := borrow α7 T in
      let* α9 := self.["is_some"] in
      (subtle.ConditionallySelectable.conditional_select (Self := T)) α4 α8 α9.
    
    Global Instance AssociatedFunction_unwrap_or_else
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
      Notation.DoubleColon Self "unwrap_or_else" := {
      Notation.double_colon := unwrap_or_else (F := F);
    }.
    
    Definition is_some (self : ref Self) : M subtle.Choice :=
      let* α0 := deref self (subtle.CtOption T) in
      α0.["is_some"].
    
    Global Instance AssociatedFunction_is_some :
      Notation.DoubleColon Self "is_some" := {
      Notation.double_colon := is_some;
    }.
    
    Definition is_none (self : ref Self) : M subtle.Choice :=
      let* α0 := deref self (subtle.CtOption T) in
      let* α1 := α0.["is_some"] in
      (core.ops.bit.Not.not (Self := subtle.Choice)) α1.
    
    Global Instance AssociatedFunction_is_none :
      Notation.DoubleColon Self "is_none" := {
      Notation.double_colon := is_none;
    }.
    
    Definition map
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
        (self : Self)
        (f : F)
        : M (subtle.CtOption U) :=
      let* α0 := core.default.Default.default (Self := T) in
      let* α1 := borrow α0 T in
      let* α2 := deref α1 T in
      let* α3 := borrow α2 T in
      let* α4 := self.["value"] in
      let* α5 := borrow α4 T in
      let* α6 := deref α5 T in
      let* α7 := borrow α6 T in
      let* α8 := self.["is_some"] in
      let* α9 :=
        (subtle.ConditionallySelectable.conditional_select (Self := T))
          α3
          α7
          α8 in
      let* α10 := (core.ops.function.FnOnce.call_once (Self := F)) f (α9) in
      let* α11 := self.["is_some"] in
      (subtle.CtOption T)::["new"] α10 α11.
    
    Global Instance AssociatedFunction_map
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
      Notation.DoubleColon Self "map" := {
      Notation.double_colon := map (U := U) (F := F);
    }.
    
    Definition and_then
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
        (self : Self)
        (f : F)
        : M (subtle.CtOption U) :=
      let* tmp :=
        let* α0 := core.default.Default.default (Self := T) in
        let* α1 := borrow α0 T in
        let* α2 := deref α1 T in
        let* α3 := borrow α2 T in
        let* α4 := self.["value"] in
        let* α5 := borrow α4 T in
        let* α6 := deref α5 T in
        let* α7 := borrow α6 T in
        let* α8 := self.["is_some"] in
        let* α9 :=
          (subtle.ConditionallySelectable.conditional_select (Self := T))
            α3
            α7
            α8 in
        (core.ops.function.FnOnce.call_once (Self := F)) f (α9) in
      let* _ :=
        let* α0 := tmp.["is_some"] in
        let* α1 := borrow_mut α0 subtle.Choice in
        let* α2 := self.["is_some"] in
        (core.ops.bit.BitAndAssign.bitand_assign (Self := subtle.Choice))
          α1
          α2 in
      Pure tmp.
    
    Global Instance AssociatedFunction_and_then
        {U F : Set}
        {ℋ_0 : core.default.Default.Trait T}
        {ℋ_1 : subtle.ConditionallySelectable.Trait T}
        {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
      Notation.DoubleColon Self "and_then" := {
      Notation.double_colon := and_then (U := U) (F := F);
    }.
    
    Definition or_else
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
        (self : Self)
        (f : F)
        : M (subtle.CtOption T) :=
      let* is_none :=
        let* α0 := borrow self (subtle.CtOption T) in
        (subtle.CtOption T)::["is_none"] α0 in
      let* f :=
        let* α0 := M.alloc tt in
        (core.ops.function.FnOnce.call_once (Self := F)) f α0 in
      let* α0 := borrow self (subtle.CtOption T) in
      let* α1 := deref α0 (subtle.CtOption T) in
      let* α2 := borrow α1 (subtle.CtOption T) in
      let* α3 := borrow f (subtle.CtOption T) in
      let* α4 := deref α3 (subtle.CtOption T) in
      let* α5 := borrow α4 (subtle.CtOption T) in
      (subtle.ConditionallySelectable.conditional_select
          (Self := (subtle.CtOption T)))
        α2
        α5
        is_none.
    
    Global Instance AssociatedFunction_or_else
        {F : Set}
        {ℋ_0 : subtle.ConditionallySelectable.Trait T}
        {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
      Notation.DoubleColon Self "or_else" := {
      Notation.double_colon := or_else (F := F);
    }.
  End Impl_subtle_CtOption_T_4.
End Impl_subtle_CtOption_T_4.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : subtle.ConditionallySelectable.Trait T}.
    Definition Self : Set := subtle.CtOption T.
    
    Definition conditional_select
        (a : ref Self)
        (b : ref Self)
        (choice : subtle.Choice)
        : M Self :=
      let* α0 := deref a (subtle.CtOption T) in
      let* α1 := α0.["value"] in
      let* α2 := borrow α1 T in
      let* α3 := deref α2 T in
      let* α4 := borrow α3 T in
      let* α5 := deref b (subtle.CtOption T) in
      let* α6 := α5.["value"] in
      let* α7 := borrow α6 T in
      let* α8 := deref α7 T in
      let* α9 := borrow α8 T in
      let* α10 :=
        (subtle.ConditionallySelectable.conditional_select (Self := T))
          α4
          α9
          choice in
      let* α11 := deref a (subtle.CtOption T) in
      let* α12 := α11.["is_some"] in
      let* α13 := borrow α12 subtle.Choice in
      let* α14 := deref α13 subtle.Choice in
      let* α15 := borrow α14 subtle.Choice in
      let* α16 := deref b (subtle.CtOption T) in
      let* α17 := α16.["is_some"] in
      let* α18 := borrow α17 subtle.Choice in
      let* α19 := deref α18 subtle.Choice in
      let* α20 := borrow α19 subtle.Choice in
      let* α21 :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := subtle.Choice))
          α15
          α20
          choice in
      (subtle.CtOption T)::["new"] α10 α21.
    
    Global Instance AssociatedFunction_conditional_select :
      Notation.DoubleColon Self "conditional_select" := {
      Notation.double_colon := conditional_select;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConditionallySelectable.Trait Self := {
      subtle.ConditionallySelectable.conditional_select := conditional_select;
    }.
    Admitted.
  End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
    Context `{ℋ : State.Trait}.
    
    Context {T : Set}.
    
    Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
    Definition Self : Set := subtle.CtOption T.
    
    Definition ct_eq
        (self : ref Self)
        (rhs : ref (subtle.CtOption T))
        : M subtle.Choice :=
      let* a :=
        let* α0 := deref self (subtle.CtOption T) in
        let* α1 := borrow α0 (subtle.CtOption T) in
        (subtle.CtOption T)::["is_some"] α1 in
      let* b :=
        let* α0 := deref rhs (subtle.CtOption T) in
        let* α1 := borrow α0 (subtle.CtOption T) in
        (subtle.CtOption T)::["is_some"] α1 in
      let* α0 := (core.ops.bit.BitAnd.bitand (Self := subtle.Choice)) a b in
      let* α1 := deref self (subtle.CtOption T) in
      let* α2 := α1.["value"] in
      let* α3 := borrow α2 T in
      let* α4 := deref rhs (subtle.CtOption T) in
      let* α5 := α4.["value"] in
      let* α6 := borrow α5 T in
      let* α7 := deref α6 T in
      let* α8 := borrow α7 T in
      let* α9 := (subtle.ConstantTimeEq.ct_eq (Self := T)) α3 α8 in
      let* α10 := (core.ops.bit.BitAnd.bitand (Self := subtle.Choice)) α0 α9 in
      let* α11 := (core.ops.bit.Not.not (Self := subtle.Choice)) a in
      let* α12 := (core.ops.bit.Not.not (Self := subtle.Choice)) b in
      let* α13 :=
        (core.ops.bit.BitAnd.bitand (Self := subtle.Choice)) α11 α12 in
      (core.ops.bit.BitOr.bitor (Self := subtle.Choice)) α10 α13.
    
    Global Instance AssociatedFunction_ct_eq :
      Notation.DoubleColon Self "ct_eq" := {
      Notation.double_colon := ct_eq;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeEq.Trait Self := {
      subtle.ConstantTimeEq.ct_eq := ct_eq;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module ConstantTimeGreater.
  Section ConstantTimeGreater.
    Context `{ℋ : State.Trait}.
    
    Class Trait (Self : Set) : Type := {
      ct_gt : (ref Self) -> (ref Self) -> M subtle.Choice;
    }.
    
  End ConstantTimeGreater.
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  Section Impl_subtle_ConstantTimeGreater_for_u8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u8.
    
    Definition ct_gt (self : ref Self) (other : ref u8) : M subtle.Choice :=
      let* gtb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u8))) other in
        (core.ops.bit.BitAnd.bitand (Self := (ref u8))) self α0 in
      let* ltb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u8))) self in
        (core.ops.bit.BitAnd.bitand (Self := u8)) α0 other in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 8 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* bit :=
        let* α0 := not ltb in
        bitand gtb α0 in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 8 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr bit pow in
              assign_op bitor bit α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* α0 := M.alloc 1 in
      let* α1 := bitand bit α0 in
      let* α2 := use α1 in
      (core.convert.From.from (Self := subtle.Choice)) α2.
    
    Global Instance AssociatedFunction_ct_gt :
      Notation.DoubleColon Self "ct_gt" := {
      Notation.double_colon := ct_gt;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
      subtle.ConstantTimeGreater.ct_gt := ct_gt;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeGreater_for_u8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  Section Impl_subtle_ConstantTimeGreater_for_u16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u16.
    
    Definition ct_gt (self : ref Self) (other : ref u16) : M subtle.Choice :=
      let* gtb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u16))) other in
        (core.ops.bit.BitAnd.bitand (Self := (ref u16))) self α0 in
      let* ltb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u16))) self in
        (core.ops.bit.BitAnd.bitand (Self := u16)) α0 other in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 16 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* bit :=
        let* α0 := not ltb in
        bitand gtb α0 in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 16 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr bit pow in
              assign_op bitor bit α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* α0 := M.alloc 1 in
      let* α1 := bitand bit α0 in
      let* α2 := cast α1 in
      (core.convert.From.from (Self := subtle.Choice)) α2.
    
    Global Instance AssociatedFunction_ct_gt :
      Notation.DoubleColon Self "ct_gt" := {
      Notation.double_colon := ct_gt;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
      subtle.ConstantTimeGreater.ct_gt := ct_gt;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeGreater_for_u16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  Section Impl_subtle_ConstantTimeGreater_for_u32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u32.
    
    Definition ct_gt (self : ref Self) (other : ref u32) : M subtle.Choice :=
      let* gtb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u32))) other in
        (core.ops.bit.BitAnd.bitand (Self := (ref u32))) self α0 in
      let* ltb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u32))) self in
        (core.ops.bit.BitAnd.bitand (Self := u32)) α0 other in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 32 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* bit :=
        let* α0 := not ltb in
        bitand gtb α0 in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 32 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr bit pow in
              assign_op bitor bit α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* α0 := M.alloc 1 in
      let* α1 := bitand bit α0 in
      let* α2 := cast α1 in
      (core.convert.From.from (Self := subtle.Choice)) α2.
    
    Global Instance AssociatedFunction_ct_gt :
      Notation.DoubleColon Self "ct_gt" := {
      Notation.double_colon := ct_gt;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
      subtle.ConstantTimeGreater.ct_gt := ct_gt;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeGreater_for_u32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  Section Impl_subtle_ConstantTimeGreater_for_u64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u64.
    
    Definition ct_gt (self : ref Self) (other : ref u64) : M subtle.Choice :=
      let* gtb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u64))) other in
        (core.ops.bit.BitAnd.bitand (Self := (ref u64))) self α0 in
      let* ltb :=
        let* α0 := (core.ops.bit.Not.not (Self := (ref u64))) self in
        (core.ops.bit.BitAnd.bitand (Self := u64)) α0 other in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 64 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr ltb pow in
              assign_op bitor ltb α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* bit :=
        let* α0 := not ltb in
        bitand gtb α0 in
      let* pow := M.alloc 1 in
      let* _ :=
        loop
          (let* α0 := M.alloc 64 in
          let* α1 := lt pow α0 in
          let* α2 := use α1 in
          if (α2 : bool) then
            let* _ :=
              let* α0 := shr bit pow in
              assign_op bitor bit α0 in
            let* _ := assign_op add pow pow in
            M.alloc tt
          else
            let* _ :=
              let* α0 := Break in
              never_to_any α0 in
            let* α0 := M.alloc tt in
            never_to_any α0) in
      let* α0 := M.alloc 1 in
      let* α1 := bitand bit α0 in
      let* α2 := cast α1 in
      (core.convert.From.from (Self := subtle.Choice)) α2.
    
    Global Instance AssociatedFunction_ct_gt :
      Notation.DoubleColon Self "ct_gt" := {
      Notation.double_colon := ct_gt;
    }.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
      subtle.ConstantTimeGreater.ct_gt := ct_gt;
    }.
    Admitted.
  End Impl_subtle_ConstantTimeGreater_for_u64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Section ConstantTimeLess.
    Context `{ℋ : State.Trait}.
    
    Class Trait (Self : Set) : Type := {
      ℒ_0 :: subtle.ConstantTimeEq.Trait Self;
      ℒ_1 :: subtle.ConstantTimeGreater.Trait Self;
    }.
    
  End ConstantTimeLess.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Section Impl_subtle_ConstantTimeLess_for_u8.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u8.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeLess.Trait Self := {
    }.
    Admitted.
  End Impl_subtle_ConstantTimeLess_for_u8.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Section Impl_subtle_ConstantTimeLess_for_u16.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u16.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeLess.Trait Self := {
    }.
    Admitted.
  End Impl_subtle_ConstantTimeLess_for_u16.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Section Impl_subtle_ConstantTimeLess_for_u32.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u32.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeLess.Trait Self := {
    }.
    Admitted.
  End Impl_subtle_ConstantTimeLess_for_u32.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Section Impl_subtle_ConstantTimeLess_for_u64.
    Context `{ℋ : State.Trait}.
    
    Definition Self : Set := u64.
    
    #[refine] Global Instance ℐ : subtle.ConstantTimeLess.Trait Self := {
    }.
    Admitted.
  End Impl_subtle_ConstantTimeLess_for_u64.
  Global Hint Resolve ℐ : core.
End Impl_subtle_ConstantTimeLess_for_u64.
