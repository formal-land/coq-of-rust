(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module  Choice.
Section Choice.
  Context `{ℋ : State.Trait}.
  
  Unset Primitive Projections.
  Record t : Set := {
    x0 : u8;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_0 : Notation.Dot "0" := {
    Notation.dot x := let* x := M.read x in Pure x.(x0) : M _;
  }.
End Choice.
End Choice.
Definition Choice `{ℋ : State.Trait} : Set := M.val Choice.t.

Module  Impl_core_marker_Copy_for_subtle_Choice.
Section Impl_core_marker_Copy_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_subtle_Choice.
End Impl_core_marker_Copy_for_subtle_Choice.

Module  Impl_core_clone_Clone_for_subtle_Choice.
Section Impl_core_clone_Clone_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition clone (self : ref Self) : M subtle.Choice :=
    let* _ := M.alloc tt in
    deref self subtle.Choice.
  
  Global Instance AssociatedFunction_clone :
    Notation.DoubleColon Self "clone" := {
    Notation.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_Choice.
End Impl_core_clone_Clone_for_subtle_Choice.

Module  Impl_core_fmt_Debug_for_subtle_Choice.
Section Impl_core_fmt_Debug_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M ltac:(core.fmt.Result) :=
    let* α0 := deref f core.fmt.Formatter in
    let* α1 := borrow_mut α0 core.fmt.Formatter in
    let* α2 := deref (mk_str "Choice") str in
    let* α3 := borrow α2 str in
    let* α4 := deref self subtle.Choice in
    let* α5 := α4.["0"] in
    let* α6 := borrow α5 u8 in
    let* α7 := borrow α6 (ref u8) in
    let* α8 := deref α7 (ref u8) in
    let* α9 := borrow α8 (ref u8) in
    let* α10 := pointer_coercion "Unsize" α9 in
    core.fmt.Formatter::["debug_tuple_field1_finish"] α1 α3 α10.
  
  Global Instance AssociatedFunction_fmt : Notation.DoubleColon Self "fmt" := {
    Notation.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_Choice.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module  Impl_subtle_Choice.
Section Impl_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition unwrap_u8 (self : ref Self) : M u8 :=
    let* α0 := deref self subtle.Choice in
    α0.["0"].
  
  Global Instance AssociatedFunction_unwrap_u8 :
    Notation.DoubleColon Self "unwrap_u8" := {
    Notation.double_colon := unwrap_u8;
  }.
End Impl_subtle_Choice.
End Impl_subtle_Choice.

Module  Impl_core_convert_From_subtle_Choice_for_bool.
Section Impl_core_convert_From_subtle_Choice_for_bool.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := bool.
  
  Definition from (source : subtle.Choice) : M bool :=
    let* _ :=
      let* α0 := M.alloc true in
      let* α1 := use α0 in
      if (α1 : bool) then
        let* _ :=
          let* α0 := source.["0"] in
          let* α1 := M.alloc 0 in
          let* α2 := BinOp.eq α0 α1 in
          let* α3 := source.["0"] in
          let* α4 := M.alloc 1 in
          let* α5 := BinOp.eq α3 α4 in
          let* α6 := BinOp.bit_or α2 α5 in
          let* α7 := UnOp.not α6 in
          let* α8 := use α7 in
          if (α8 : bool) then
            let* α0 :=
              core.panicking.panic
                (mk_str
                  "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)") in
            never_to_any α0
          else
            M.alloc tt in
        M.alloc tt
      else
        M.alloc tt in
    let* α0 := source.["0"] in
    let* α1 := M.alloc 0 in
    BinOp.ne α0 α1.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := subtle.Choice) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_Choice_for_bool.
End Impl_core_convert_From_subtle_Choice_for_bool.

Module  Impl_core_ops_bit_BitAnd_for_subtle_Choice.
Section Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitand (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := BinOp.bit_and α0 α1 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α2.
  
  Global Instance AssociatedFunction_bitand :
    Notation.DoubleColon Self "bitand" := {
    Notation.double_colon := bitand;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAnd.Trait Self
      (Rhs := core.ops.bit.BitAnd.Default.Rhs Self) := {
    core.ops.bit.BitAnd.Output := Output;
    core.ops.bit.BitAnd.bitand := bitand;
  }.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module  Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition bitand_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 :=
        (core.ops.bit.BitAnd.bitand
            (Self := subtle.Choice)
            (Trait := ltac:(refine _)))
          α1
          rhs in
      assign α0 α2 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_bitand_assign :
    Notation.DoubleColon Self "bitand_assign" := {
    Notation.double_colon := bitand_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitAndAssign.Trait Self
      (Rhs := core.ops.bit.BitAndAssign.Default.Rhs Self) := {
    core.ops.bit.BitAndAssign.bitand_assign := bitand_assign;
  }.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_BitOr_for_subtle_Choice.
Section Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitor (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := BinOp.bit_or α0 α1 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α2.
  
  Global Instance AssociatedFunction_bitor :
    Notation.DoubleColon Self "bitor" := {
    Notation.double_colon := bitor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOr.Trait Self
      (Rhs := core.ops.bit.BitOr.Default.Rhs Self) := {
    core.ops.bit.BitOr.Output := Output;
    core.ops.bit.BitOr.bitor := bitor;
  }.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module  Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition bitor_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 :=
        (core.ops.bit.BitOr.bitor
            (Self := subtle.Choice)
            (Trait := ltac:(refine _)))
          α1
          rhs in
      assign α0 α2 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_bitor_assign :
    Notation.DoubleColon Self "bitor_assign" := {
    Notation.double_colon := bitor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitOrAssign.Trait Self
      (Rhs := core.ops.bit.BitOrAssign.Default.Rhs Self) := {
    core.ops.bit.BitOrAssign.bitor_assign := bitor_assign;
  }.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_BitXor_for_subtle_Choice.
Section Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitxor (self : Self) (rhs : subtle.Choice) : M subtle.Choice :=
    let* α0 := self.["0"] in
    let* α1 := rhs.["0"] in
    let* α2 := BinOp.bit_xor α0 α1 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α2.
  
  Global Instance AssociatedFunction_bitxor :
    Notation.DoubleColon Self "bitxor" := {
    Notation.double_colon := bitxor;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXor.Trait Self
      (Rhs := core.ops.bit.BitXor.Default.Rhs Self) := {
    core.ops.bit.BitXor.Output := Output;
    core.ops.bit.BitXor.bitxor := bitxor;
  }.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module  Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
Section Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition bitxor_assign
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M unit :=
    let* _ :=
      let* α0 := deref self subtle.Choice in
      let* α1 := deref self subtle.Choice in
      let* α2 :=
        (core.ops.bit.BitXor.bitxor
            (Self := subtle.Choice)
            (Trait := ltac:(refine _)))
          α1
          rhs in
      assign α0 α2 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_bitxor_assign :
    Notation.DoubleColon Self "bitxor_assign" := {
    Notation.double_colon := bitxor_assign;
  }.
  
  Global Instance ℐ :
    core.ops.bit.BitXorAssign.Trait Self
      (Rhs := core.ops.bit.BitXorAssign.Default.Rhs Self) := {
    core.ops.bit.BitXorAssign.bitxor_assign := bitxor_assign;
  }.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module  Impl_core_ops_bit_Not_for_subtle_Choice.
Section Impl_core_ops_bit_Not_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition not (self : Self) : M subtle.Choice :=
    let* α0 := M.alloc 1 in
    let* α1 := self.["0"] in
    let* α2 := UnOp.not α1 in
    let* α3 := BinOp.bit_and α0 α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_not : Notation.DoubleColon Self "not" := {
    Notation.double_colon := not;
  }.
  
  Global Instance ℐ : core.ops.bit.Not.Trait Self := {
    core.ops.bit.Not.Output := Output;
    core.ops.bit.Not.not := not;
  }.
End Impl_core_ops_bit_Not_for_subtle_Choice.
End Impl_core_ops_bit_Not_for_subtle_Choice.

Definition black_box `{ℋ : State.Trait} (input : u8) : M u8 :=
  let* _ :=
    let* α0 := M.alloc true in
    let* α1 := use α0 in
    if (α1 : bool) then
      let* _ :=
        let* α0 := M.alloc 0 in
        let* α1 := BinOp.eq input α0 in
        let* α2 := M.alloc 1 in
        let* α3 := BinOp.eq input α2 in
        let* α4 := BinOp.bit_or α1 α3 in
        let* α5 := UnOp.not α4 in
        let* α6 := use α5 in
        if (α6 : bool) then
          let* α0 :=
            core.panicking.panic
              (mk_str "assertion failed: (input == 0u8) | (input == 1u8)") in
          never_to_any α0
        else
          M.alloc tt in
      M.alloc tt
    else
      M.alloc tt in
  let* α0 := borrow input u8 in
  let* α1 := deref α0 u8 in
  let* α2 := addr_of α1 in
  let* α3 := use α2 in
  core.ptr.read_volatile α3.

Module  Impl_core_convert_From_u8_for_subtle_Choice.
Section Impl_core_convert_From_u8_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition from (input : u8) : M subtle.Choice :=
    let* α0 := subtle.black_box input in
    M.alloc (subtle.Choice.Build_t α0).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := u8) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_u8_for_subtle_Choice.
End Impl_core_convert_From_u8_for_subtle_Choice.

Module  ConstantTimeEq.
Section ConstantTimeEq.
  Context `{ℋ : State.Trait}.
  
  Class Trait (Self : Set) : Type := {
    ct_eq : (ref Self) -> (ref Self) -> M subtle.Choice;
  }.
  
End ConstantTimeEq.
End ConstantTimeEq.

Module  Impl_subtle_ConstantTimeEq_for_Slice_T.
Section Impl_subtle_ConstantTimeEq_for_Slice_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  Definition Self : Set := Slice T.
  
  Definition ct_eq (self : ref Self) (_rhs : ref (Slice T)) : M subtle.Choice :=
    let* len :=
      let* α0 := deref self (Slice T) in
      let* α1 := borrow α0 (Slice T) in
      (Slice T)::["len"] α1 in
    let* _ :=
      let* α0 := deref _rhs (Slice T) in
      let* α1 := borrow α0 (Slice T) in
      let* α2 := (Slice T)::["len"] α1 in
      let* α3 := BinOp.ne len α2 in
      let* α4 := use α3 in
      if (α4 : bool) then
        let* _ :=
          let* α0 := M.alloc 0 in
          let* α1 :=
            (core.convert.From.from
                (Self := subtle.Choice)
                (Trait := ltac:(refine _)))
              α0 in
          Return α1 in
        let* α0 := M.alloc tt in
        never_to_any α0
      else
        M.alloc tt in
    let* x := M.alloc 1 in
    let* _ :=
      let* α0 := deref self (Slice T) in
      let* α1 := borrow α0 (Slice T) in
      let* α2 := (Slice T)::["iter"] α1 in
      let* α3 := deref _rhs (Slice T) in
      let* α4 := borrow α3 (Slice T) in
      let* α5 := (Slice T)::["iter"] α4 in
      let* α6 :=
        (core.iter.traits.iterator.Iterator.zip
            (Self := core.slice.iter.Iter T)
            (Trait := ltac:(refine _)))
          α2
          α5 in
      let* α7 :=
        (core.iter.traits.collect.IntoIterator.into_iter
            (Self :=
              core.iter.adapters.zip.Zip
                (core.slice.iter.Iter T)
                (core.slice.iter.Iter T))
            (Trait := ltac:(refine _)))
          α6 in
      let* α8 :=
        match α7 with
        | iter =>
          loop
            (let* _ :=
              let* α0 :=
                borrow_mut
                  iter
                  (core.iter.adapters.zip.Zip
                    (core.slice.iter.Iter T)
                    (core.slice.iter.Iter T)) in
              let* α1 :=
                deref
                  α0
                  (core.iter.adapters.zip.Zip
                    (core.slice.iter.Iter T)
                    (core.slice.iter.Iter T)) in
              let* α2 :=
                borrow_mut
                  α1
                  (core.iter.adapters.zip.Zip
                    (core.slice.iter.Iter T)
                    (core.slice.iter.Iter T)) in
              let* α3 :=
                (core.iter.traits.iterator.Iterator.next
                    (Self :=
                      core.iter.adapters.zip.Zip
                        (core.slice.iter.Iter T)
                        (core.slice.iter.Iter T))
                    (Trait := ltac:(refine _)))
                  α2 in
              match α3 with
              | core.option.Option  =>
                let* α0 := Break in
                never_to_any α0
              | core.option.Option (ai, bi) =>
                let* _ :=
                  let* α0 := deref ai T in
                  let* α1 := borrow α0 T in
                  let* α2 := deref bi T in
                  let* α3 := borrow α2 T in
                  let* α4 :=
                    (subtle.ConstantTimeEq.ct_eq
                        (Self := T)
                        (Trait := ltac:(refine _)))
                      α1
                      α3 in
                  let* α5 := borrow α4 subtle.Choice in
                  let* α6 := subtle.Choice::["unwrap_u8"] α5 in
                  assign_op bitand x α6 in
                M.alloc tt
              end in
            M.alloc tt)
        end in
      use α8 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) x.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_Slice_T.
End Impl_subtle_ConstantTimeEq_for_Slice_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_Choice.
Section Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition ct_eq
      (self : ref Self)
      (rhs : ref subtle.Choice)
      : M subtle.Choice :=
    let* α0 := deref self subtle.Choice in
    let* α1 := deref rhs subtle.Choice in
    let* α2 :=
      (core.ops.bit.BitXor.bitxor
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α0
        α1 in
    (core.ops.bit.Not.not (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α2.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module  Impl_subtle_ConstantTimeEq_for_u8.
Section Impl_subtle_ConstantTimeEq_for_u8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u8.
  
  Definition ct_eq (self : ref Self) (other : ref u8) : M subtle.Choice :=
    let* x :=
      (core.ops.bit.BitXor.bitxor (Self := ref u8) (Trait := ltac:(refine _)))
        self
        other in
    let* y :=
      let* α0 := u8::["wrapping_neg"] x in
      let* α1 := BinOp.bit_or x α0 in
      let* α2 := M.alloc 8 in
      let* α3 := M.alloc 1 in
      let* α4 := BinOp.sub α2 α3 in
      BinOp.shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := BinOp.bit_xor y α1 in
    let* α3 := use α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u8.
End Impl_subtle_ConstantTimeEq_for_u8.

Module  Impl_subtle_ConstantTimeEq_for_i8.
Section Impl_subtle_ConstantTimeEq_for_i8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i8.
  
  Definition ct_eq (self : ref Self) (other : ref i8) : M subtle.Choice :=
    let* α0 := deref self i8 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u8 in
    let* α3 := deref other i8 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u8 in
    let* α6 := deref α5 u8 in
    let* α7 := borrow α6 u8 in
    (subtle.ConstantTimeEq.ct_eq (Self := u8) (Trait := ltac:(refine _))) α2 α7.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i8.
End Impl_subtle_ConstantTimeEq_for_i8.

Module  Impl_subtle_ConstantTimeEq_for_u16.
Section Impl_subtle_ConstantTimeEq_for_u16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u16.
  
  Definition ct_eq (self : ref Self) (other : ref u16) : M subtle.Choice :=
    let* x :=
      (core.ops.bit.BitXor.bitxor (Self := ref u16) (Trait := ltac:(refine _)))
        self
        other in
    let* y :=
      let* α0 := u16::["wrapping_neg"] x in
      let* α1 := BinOp.bit_or x α0 in
      let* α2 := M.alloc 16 in
      let* α3 := M.alloc 1 in
      let* α4 := BinOp.sub α2 α3 in
      BinOp.shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := BinOp.bit_xor y α1 in
    let* α3 := cast α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u16.
End Impl_subtle_ConstantTimeEq_for_u16.

Module  Impl_subtle_ConstantTimeEq_for_i16.
Section Impl_subtle_ConstantTimeEq_for_i16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i16.
  
  Definition ct_eq (self : ref Self) (other : ref i16) : M subtle.Choice :=
    let* α0 := deref self i16 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u16 in
    let* α3 := deref other i16 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u16 in
    let* α6 := deref α5 u16 in
    let* α7 := borrow α6 u16 in
    (subtle.ConstantTimeEq.ct_eq (Self := u16) (Trait := ltac:(refine _)))
      α2
      α7.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i16.
End Impl_subtle_ConstantTimeEq_for_i16.

Module  Impl_subtle_ConstantTimeEq_for_u32.
Section Impl_subtle_ConstantTimeEq_for_u32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u32.
  
  Definition ct_eq (self : ref Self) (other : ref u32) : M subtle.Choice :=
    let* x :=
      (core.ops.bit.BitXor.bitxor (Self := ref u32) (Trait := ltac:(refine _)))
        self
        other in
    let* y :=
      let* α0 := u32::["wrapping_neg"] x in
      let* α1 := BinOp.bit_or x α0 in
      let* α2 := M.alloc 32 in
      let* α3 := M.alloc 1 in
      let* α4 := BinOp.sub α2 α3 in
      BinOp.shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := BinOp.bit_xor y α1 in
    let* α3 := cast α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u32.
End Impl_subtle_ConstantTimeEq_for_u32.

Module  Impl_subtle_ConstantTimeEq_for_i32.
Section Impl_subtle_ConstantTimeEq_for_i32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i32.
  
  Definition ct_eq (self : ref Self) (other : ref i32) : M subtle.Choice :=
    let* α0 := deref self i32 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u32 in
    let* α3 := deref other i32 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u32 in
    let* α6 := deref α5 u32 in
    let* α7 := borrow α6 u32 in
    (subtle.ConstantTimeEq.ct_eq (Self := u32) (Trait := ltac:(refine _)))
      α2
      α7.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i32.
End Impl_subtle_ConstantTimeEq_for_i32.

Module  Impl_subtle_ConstantTimeEq_for_u64.
Section Impl_subtle_ConstantTimeEq_for_u64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u64.
  
  Definition ct_eq (self : ref Self) (other : ref u64) : M subtle.Choice :=
    let* x :=
      (core.ops.bit.BitXor.bitxor (Self := ref u64) (Trait := ltac:(refine _)))
        self
        other in
    let* y :=
      let* α0 := u64::["wrapping_neg"] x in
      let* α1 := BinOp.bit_or x α0 in
      let* α2 := M.alloc 64 in
      let* α3 := M.alloc 1 in
      let* α4 := BinOp.sub α2 α3 in
      BinOp.shr α1 α4 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := BinOp.bit_xor y α1 in
    let* α3 := cast α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_u64.
End Impl_subtle_ConstantTimeEq_for_u64.

Module  Impl_subtle_ConstantTimeEq_for_i64.
Section Impl_subtle_ConstantTimeEq_for_i64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i64.
  
  Definition ct_eq (self : ref Self) (other : ref i64) : M subtle.Choice :=
    let* α0 := deref self i64 in
    let* α1 := cast α0 in
    let* α2 := borrow α1 u64 in
    let* α3 := deref other i64 in
    let* α4 := cast α3 in
    let* α5 := borrow α4 u64 in
    let* α6 := deref α5 u64 in
    let* α7 := borrow α6 u64 in
    (subtle.ConstantTimeEq.ct_eq (Self := u64) (Trait := ltac:(refine _)))
      α2
      α7.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_i64.
End Impl_subtle_ConstantTimeEq_for_i64.

Module  Impl_subtle_ConstantTimeEq_for_usize.
Section Impl_subtle_ConstantTimeEq_for_usize.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := usize.
  
  Definition ct_eq (self : ref Self) (other : ref usize) : M subtle.Choice :=
    let* x :=
      (core.ops.bit.BitXor.bitxor
          (Self := ref usize)
          (Trait := ltac:(refine _)))
        self
        other in
    let* y :=
      let* α0 := usize::["wrapping_neg"] x in
      let* α1 := BinOp.bit_or x α0 in
      let* α2 := core.mem.size_of in
      let* α3 := M.alloc 8 in
      let* α4 := BinOp.mul α2 α3 in
      let* α5 := M.alloc 1 in
      let* α6 := BinOp.sub α4 α5 in
      BinOp.shr α1 α6 in
    let* α0 := M.alloc 1 in
    let* α1 := use α0 in
    let* α2 := BinOp.bit_xor y α1 in
    let* α3 := cast α2 in
    (core.convert.Into.into (Self := u8) (Trait := ltac:(refine _))) α3.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_usize.
End Impl_subtle_ConstantTimeEq_for_usize.

Module  Impl_subtle_ConstantTimeEq_for_isize.
Section Impl_subtle_ConstantTimeEq_for_isize.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := isize.
  
  Definition ct_eq (self : ref Self) (other : ref isize) : M subtle.Choice :=
    let* α0 := deref self isize in
    let* α1 := cast α0 in
    let* α2 := borrow α1 usize in
    let* α3 := deref other isize in
    let* α4 := cast α3 in
    let* α5 := borrow α4 usize in
    let* α6 := deref α5 usize in
    let* α7 := borrow α6 usize in
    (subtle.ConstantTimeEq.ct_eq (Self := usize) (Trait := ltac:(refine _)))
      α2
      α7.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_isize.
End Impl_subtle_ConstantTimeEq_for_isize.

Module  ConditionallySelectable.
Section ConditionallySelectable.
  Context `{ℋ : State.Trait}.
  
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: core.marker.Copy.Trait Self;
    conditional_select : (ref Self) -> (ref Self) -> subtle.Choice -> M Self;
  }.
  
End ConditionallySelectable.
End ConditionallySelectable.

Module  Impl_subtle_ConditionallySelectable_for_u8.
Section Impl_subtle_ConditionallySelectable_for_u8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref u8) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref u8) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u8 in
      let* α1 := deref self u8 in
      let* α2 := deref other u8 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u8 in
      let* α1 := deref b u8 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a u8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u8 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u8.
End Impl_subtle_ConditionallySelectable_for_u8.

Module  Impl_subtle_ConditionallySelectable_for_i8.
Section Impl_subtle_ConditionallySelectable_for_i8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref i8) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref i8) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i8 in
      let* α1 := deref self i8 in
      let* α2 := deref other i8 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i8 in
      let* α1 := deref b i8 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a i8 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i8 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i8.
End Impl_subtle_ConditionallySelectable_for_i8.

Module  Impl_subtle_ConditionallySelectable_for_u16.
Section Impl_subtle_ConditionallySelectable_for_u16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref u16) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref u16) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u16 in
      let* α1 := deref self u16 in
      let* α2 := deref other u16 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u16 in
      let* α1 := deref b u16 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a u16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u16 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u16.
End Impl_subtle_ConditionallySelectable_for_u16.

Module  Impl_subtle_ConditionallySelectable_for_i16.
Section Impl_subtle_ConditionallySelectable_for_i16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref i16) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref i16) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i16 in
      let* α1 := deref self i16 in
      let* α2 := deref other i16 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i16 in
      let* α1 := deref b i16 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a i16 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i16 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i16.
End Impl_subtle_ConditionallySelectable_for_i16.

Module  Impl_subtle_ConditionallySelectable_for_u32.
Section Impl_subtle_ConditionallySelectable_for_u32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref u32) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref u32) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u32 in
      let* α1 := deref self u32 in
      let* α2 := deref other u32 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u32 in
      let* α1 := deref b u32 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a u32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u32 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u32.
End Impl_subtle_ConditionallySelectable_for_u32.

Module  Impl_subtle_ConditionallySelectable_for_i32.
Section Impl_subtle_ConditionallySelectable_for_i32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref i32) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref i32) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i32 in
      let* α1 := deref self i32 in
      let* α2 := deref other i32 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i32 in
      let* α1 := deref b i32 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a i32 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i32 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i32.
End Impl_subtle_ConditionallySelectable_for_i32.

Module  Impl_subtle_ConditionallySelectable_for_u64.
Section Impl_subtle_ConditionallySelectable_for_u64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref u64) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref u64) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* _ :=
      let* α0 := deref self u64 in
      let* α1 := deref self u64 in
      let* α2 := deref other u64 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      cast α3 in
    let* t :=
      let* α0 := deref a u64 in
      let* α1 := deref b u64 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a u64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b u64 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_u64.
End Impl_subtle_ConditionallySelectable_for_u64.

Module  Impl_subtle_ConditionallySelectable_for_i64.
Section Impl_subtle_ConditionallySelectable_for_i64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := i64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* α0 :=
      (core.ops.bit.BitXor.bitxor (Self := ref i64) (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := BinOp.bit_and mask α0 in
    (core.ops.bit.BitXor.bitxor (Self := ref i64) (Trait := ltac:(refine _)))
      a
      α1.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* _ :=
      let* α0 := deref self i64 in
      let* α1 := deref self i64 in
      let* α2 := deref other i64 in
      let* α3 := BinOp.bit_xor α1 α2 in
      let* α4 := BinOp.bit_and mask α3 in
      assign_op bitxor α0 α4 in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_assign :
    Notation.DoubleColon Self "conditional_assign" := {
    Notation.double_colon := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* mask :=
      let* α0 := borrow choice subtle.Choice in
      let* α1 := subtle.Choice::["unwrap_u8"] α0 in
      let* α2 := cast α1 in
      let* α3 := UnOp.neg α2 in
      use α3 in
    let* t :=
      let* α0 := deref a i64 in
      let* α1 := deref b i64 in
      let* α2 := BinOp.bit_xor α0 α1 in
      BinOp.bit_and mask α2 in
    let* _ :=
      let* α0 := deref a i64 in
      assign_op bitxor α0 t in
    let* _ :=
      let* α0 := deref b i64 in
      assign_op bitxor α0 t in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign :=
      Datatypes.Some conditional_assign;
    subtle.ConditionallySelectable.conditional_swap :=
      Datatypes.Some conditional_swap;
  }.
End Impl_subtle_ConditionallySelectable_for_i64.
End Impl_subtle_ConditionallySelectable_for_i64.

Module  Impl_subtle_ConditionallySelectable_for_subtle_Choice.
Section Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := subtle.Choice.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* α0 := deref a subtle.Choice in
    let* α1 := α0.["0"] in
    let* α2 := borrow α1 u8 in
    let* α3 := deref α2 u8 in
    let* α4 := borrow α3 u8 in
    let* α5 := deref b subtle.Choice in
    let* α6 := α5.["0"] in
    let* α7 := borrow α6 u8 in
    let* α8 := deref α7 u8 in
    let* α9 := borrow α8 u8 in
    let* α10 :=
      (subtle.ConditionallySelectable.conditional_select
          (Self := u8)
          (Trait := ltac:(refine _)))
        α4
        α9
        choice in
    M.alloc (subtle.Choice.Build_t α10).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module  ConditionallyNegatable.
Section ConditionallyNegatable.
  Context `{ℋ : State.Trait}.
  
  Class Trait (Self : Set) : Type := {
    conditional_negate : (mut_ref Self) -> subtle.Choice -> M unit;
  }.
  
End ConditionallyNegatable.
End ConditionallyNegatable.

Module  Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context
    {ℋ_0 : subtle.ConditionallySelectable.Trait T}
    {ℋ_1 : core.ops.arith.Neg.Trait (ref T)}.
  Definition Self : Set := T.
  
  Definition conditional_negate
      (self : mut_ref Self)
      (choice : subtle.Choice)
      : M unit :=
    let* self_neg :=
      let* α0 := deref self T in
      let* α1 := borrow α0 T in
      let* α2 := use α1 in
      (core.ops.arith.Neg.neg (Self := ref T) (Trait := ltac:(refine _)))
        (α2 : (ref T)) in
    let* _ :=
      let* α0 := deref self T in
      let* α1 := borrow_mut α0 T in
      let* α2 := borrow self_neg T in
      let* α3 := deref α2 T in
      let* α4 := borrow α3 T in
      (subtle.ConditionallySelectable.conditional_assign
          (Self := T)
          (Trait := ltac:(refine _)))
        α1
        α4
        choice in
    M.alloc tt.
  
  Global Instance AssociatedFunction_conditional_negate :
    Notation.DoubleColon Self "conditional_negate" := {
    Notation.double_colon := conditional_negate;
  }.
  
  Global Instance ℐ : subtle.ConditionallyNegatable.Trait Self := {
    subtle.ConditionallyNegatable.conditional_negate := conditional_negate;
  }.
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.

Module  CtOption.
Section CtOption.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Unset Primitive Projections.
  Record t : Set := {
    value : T;
    is_some : subtle.Choice;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot x := let* x := M.read x in Pure x.(value) : M _;
  }.
  Global Instance Get_AF_value : Notation.DoubleColon t "value" := {
    Notation.double_colon x := let* x := M.read x in Pure x.(value) : M _;
  }.
  Global Instance Get_is_some : Notation.Dot "is_some" := {
    Notation.dot x := let* x := M.read x in Pure x.(is_some) : M _;
  }.
  Global Instance Get_AF_is_some : Notation.DoubleColon t "is_some" := {
    Notation.double_colon x := let* x := M.read x in Pure x.(is_some) : M _;
  }.
End CtOption.
End CtOption.
Definition CtOption (T : Set) `{ℋ : State.Trait} : Set :=
  M.val (CtOption.t (T := T)).

Module  Impl_core_clone_Clone_for_subtle_CtOption_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : core.clone.Clone.Trait T}.
  Definition Self : Set := subtle.CtOption T.
  
  Definition clone (self : ref Self) : M (subtle.CtOption T) :=
    let* α0 := deref self (subtle.CtOption T) in
    let* α1 := α0.["value"] in
    let* α2 := borrow α1 T in
    let* α3 := deref α2 T in
    let* α4 := borrow α3 T in
    let* α5 :=
      (core.clone.Clone.clone (Self := T) (Trait := ltac:(refine _))) α4 in
    let* α6 := deref self (subtle.CtOption T) in
    let* α7 := α6.["is_some"] in
    let* α8 := borrow α7 subtle.Choice in
    let* α9 := deref α8 subtle.Choice in
    let* α10 := borrow α9 subtle.Choice in
    let* α11 :=
      (core.clone.Clone.clone
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α10 in
    M.alloc {| subtle.CtOption.value := α5; subtle.CtOption.is_some := α11; |}.
  
  Global Instance AssociatedFunction_clone :
    Notation.DoubleColon Self "clone" := {
    Notation.double_colon := clone;
  }.
  
  Global Instance ℐ : core.clone.Clone.Required.Trait Self := {
    core.clone.Clone.clone := clone;
    core.clone.Clone.clone_from := Datatypes.None;
  }.
End Impl_core_clone_Clone_for_subtle_CtOption_T.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module  Impl_core_marker_Copy_for_subtle_CtOption_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : core.marker.Copy.Trait T}.
  Definition Self : Set := subtle.CtOption T.
  
  Global Instance ℐ : core.marker.Copy.Trait Self := {
  }.
End Impl_core_marker_Copy_for_subtle_CtOption_T.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module  Impl_core_fmt_Debug_for_subtle_CtOption_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : core.fmt.Debug.Trait T}.
  Definition Self : Set := subtle.CtOption T.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M ltac:(core.fmt.Result) :=
    let* α0 := deref f core.fmt.Formatter in
    let* α1 := borrow_mut α0 core.fmt.Formatter in
    let* α2 := deref (mk_str "CtOption") str in
    let* α3 := borrow α2 str in
    let* α4 := deref (mk_str "value") str in
    let* α5 := borrow α4 str in
    let* α6 := deref self (subtle.CtOption T) in
    let* α7 := α6.["value"] in
    let* α8 := borrow α7 T in
    let* α9 := deref α8 T in
    let* α10 := borrow α9 T in
    let* α11 := pointer_coercion "Unsize" α10 in
    let* α12 := deref (mk_str "is_some") str in
    let* α13 := borrow α12 str in
    let* α14 := deref self (subtle.CtOption T) in
    let* α15 := α14.["is_some"] in
    let* α16 := borrow α15 subtle.Choice in
    let* α17 := borrow α16 (ref subtle.Choice) in
    let* α18 := deref α17 (ref subtle.Choice) in
    let* α19 := borrow α18 (ref subtle.Choice) in
    let* α20 := pointer_coercion "Unsize" α19 in
    core.fmt.Formatter::["debug_struct_field2_finish"] α1 α3 α5 α11 α13 α20.
  
  Global Instance AssociatedFunction_fmt : Notation.DoubleColon Self "fmt" := {
    Notation.double_colon := fmt;
  }.
  
  Global Instance ℐ : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module  Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
Section Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Definition Self : Set := core.option.Option T.
  
  Definition from (source : subtle.CtOption T) : M (core.option.Option T) :=
    let* α0 := borrow source (subtle.CtOption T) in
    let* α1 := (subtle.CtOption T)::["is_some"] α0 in
    let* α2 := borrow α1 subtle.Choice in
    let* α3 := subtle.Choice::["unwrap_u8"] α2 in
    let* α4 := M.alloc 1 in
    let* α5 := BinOp.eq α3 α4 in
    let* α6 := use α5 in
    if (α6 : bool) then
      let* α0 := source.["value"] in
      M.alloc (core.option.Option.Some α0)
    else
      M.alloc core.option.Option.None.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance ℐ : core.convert.From.Trait Self (T := subtle.CtOption T) := {
    core.convert.From.from := from;
  }.
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.
End Impl_core_convert_From_subtle_CtOption_T_for_core_option_Option_T.

Module  Impl_subtle_CtOption_T.
Section Impl_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Definition Self : Set := subtle.CtOption T.
  
  Definition new
      (value : T)
      (is_some : subtle.Choice)
      : M (subtle.CtOption T) :=
    M.alloc
      {| subtle.CtOption.value := value; subtle.CtOption.is_some := is_some; |}.
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect (self : Self) (msg : ref str) : M T :=
    let* _ :=
      let* α0 := self.["is_some"] in
      let* α1 := borrow α0 subtle.Choice in
      let* α2 := subtle.Choice::["unwrap_u8"] α1 in
      let* α3 := borrow α2 u8 in
      let* α4 := M.alloc 1 in
      let* α5 := borrow α4 u8 in
      match (α3, α5) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := BinOp.eq α0 α1 in
        let* α3 := UnOp.not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* kind := M.alloc core.panicking.AssertKind.Eq in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            let* α8 := borrow [ mk_str "" ] (list (ref str)) in
            let* α9 := deref α8 (list (ref str)) in
            let* α10 := borrow α9 (list (ref str)) in
            let* α11 := pointer_coercion "Unsize" α10 in
            let* α12 := borrow msg (ref str) in
            let* α13 := deref α12 (ref str) in
            let* α14 := borrow α13 (ref str) in
            let* α15 := core.fmt.rt.Argument::["new_display"] α14 in
            let* α16 := borrow [ α15 ] (list core.fmt.rt.Argument) in
            let* α17 := deref α16 (list core.fmt.rt.Argument) in
            let* α18 := borrow α17 (list core.fmt.rt.Argument) in
            let* α19 := pointer_coercion "Unsize" α18 in
            let* α20 := core.fmt.Arguments::["new_v1"] α11 α19 in
            let* α21 := M.alloc (core.option.Option.Some α20) in
            core.panicking.assert_failed kind α3 α7 α21 in
          let* α0 := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    self.["value"].
  
  Global Instance AssociatedFunction_expect :
    Notation.DoubleColon Self "expect" := {
    Notation.double_colon := expect;
  }.
  
  Definition unwrap (self : Self) : M T :=
    let* _ :=
      let* α0 := self.["is_some"] in
      let* α1 := borrow α0 subtle.Choice in
      let* α2 := subtle.Choice::["unwrap_u8"] α1 in
      let* α3 := borrow α2 u8 in
      let* α4 := M.alloc 1 in
      let* α5 := borrow α4 u8 in
      match (α3, α5) with
      | (left_val, right_val) =>
        let* α0 := deref left_val u8 in
        let* α1 := deref right_val u8 in
        let* α2 := BinOp.eq α0 α1 in
        let* α3 := UnOp.not α2 in
        let* α4 := use α3 in
        if (α4 : bool) then
          let* kind := M.alloc core.panicking.AssertKind.Eq in
          let* _ :=
            let* α0 := deref left_val u8 in
            let* α1 := borrow α0 u8 in
            let* α2 := deref α1 u8 in
            let* α3 := borrow α2 u8 in
            let* α4 := deref right_val u8 in
            let* α5 := borrow α4 u8 in
            let* α6 := deref α5 u8 in
            let* α7 := borrow α6 u8 in
            let* α8 := M.alloc core.option.Option.None in
            core.panicking.assert_failed kind α3 α7 α8 in
          let* α0 := M.alloc tt in
          never_to_any α0
        else
          M.alloc tt
      end in
    self.["value"].
  
  Global Instance AssociatedFunction_unwrap :
    Notation.DoubleColon Self "unwrap" := {
    Notation.double_colon := unwrap;
  }.
  
  Definition unwrap_or
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      (self : Self)
      (def : T)
      : M T :=
    let* α0 := borrow def T in
    let* α1 := deref α0 T in
    let* α2 := borrow α1 T in
    let* α3 := self.["value"] in
    let* α4 := borrow α3 T in
    let* α5 := deref α4 T in
    let* α6 := borrow α5 T in
    let* α7 := self.["is_some"] in
    (subtle.ConditionallySelectable.conditional_select
        (Self := T)
        (Trait := ltac:(refine _)))
      α2
      α6
      α7.
  
  Global Instance AssociatedFunction_unwrap_or
      {ℋ_0 : subtle.ConditionallySelectable.Trait T} :
    Notation.DoubleColon Self "unwrap_or" := {
    Notation.double_colon := unwrap_or;
  }.
  
  Definition unwrap_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M T :=
    let* α0 := M.alloc tt in
    let* α1 :=
      (core.ops.function.FnOnce.call_once
          (Self := F)
          (Trait := ltac:(refine _)))
        f
        α0 in
    let* α2 := borrow α1 T in
    let* α3 := deref α2 T in
    let* α4 := borrow α3 T in
    let* α5 := self.["value"] in
    let* α6 := borrow α5 T in
    let* α7 := deref α6 T in
    let* α8 := borrow α7 T in
    let* α9 := self.["is_some"] in
    (subtle.ConditionallySelectable.conditional_select
        (Self := T)
        (Trait := ltac:(refine _)))
      α4
      α8
      α9.
  
  Global Instance AssociatedFunction_unwrap_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.DoubleColon Self "unwrap_or_else" := {
    Notation.double_colon := unwrap_or_else (F := F);
  }.
  
  Definition is_some (self : ref Self) : M subtle.Choice :=
    let* α0 := deref self (subtle.CtOption T) in
    α0.["is_some"].
  
  Global Instance AssociatedFunction_is_some :
    Notation.DoubleColon Self "is_some" := {
    Notation.double_colon := is_some;
  }.
  
  Definition is_none (self : ref Self) : M subtle.Choice :=
    let* α0 := deref self (subtle.CtOption T) in
    let* α1 := α0.["is_some"] in
    (core.ops.bit.Not.not (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α1.
  
  Global Instance AssociatedFunction_is_none :
    Notation.DoubleColon Self "is_none" := {
    Notation.double_colon := is_none;
  }.
  
  Definition map
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption U) :=
    let* α0 :=
      core.default.Default.default (Self := T) (Trait := ltac:(refine _)) in
    let* α1 := borrow α0 T in
    let* α2 := deref α1 T in
    let* α3 := borrow α2 T in
    let* α4 := self.["value"] in
    let* α5 := borrow α4 T in
    let* α6 := deref α5 T in
    let* α7 := borrow α6 T in
    let* α8 := self.["is_some"] in
    let* α9 :=
      (subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ltac:(refine _)))
        α3
        α7
        α8 in
    let* α10 :=
      (core.ops.function.FnOnce.call_once
          (Self := F)
          (Trait := ltac:(refine _)))
        f
        (α9) in
    let* α11 := self.["is_some"] in
    (subtle.CtOption U)::["new"] α10 α11.
  
  Global Instance AssociatedFunction_map
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.DoubleColon Self "map" := {
    Notation.double_colon := map (U := U) (F := F);
  }.
  
  Definition and_then
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption U) :=
    let* tmp :=
      let* α0 :=
        core.default.Default.default (Self := T) (Trait := ltac:(refine _)) in
      let* α1 := borrow α0 T in
      let* α2 := deref α1 T in
      let* α3 := borrow α2 T in
      let* α4 := self.["value"] in
      let* α5 := borrow α4 T in
      let* α6 := deref α5 T in
      let* α7 := borrow α6 T in
      let* α8 := self.["is_some"] in
      let* α9 :=
        (subtle.ConditionallySelectable.conditional_select
            (Self := T)
            (Trait := ltac:(refine _)))
          α3
          α7
          α8 in
      (core.ops.function.FnOnce.call_once
          (Self := F)
          (Trait := ltac:(refine _)))
        f
        (α9) in
    let* _ :=
      let* α0 := tmp.["is_some"] in
      let* α1 := borrow_mut α0 subtle.Choice in
      let* α2 := self.["is_some"] in
      (core.ops.bit.BitAndAssign.bitand_assign
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α1
        α2 in
    Pure tmp.
  
  Global Instance AssociatedFunction_and_then
      {U F : Set}
      {ℋ_0 : core.default.Default.Trait T}
      {ℋ_1 : subtle.ConditionallySelectable.Trait T}
      {ℋ_2 : core.ops.function.FnOnce.Trait F (Args := T)} :
    Notation.DoubleColon Self "and_then" := {
    Notation.double_colon := and_then (U := U) (F := F);
  }.
  
  Definition or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (subtle.CtOption T) :=
    let* is_none :=
      let* α0 := borrow self (subtle.CtOption T) in
      (subtle.CtOption T)::["is_none"] α0 in
    let* f :=
      let* α0 := M.alloc tt in
      (core.ops.function.FnOnce.call_once
          (Self := F)
          (Trait := ltac:(refine _)))
        f
        α0 in
    let* α0 := borrow self (subtle.CtOption T) in
    let* α1 := deref α0 (subtle.CtOption T) in
    let* α2 := borrow α1 (subtle.CtOption T) in
    let* α3 := borrow f (subtle.CtOption T) in
    let* α4 := deref α3 (subtle.CtOption T) in
    let* α5 := borrow α4 (subtle.CtOption T) in
    (subtle.ConditionallySelectable.conditional_select
        (Self := subtle.CtOption T)
        (Trait := ltac:(refine _)))
      α2
      α5
      is_none.
  
  Global Instance AssociatedFunction_or_else
      {F : Set}
      {ℋ_0 : subtle.ConditionallySelectable.Trait T}
      {ℋ_1 : core.ops.function.FnOnce.Trait F (Args := unit)} :
    Notation.DoubleColon Self "or_else" := {
    Notation.double_colon := or_else (F := F);
  }.
End Impl_subtle_CtOption_T.
End Impl_subtle_CtOption_T.

Module  Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConditionallySelectable.Trait T}.
  Definition Self : Set := subtle.CtOption T.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M Self :=
    let* α0 := deref a (subtle.CtOption T) in
    let* α1 := α0.["value"] in
    let* α2 := borrow α1 T in
    let* α3 := deref α2 T in
    let* α4 := borrow α3 T in
    let* α5 := deref b (subtle.CtOption T) in
    let* α6 := α5.["value"] in
    let* α7 := borrow α6 T in
    let* α8 := deref α7 T in
    let* α9 := borrow α8 T in
    let* α10 :=
      (subtle.ConditionallySelectable.conditional_select
          (Self := T)
          (Trait := ltac:(refine _)))
        α4
        α9
        choice in
    let* α11 := deref a (subtle.CtOption T) in
    let* α12 := α11.["is_some"] in
    let* α13 := borrow α12 subtle.Choice in
    let* α14 := deref α13 subtle.Choice in
    let* α15 := borrow α14 subtle.Choice in
    let* α16 := deref b (subtle.CtOption T) in
    let* α17 := α16.["is_some"] in
    let* α18 := borrow α17 subtle.Choice in
    let* α19 := deref α18 subtle.Choice in
    let* α20 := borrow α19 subtle.Choice in
    let* α21 :=
      (subtle.ConditionallySelectable.conditional_select
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α15
        α20
        choice in
    (subtle.CtOption T)::["new"] α10 α21.
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance ℐ : subtle.ConditionallySelectable.Required.Trait Self := {
    subtle.ConditionallySelectable.conditional_select := conditional_select;
    subtle.ConditionallySelectable.conditional_assign := Datatypes.None;
    subtle.ConditionallySelectable.conditional_swap := Datatypes.None;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module  Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Context `{ℋ : State.Trait}.
  
  Context {T : Set}.
  
  Context {ℋ_0 : subtle.ConstantTimeEq.Trait T}.
  Definition Self : Set := subtle.CtOption T.
  
  Definition ct_eq
      (self : ref Self)
      (rhs : ref (subtle.CtOption T))
      : M subtle.Choice :=
    let* a :=
      let* α0 := deref self (subtle.CtOption T) in
      let* α1 := borrow α0 (subtle.CtOption T) in
      (subtle.CtOption T)::["is_some"] α1 in
    let* b :=
      let* α0 := deref rhs (subtle.CtOption T) in
      let* α1 := borrow α0 (subtle.CtOption T) in
      (subtle.CtOption T)::["is_some"] α1 in
    let* α0 :=
      (core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        a
        b in
    let* α1 := deref self (subtle.CtOption T) in
    let* α2 := α1.["value"] in
    let* α3 := borrow α2 T in
    let* α4 := deref rhs (subtle.CtOption T) in
    let* α5 := α4.["value"] in
    let* α6 := borrow α5 T in
    let* α7 := deref α6 T in
    let* α8 := borrow α7 T in
    let* α9 :=
      (subtle.ConstantTimeEq.ct_eq (Self := T) (Trait := ltac:(refine _)))
        α3
        α8 in
    let* α10 :=
      (core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α0
        α9 in
    let* α11 :=
      (core.ops.bit.Not.not (Self := subtle.Choice) (Trait := ltac:(refine _)))
        a in
    let* α12 :=
      (core.ops.bit.Not.not (Self := subtle.Choice) (Trait := ltac:(refine _)))
        b in
    let* α13 :=
      (core.ops.bit.BitAnd.bitand
          (Self := subtle.Choice)
          (Trait := ltac:(refine _)))
        α11
        α12 in
    (core.ops.bit.BitOr.bitor
        (Self := subtle.Choice)
        (Trait := ltac:(refine _)))
      α10
      α13.
  
  Global Instance AssociatedFunction_ct_eq :
    Notation.DoubleColon Self "ct_eq" := {
    Notation.double_colon := ct_eq;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeEq.Required.Trait Self := {
    subtle.ConstantTimeEq.ct_eq := ct_eq;
    subtle.ConstantTimeEq.ct_ne := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module  ConstantTimeGreater.
Section ConstantTimeGreater.
  Context `{ℋ : State.Trait}.
  
  Class Trait (Self : Set) : Type := {
    ct_gt : (ref Self) -> (ref Self) -> M subtle.Choice;
  }.
  
End ConstantTimeGreater.
End ConstantTimeGreater.

Module  Impl_subtle_ConstantTimeGreater_for_u8.
Section Impl_subtle_ConstantTimeGreater_for_u8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u8.
  
  Definition ct_gt (self : ref Self) (other : ref u8) : M subtle.Choice :=
    let* gtb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u8) (Trait := ltac:(refine _)))
          other in
      (core.ops.bit.BitAnd.bitand (Self := ref u8) (Trait := ltac:(refine _)))
        self
        α0 in
    let* ltb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u8) (Trait := ltac:(refine _)))
          self in
      (core.ops.bit.BitAnd.bitand (Self := u8) (Trait := ltac:(refine _)))
        α0
        other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 8 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* bit :=
      let* α0 := UnOp.not ltb in
      BinOp.bit_and gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 8 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* α0 := M.alloc 1 in
    let* α1 := BinOp.bit_and bit α0 in
    let* α2 := use α1 in
    (core.convert.From.from (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α2.
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon Self "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u8.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module  Impl_subtle_ConstantTimeGreater_for_u16.
Section Impl_subtle_ConstantTimeGreater_for_u16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u16.
  
  Definition ct_gt (self : ref Self) (other : ref u16) : M subtle.Choice :=
    let* gtb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u16) (Trait := ltac:(refine _)))
          other in
      (core.ops.bit.BitAnd.bitand (Self := ref u16) (Trait := ltac:(refine _)))
        self
        α0 in
    let* ltb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u16) (Trait := ltac:(refine _)))
          self in
      (core.ops.bit.BitAnd.bitand (Self := u16) (Trait := ltac:(refine _)))
        α0
        other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 16 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* bit :=
      let* α0 := UnOp.not ltb in
      BinOp.bit_and gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 16 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* α0 := M.alloc 1 in
    let* α1 := BinOp.bit_and bit α0 in
    let* α2 := cast α1 in
    (core.convert.From.from (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α2.
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon Self "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u16.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module  Impl_subtle_ConstantTimeGreater_for_u32.
Section Impl_subtle_ConstantTimeGreater_for_u32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u32.
  
  Definition ct_gt (self : ref Self) (other : ref u32) : M subtle.Choice :=
    let* gtb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u32) (Trait := ltac:(refine _)))
          other in
      (core.ops.bit.BitAnd.bitand (Self := ref u32) (Trait := ltac:(refine _)))
        self
        α0 in
    let* ltb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u32) (Trait := ltac:(refine _)))
          self in
      (core.ops.bit.BitAnd.bitand (Self := u32) (Trait := ltac:(refine _)))
        α0
        other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 32 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* bit :=
      let* α0 := UnOp.not ltb in
      BinOp.bit_and gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 32 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* α0 := M.alloc 1 in
    let* α1 := BinOp.bit_and bit α0 in
    let* α2 := cast α1 in
    (core.convert.From.from (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α2.
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon Self "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u32.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module  Impl_subtle_ConstantTimeGreater_for_u64.
Section Impl_subtle_ConstantTimeGreater_for_u64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u64.
  
  Definition ct_gt (self : ref Self) (other : ref u64) : M subtle.Choice :=
    let* gtb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u64) (Trait := ltac:(refine _)))
          other in
      (core.ops.bit.BitAnd.bitand (Self := ref u64) (Trait := ltac:(refine _)))
        self
        α0 in
    let* ltb :=
      let* α0 :=
        (core.ops.bit.Not.not (Self := ref u64) (Trait := ltac:(refine _)))
          self in
      (core.ops.bit.BitAnd.bitand (Self := u64) (Trait := ltac:(refine _)))
        α0
        other in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 64 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr ltb pow in
            assign_op bitor ltb α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* bit :=
      let* α0 := UnOp.not ltb in
      BinOp.bit_and gtb α0 in
    let* pow := M.alloc 1 in
    let* _ :=
      loop
        (let* α0 := M.alloc 64 in
        let* α1 := BinOp.lt pow α0 in
        let* α2 := use α1 in
        if (α2 : bool) then
          let* _ :=
            let* α0 := BinOp.shr bit pow in
            assign_op bitor bit α0 in
          let* _ := assign_op add pow pow in
          M.alloc tt
        else
          let* _ :=
            let* α0 := Break in
            never_to_any α0 in
          let* α0 := M.alloc tt in
          never_to_any α0) in
    let* α0 := M.alloc 1 in
    let* α1 := BinOp.bit_and bit α0 in
    let* α2 := cast α1 in
    (core.convert.From.from (Self := subtle.Choice) (Trait := ltac:(refine _)))
      α2.
  
  Global Instance AssociatedFunction_ct_gt :
    Notation.DoubleColon Self "ct_gt" := {
    Notation.double_colon := ct_gt;
  }.
  
  Global Instance ℐ : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u64.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module  ConstantTimeLess.
Section ConstantTimeLess.
  Context `{ℋ : State.Trait}.
  
  Class Trait (Self : Set) : Type := {
    ℒ_0 :: subtle.ConstantTimeEq.Trait Self;
    ℒ_1 :: subtle.ConstantTimeGreater.Trait Self;
  }.
  
End ConstantTimeLess.
End ConstantTimeLess.

Module  Impl_subtle_ConstantTimeLess_for_u8.
Section Impl_subtle_ConstantTimeLess_for_u8.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u8.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u8.
End Impl_subtle_ConstantTimeLess_for_u8.

Module  Impl_subtle_ConstantTimeLess_for_u16.
Section Impl_subtle_ConstantTimeLess_for_u16.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u16.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u16.
End Impl_subtle_ConstantTimeLess_for_u16.

Module  Impl_subtle_ConstantTimeLess_for_u32.
Section Impl_subtle_ConstantTimeLess_for_u32.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u32.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u32.
End Impl_subtle_ConstantTimeLess_for_u32.

Module  Impl_subtle_ConstantTimeLess_for_u64.
Section Impl_subtle_ConstantTimeLess_for_u64.
  Context `{ℋ : State.Trait}.
  
  Definition Self : Set := u64.
  
  Global Instance ℐ : subtle.ConstantTimeLess.Required.Trait Self := {
    subtle.ConstantTimeLess.ct_lt := Datatypes.None;
  }.
End Impl_subtle_ConstantTimeLess_for_u64.
End Impl_subtle_ConstantTimeLess_for_u64.
