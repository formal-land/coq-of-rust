(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.core.prelude.rust_2015.

Module Option := core.option.Option.
Definition Option := Option.t.

Module Choice.
  Record t : Set := { _ : u8;}.
  
  Global Instance Get_0 : Notation.Dot 0 := {
    Notation.dot '(Build_t x0) := x0;
  }.
End Choice.
Definition Choice := Choice.t.

Module Impl__crate_marker_Copy_for_Choice.
  Definition Self := Choice.
  
  Global Instance I : _crate.marker.Copy.Trait Self :=
    _crate.marker.Copy.Build_Class _.
End Impl__crate_marker_Copy_for_Choice.

Module Impl__crate_clone_Clone_for_Choice.
  Definition Self := Choice.
  
  Definition clone (self : ref Self) :=
    ltac:(function (
      let '_ := tt in
      self.["deref"](||)
      : Choice)).
  
  Global Instance Method_clone : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : _crate.clone.Clone.Trait Self := {
    _crate.clone.Clone.clone := clone;
  }.
End Impl__crate_clone_Clone_for_Choice.

Module Impl__crate_fmt_Debug_for_Choice.
  Definition Self := Choice.
  
  Definition fmt (self : ref Self) (f : mut_ref _crate.fmt.Formatter) :=
    ltac:(function (
      _crate.fmt.Formatter::["debug_tuple_field1_finish"](|
        f,
        "Choice",
        self.[0]
      |)
      : _crate.fmt.Result)).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_Choice.

Module ImplChoice.
  Definition Self := Choice.
  
  Definition unwrap_u8 (self : ref Self) := ltac:(function (self.[0] : u8)).
  
  Global Instance Method_unwrap_u8 : Notation.Dot "unwrap_u8" := {
    Notation.dot := unwrap_u8;
  }.
End ImplChoice.

Module Impl_From_for_bool.
  Definition Self := bool.
  
  Definition from (source : Choice) :=
    ltac:(function (
      let '_ :=
        if (true : bool) then
          let '_ :=
            if
              ((((source.[0]).["eq"](| 0 |)).["bitor"](|
                (source.[0]).["eq"](| 1 |)
              |)).["not"](||)
              : bool)
            then
              _crate.panicking.panic(|
                "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)"
              |)
            else
              tt in
          tt
        else
          tt in
      (source.[0]).["ne"](| 0 |)
      : bool)).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : From.Trait Self Choice := {
    From.from := from;
  }.
End Impl_From_for_bool.

Module Impl_BitAnd_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitand (self : Self) (rhs : Choice) :=
    ltac:(function (
      ((self.[0]).["bitand"](| rhs.[0] |)).["into"](||)
      : Choice)).
  
  Global Instance Method_bitand : Notation.Dot "bitand" := {
    Notation.dot := bitand;
  }.
  
  Global Instance I : BitAnd.Trait Self := {
    BitAnd.bitand := bitand;
  }.
End Impl_BitAnd_for_Choice.

Module Impl_BitAndAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitand_assign (self : mut_ref Self) (rhs : Choice) :=
    ltac:(function (
      let '_ :=
        assign
          (self.["deref"](||))
          ((self.["deref"](||)).["bitand"](| rhs |)) in
      tt
      : _)).
  
  Global Instance Method_bitand_assign : Notation.Dot "bitand_assign" := {
    Notation.dot := bitand_assign;
  }.
  
  Global Instance I : BitAndAssign.Trait Self := {
    BitAndAssign.bitand_assign := bitand_assign;
  }.
End Impl_BitAndAssign_for_Choice.

Module Impl_BitOr_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitor (self : Self) (rhs : Choice) :=
    ltac:(function (((self.[0]).["bitor"](| rhs.[0] |)).["into"](||) : Choice)).
  
  Global Instance Method_bitor : Notation.Dot "bitor" := {
    Notation.dot := bitor;
  }.
  
  Global Instance I : BitOr.Trait Self := {
    BitOr.bitor := bitor;
  }.
End Impl_BitOr_for_Choice.

Module Impl_BitOrAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitor_assign (self : mut_ref Self) (rhs : Choice) :=
    ltac:(function (
      let '_ :=
        assign (self.["deref"](||)) ((self.["deref"](||)).["bitor"](| rhs |)) in
      tt
      : _)).
  
  Global Instance Method_bitor_assign : Notation.Dot "bitor_assign" := {
    Notation.dot := bitor_assign;
  }.
  
  Global Instance I : BitOrAssign.Trait Self := {
    BitOrAssign.bitor_assign := bitor_assign;
  }.
End Impl_BitOrAssign_for_Choice.

Module Impl_BitXor_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition bitxor (self : Self) (rhs : Choice) :=
    ltac:(function (
      ((self.[0]).["bitxor"](| rhs.[0] |)).["into"](||)
      : Choice)).
  
  Global Instance Method_bitxor : Notation.Dot "bitxor" := {
    Notation.dot := bitxor;
  }.
  
  Global Instance I : BitXor.Trait Self := {
    BitXor.bitxor := bitxor;
  }.
End Impl_BitXor_for_Choice.

Module Impl_BitXorAssign_for_Choice.
  Definition Self := Choice.
  
  Definition bitxor_assign (self : mut_ref Self) (rhs : Choice) :=
    ltac:(function (
      let '_ :=
        assign
          (self.["deref"](||))
          ((self.["deref"](||)).["bitxor"](| rhs |)) in
      tt
      : _)).
  
  Global Instance Method_bitxor_assign : Notation.Dot "bitxor_assign" := {
    Notation.dot := bitxor_assign;
  }.
  
  Global Instance I : BitXorAssign.Trait Self := {
    BitXorAssign.bitxor_assign := bitxor_assign;
  }.
End Impl_BitXorAssign_for_Choice.

Module Impl_Not_for_Choice.
  Definition Self := Choice.
  
  Definition Output : Set := Choice.
  
  Definition not (self : Self) :=
    ltac:(function (
      (1.["bitand"](| (self.[0]).["not"](||) |)).["into"](||)
      : Choice)).
  
  Global Instance Method_not : Notation.Dot "not" := {
    Notation.dot := not;
  }.
  
  Global Instance I : Not.Trait Self := {
    Not.not := not;
  }.
End Impl_Not_for_Choice.

Definition black_box (input : u8) :=
  ltac:(function (
    let '_ :=
      if (true : bool) then
        let '_ :=
          if
            (((input.["eq"](| 0 |)).["bitor"](| input.["eq"](| 1 |)
            |)).["not"](||)
            : bool)
          then
            _crate.panicking.panic(|
              "assertion failed: (input == 0u8) | (input == 1u8)"
            |)
          else
            tt in
        tt
      else
        tt in
    core.ptr.read_volatile(| cast input (ref u8) |)
    : u8)).

Module Impl_From_for_Choice.
  Definition Self := Choice.
  
  Definition from (input : u8) :=
    ltac:(function (Choice.Build_t (black_box(| input |)) : Choice)).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : From.Trait Self u8 := {
    From.from := from;
  }.
End Impl_From_for_Choice.

Module ConstantTimeEq.
  Class Trait (Self : Set) : Set := {
    ct_eq : (ref Self) -> ((ref Self) -> (M Choice));
  }.
  
  Global Instance Method_ct_eq `(Trait) : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  Global Instance Method_ct_ne `(Trait) : Notation.Dot "ct_ne" := {
    Notation.dot (self : ref Self) (other : ref Self) :=
      ((self.["ct_eq"](| other |)).["not"](||)
      : Choice);
  }.
End ConstantTimeEq.

Module Impl_ConstantTimeEq_for_Slice.
  Definition Self := Slice.
  
  Definition ct_eq (self : ref Self) (_rhs : ref Slice) :=
    ltac:(function (
      let len := self.["len"](||) in
      let '_ :=
        if (len.["ne"](| _rhs.["len"](||) |) : bool) then
          let '_ := Return(| Choice::["from"](| 0 |) |) in
          tt
        else
          tt in
      let x := 1 in
      let '_ :=
        match LangItem(| (self.["iter"](||)).["zip"](| _rhs.["iter"](||) |) |)
        with
        | iter =>
          loop
            let '_ :=
              match LangItem(| iter |) with
              | None => Break
              | Some {| Some.0 := (ai, bi); |} =>
                let '_ :=
                  x.["bitand_assign"](| (ai.["ct_eq"](| bi |)).["unwrap_u8"](||)
                  |) in
                tt
              end in
            tt
            from
            for
        end in
      x.["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I T : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_Slice.

Module Impl_ConstantTimeEq_for_Choice.
  Definition Self := Choice.
  
  Definition ct_eq (self : ref Self) (rhs : ref Choice) :=
    ltac:(function (
      ((self.["deref"](||)).["bitxor"](| rhs.["deref"](||) |)).["not"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_Choice.

Module Impl_ConstantTimeEq_for_u8.
  Definition Self := u8.
  
  Definition ct_eq (self : ref Self) (other : ref u8) :=
    ltac:(function (
      let x := self.["bitxor"](| other |) in
      let y :=
        (x.["bitor"](| x.["wrapping_neg"](||) |)).["shr"](| 8.["sub"](| 1 |)
        |) in
      (cast (y.["bitxor"](| cast 1 u8 |)) u8).["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_u8.

Module Impl_ConstantTimeEq_for_i8.
  Definition Self := i8.
  
  Definition ct_eq (self : ref Self) (other : ref i8) :=
    ltac:(function (
      (cast (self.["deref"](||)) u8).["ct_eq"](| cast (other.["deref"](||)) u8
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_i8.

Module Impl_ConstantTimeEq_for_u16.
  Definition Self := u16.
  
  Definition ct_eq (self : ref Self) (other : ref u16) :=
    ltac:(function (
      let x := self.["bitxor"](| other |) in
      let y :=
        (x.["bitor"](| x.["wrapping_neg"](||) |)).["shr"](| 16.["sub"](| 1 |)
        |) in
      (cast (y.["bitxor"](| cast 1 u16 |)) u8).["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_u16.

Module Impl_ConstantTimeEq_for_i16.
  Definition Self := i16.
  
  Definition ct_eq (self : ref Self) (other : ref i16) :=
    ltac:(function (
      (cast (self.["deref"](||)) u16).["ct_eq"](| cast (other.["deref"](||)) u16
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_i16.

Module Impl_ConstantTimeEq_for_u32.
  Definition Self := u32.
  
  Definition ct_eq (self : ref Self) (other : ref u32) :=
    ltac:(function (
      let x := self.["bitxor"](| other |) in
      let y :=
        (x.["bitor"](| x.["wrapping_neg"](||) |)).["shr"](| 32.["sub"](| 1 |)
        |) in
      (cast (y.["bitxor"](| cast 1 u32 |)) u8).["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_u32.

Module Impl_ConstantTimeEq_for_i32.
  Definition Self := i32.
  
  Definition ct_eq (self : ref Self) (other : ref i32) :=
    ltac:(function (
      (cast (self.["deref"](||)) u32).["ct_eq"](| cast (other.["deref"](||)) u32
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_i32.

Module Impl_ConstantTimeEq_for_u64.
  Definition Self := u64.
  
  Definition ct_eq (self : ref Self) (other : ref u64) :=
    ltac:(function (
      let x := self.["bitxor"](| other |) in
      let y :=
        (x.["bitor"](| x.["wrapping_neg"](||) |)).["shr"](| 64.["sub"](| 1 |)
        |) in
      (cast (y.["bitxor"](| cast 1 u64 |)) u8).["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_u64.

Module Impl_ConstantTimeEq_for_i64.
  Definition Self := i64.
  
  Definition ct_eq (self : ref Self) (other : ref i64) :=
    ltac:(function (
      (cast (self.["deref"](||)) u64).["ct_eq"](| cast (other.["deref"](||)) u64
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_i64.

Module Impl_ConstantTimeEq_for_usize.
  Definition Self := usize.
  
  Definition ct_eq (self : ref Self) (other : ref usize) :=
    ltac:(function (
      let x := self.["bitxor"](| other |) in
      let y :=
        (x.["bitor"](| x.["wrapping_neg"](||) |)).["shr"](|
          ((Root.core.mem.size_of(||)).["mul"](| 8 |)).["sub"](| 1 |)
        |) in
      (cast (y.["bitxor"](| cast 1 usize |)) u8).["into"](||)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_usize.

Module Impl_ConstantTimeEq_for_isize.
  Definition Self := isize.
  
  Definition ct_eq (self : ref Self) (other : ref isize) :=
    ltac:(function (
      (cast (self.["deref"](||)) usize).["ct_eq"](|
        cast (other.["deref"](||)) usize
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Class Trait (Self : Set) : Set := {
    conditional_select : (ref Self) -> ((ref Self) -> (Choice -> (M Self)));
  }.
  
  Global Instance Method_conditional_select `(Trait)
    : Notation.Dot "conditional_select" := {
    Notation.dot := conditional_select;
  }.
  Global Instance Method_conditional_assign `(Trait)
    : Notation.Dot "conditional_assign" := {
    Notation.dot (self : mut_ref Self) (other : ref Self) (choice : Choice) :=
      (let '_ :=
        assign
          (self.["deref"](||))
          (Self::["conditional_select"](| self, other, choice |)) in
      tt
      : unit);
  }.
  Global Instance Method_conditional_swap `(Trait)
    : Notation.Dot "conditional_swap" := {
    Notation.dot (a : mut_ref Self) (b : mut_ref Self) (choice : Choice) :=
      (let t := a.["deref"](||) in
      let '_ := a.["conditional_assign"](| b, choice |) in
      let '_ := b.["conditional_assign"](| t, choice |) in
      tt
      : unit);
  }.
End ConditionallySelectable.

Module Impl_ConditionallySelectable_for_u8.
  Definition Self := u8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) u8 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) u8 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) u8 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_u8.

Module Impl_ConditionallySelectable_for_i8.
  Definition Self := i8.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) i8 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) i8 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask := cast ((cast (choice.["unwrap_u8"](||)) i8).["neg"](||)) i8 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_i8.

Module Impl_ConditionallySelectable_for_u16.
  Definition Self := u16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) u16 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) u16 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) u16 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_u16.

Module Impl_ConditionallySelectable_for_i16.
  Definition Self := i16.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) i16 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) i16 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i16).["neg"](||)) i16 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_i16.

Module Impl_ConditionallySelectable_for_u32.
  Definition Self := u32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) u32 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) u32 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) u32 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_u32.

Module Impl_ConditionallySelectable_for_i32.
  Definition Self := i32.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) i32 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) i32 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i32).["neg"](||)) i32 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_i32.

Module Impl_ConditionallySelectable_for_u64.
  Definition Self := u64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) u64 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) u64 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) u64 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_u64.

Module Impl_ConditionallySelectable_for_i64.
  Definition Self := i64.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) i64 in
      a.["bitxor"](| mask.["bitand"](| a.["bitxor"](| b |) |) |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      (self : mut_ref Self)
      (other : ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) i64 in
      let '_ :=
        (self.["deref"](||)).["bitxor_assign"](|
          mask.["bitand"](|
            (self.["deref"](||)).["bitxor"](| other.["deref"](||) |)
          |)
        |) in
      tt
      : _)).
  
  Global Instance Method_conditional_assign :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : Choice) :=
    ltac:(function (
      let mask :=
        cast ((cast (choice.["unwrap_u8"](||)) i64).["neg"](||)) i64 in
      let t :=
        mask.["bitand"](| (a.["deref"](||)).["bitxor"](| b.["deref"](||) |)
        |) in
      let '_ := (a.["deref"](||)).["bitxor_assign"](| t |) in
      let '_ := (b.["deref"](||)).["bitxor_assign"](| t |) in
      tt
      : _)).
  
  Global Instance AssociatedFunction_conditional_swap :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_i64.

Module Impl_ConditionallySelectable_for_Choice.
  Definition Self := Choice.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      Choice.Build_t (u8::["conditional_select"](| a.[0], b.[0], choice |))
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_Choice.

Module ConditionallyNegatable.
  Class Trait (Self : Set) : Set := {
    conditional_negate : (mut_ref Self) -> (Choice -> (M _));
  }.
  
  Global Instance Method_conditional_negate `(Trait)
    : Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
End ConditionallyNegatable.

Module Impl_ConditionallyNegatable_for_T.
  Definition Self := T.
  
  Definition conditional_negate (self : mut_ref Self) (choice : Choice) :=
    ltac:(function (
      let self_neg := (cast self (ref T)).["neg"](||) in
      let '_ := self.["conditional_assign"](| self_neg, choice |) in
      tt
      : _)).
  
  Global Instance Method_conditional_negate :
    Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
  
  Global Instance I T : ConditionallyNegatable.Trait Self := {
    ConditionallyNegatable.conditional_negate := conditional_negate;
  }.
End Impl_ConditionallyNegatable_for_T.

Module CtOption.
  Record t : Set := {
    value : T;
    is_some : Choice;
  }.
  
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot '(Build_t x0 _) := x0;
  }.
  Global Instance Get_is_some : Notation.Dot "is_some" := {
    Notation.dot '(Build_t _ x1) := x1;
  }.
End CtOption.
Definition CtOption : Set := CtOption.t.

Module Impl__crate_clone_Clone_for_CtOption_T.
  Definition Self := CtOption T.
  
  Definition clone (self : ref Self) :=
    ltac:(function (
      {|
        CtOption.value := _crate.clone.Clone.clone(| self.["value"] |);
        CtOption.is_some := _crate.clone.Clone.clone(| self.["is_some"] |);
      |}
      : CtOption T)).
  
  Global Instance Method_clone : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I T : _crate.clone.Clone.Trait Self := {
    _crate.clone.Clone.clone := clone;
  }.
End Impl__crate_clone_Clone_for_CtOption_T.

Module Impl__crate_marker_Copy_for_CtOption_T.
  Definition Self := CtOption T.
  
  Global Instance I T : _crate.marker.Copy.Trait Self :=
    _crate.marker.Copy.Build_Class _.
End Impl__crate_marker_Copy_for_CtOption_T.

Module Impl__crate_fmt_Debug_for_CtOption_T.
  Definition Self := CtOption T.
  
  Definition fmt (self : ref Self) (f : mut_ref _crate.fmt.Formatter) :=
    ltac:(function (
      _crate.fmt.Formatter::["debug_struct_field2_finish"](|
        f,
        "CtOption",
        "value",
        self.["value"],
        "is_some",
        self.["is_some"]
      |)
      : _crate.fmt.Result)).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I T : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_CtOption_T.

Module Impl_From_for_Option_T.
  Definition Self := Option T.
  
  Definition from (source : CtOption T) :=
    ltac:(function (
      if (((source.["is_some"](||)).["unwrap_u8"](||)).["eq"](| 1 |) : bool)
      then
        Option.Some source.["value"]
      else
        None
      : Option T)).
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I T : From.Trait Self CtOption T := {
    From.from := from;
  }.
End Impl_From_for_Option_T.

Module ImplCtOption T.
  Definition Self := CtOption T.
  
  Definition new (value : T) (is_some : Choice) :=
    ltac:(function (
      {| CtOption.value := value; CtOption.is_some := is_some; |}
      : CtOption T)).
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect (self : Self) (msg : ref str) :=
    ltac:(function (
      let '_ :=
        match (self.["is_some"].["unwrap_u8"](||), 1) with
        | (left_val, right_val) =>
          if
            (((left_val.["deref"](||)).["eq"](| right_val.["deref"](||)
            |)).["not"](||)
            : bool)
          then
            let kind := _crate.panicking.AssertKind.Eq in
            let '_ :=
              _crate.panicking.assert_failed(|
                kind,
                left_val.["deref"](||),
                right_val.["deref"](||),
                _crate.option.Option.Some
                  (format_arguments::["new_v1"](|
                    [ "" ],
                    [ format_argument::["new_display"](| msg |) ]
                  |))
              |) in
            tt
          else
            tt
        end in
      self.["value"]
      : T)).
  
  Global Instance Method_expect : Notation.Dot "expect" := {
    Notation.dot := expect;
  }.
  
  Definition unwrap (self : Self) :=
    ltac:(function (
      let '_ :=
        match (self.["is_some"].["unwrap_u8"](||), 1) with
        | (left_val, right_val) =>
          if
            (((left_val.["deref"](||)).["eq"](| right_val.["deref"](||)
            |)).["not"](||)
            : bool)
          then
            let kind := _crate.panicking.AssertKind.Eq in
            let '_ :=
              _crate.panicking.assert_failed(|
                kind,
                left_val.["deref"](||),
                right_val.["deref"](||),
                _crate.option.Option.None
              |) in
            tt
          else
            tt
        end in
      self.["value"]
      : T)).
  
  Global Instance Method_unwrap : Notation.Dot "unwrap" := {
    Notation.dot := unwrap;
  }.
  
  Definition unwrap_or (self : Self) (def : T) :=
    ltac:(function (
      T::["conditional_select"](| def, self.["value"], self.["is_some"] |)
      : T)).
  
  Global Instance Method_unwrap_or : Notation.Dot "unwrap_or" := {
    Notation.dot := unwrap_or;
  }.
  
  Definition unwrap_or_else (self : Self) (f : F) :=
    ltac:(function (
      T::["conditional_select"](| f(||), self.["value"], self.["is_some"] |)
      : T)).
  
  Global Instance Method_unwrap_or_else : Notation.Dot "unwrap_or_else" := {
    Notation.dot := unwrap_or_else;
  }.
  
  Definition is_some (self : ref Self) :=
    ltac:(function (self.["is_some"] : Choice)).
  
  Global Instance Method_is_some : Notation.Dot "is_some" := {
    Notation.dot := is_some;
  }.
  
  Definition is_none (self : ref Self) :=
    ltac:(function (self.["is_some"].["not"](||) : Choice)).
  
  Global Instance Method_is_none : Notation.Dot "is_none" := {
    Notation.dot := is_none;
  }.
  
  Definition map (self : Self) (f : F) :=
    ltac:(function (
      CtOption::["new"](|
        f(|
          T::["conditional_select"](|
            T::["default"](||),
            self.["value"],
            self.["is_some"]
          |)
        |),
        self.["is_some"]
      |)
      : CtOption U)).
  
  Global Instance Method_map : Notation.Dot "map" := {
    Notation.dot := map;
  }.
  
  Definition and_then (self : Self) (f : F) :=
    ltac:(function (
      let tmp :=
        f(|
          T::["conditional_select"](|
            T::["default"](||),
            self.["value"],
            self.["is_some"]
          |)
        |) in
      let '_ := tmp.["is_some"].["bitand_assign"](| self.["is_some"] |) in
      tmp
      : CtOption U)).
  
  Global Instance Method_and_then : Notation.Dot "and_then" := {
    Notation.dot := and_then;
  }.
  
  Definition or_else (self : Self) (f : F) :=
    ltac:(function (
      let is_none := self.["is_none"](||) in
      let f := f(||) in
      Self::["conditional_select"](| self, f, is_none |)
      : CtOption T)).
  
  Global Instance Method_or_else : Notation.Dot "or_else" := {
    Notation.dot := or_else;
  }.
End ImplCtOption T.

Module Impl_ConditionallySelectable_for_CtOption_T.
  Definition Self := CtOption T.
  
  Definition conditional_select
      (a : ref Self)
      (b : ref Self)
      (choice : Choice) :=
    ltac:(function (
      CtOption::["new"](|
        T::["conditional_select"](| a.["value"], b.["value"], choice |),
        Choice::["conditional_select"](| a.["is_some"], b.["is_some"], choice |)
      |)
      : Self)).
  
  Global Instance AssociatedFunction_conditional_select :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I T : ConditionallySelectable.Trait Self := {
    ConditionallySelectable.conditional_select := conditional_select;
  }.
End Impl_ConditionallySelectable_for_CtOption_T.

Module Impl_ConstantTimeEq_for_CtOption_T.
  Definition Self := CtOption T.
  
  Definition ct_eq (self : ref Self) (rhs : ref (CtOption T)) :=
    ltac:(function (
      let a := self.["is_some"](||) in
      let b := rhs.["is_some"](||) in
      ((a.["bitand"](| b |)).["bitand"](|
        self.["value"].["ct_eq"](| rhs.["value"] |)
      |)).["bitor"](| (a.["not"](||)).["bitand"](| b.["not"](||) |)
      |)
      : Choice)).
  
  Global Instance Method_ct_eq : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I T : ConstantTimeEq.Trait Self := {
    ConstantTimeEq.ct_eq := ct_eq;
  }.
End Impl_ConstantTimeEq_for_CtOption_T.

Module ConstantTimeGreater.
  Class Trait (Self : Set) : Set := {
    ct_gt : (ref Self) -> ((ref Self) -> (M Choice));
  }.
  
  Global Instance Method_ct_gt `(Trait) : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
End ConstantTimeGreater.

Module Impl_ConstantTimeGreater_for_u8.
  Definition Self := u8.
  
  Definition ct_gt (self : ref Self) (other : ref u8) :=
    ltac:(function (
      let gtb := self.["bitand"](| other.["not"](||) |) in
      let ltb := (self.["not"](||)).["bitand"](| other |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 8 |) : bool) then
            let '_ := ltb.["bitor_assign"](| ltb.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      let bit := gtb.["bitand"](| ltb.["not"](||) |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 8 |) : bool) then
            let '_ := bit.["bitor_assign"](| bit.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      Choice::["from"](| cast (bit.["bitand"](| 1 |)) u8 |)
      : Choice)).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {
    ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_ConstantTimeGreater_for_u8.

Module Impl_ConstantTimeGreater_for_u16.
  Definition Self := u16.
  
  Definition ct_gt (self : ref Self) (other : ref u16) :=
    ltac:(function (
      let gtb := self.["bitand"](| other.["not"](||) |) in
      let ltb := (self.["not"](||)).["bitand"](| other |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 16 |) : bool) then
            let '_ := ltb.["bitor_assign"](| ltb.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      let bit := gtb.["bitand"](| ltb.["not"](||) |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 16 |) : bool) then
            let '_ := bit.["bitor_assign"](| bit.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      Choice::["from"](| cast (bit.["bitand"](| 1 |)) u8 |)
      : Choice)).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {
    ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_ConstantTimeGreater_for_u16.

Module Impl_ConstantTimeGreater_for_u32.
  Definition Self := u32.
  
  Definition ct_gt (self : ref Self) (other : ref u32) :=
    ltac:(function (
      let gtb := self.["bitand"](| other.["not"](||) |) in
      let ltb := (self.["not"](||)).["bitand"](| other |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 32 |) : bool) then
            let '_ := ltb.["bitor_assign"](| ltb.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      let bit := gtb.["bitand"](| ltb.["not"](||) |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 32 |) : bool) then
            let '_ := bit.["bitor_assign"](| bit.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      Choice::["from"](| cast (bit.["bitand"](| 1 |)) u8 |)
      : Choice)).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {
    ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_ConstantTimeGreater_for_u32.

Module Impl_ConstantTimeGreater_for_u64.
  Definition Self := u64.
  
  Definition ct_gt (self : ref Self) (other : ref u64) :=
    ltac:(function (
      let gtb := self.["bitand"](| other.["not"](||) |) in
      let ltb := (self.["not"](||)).["bitand"](| other |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 64 |) : bool) then
            let '_ := ltb.["bitor_assign"](| ltb.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      let bit := gtb.["bitand"](| ltb.["not"](||) |) in
      let pow := 1 in
      let '_ :=
        loop
          (if (pow.["lt"](| 64 |) : bool) then
            let '_ := bit.["bitor_assign"](| bit.["shr"](| pow |) |) in
            let '_ := pow.["add_assign"](| pow |) in
            tt
          else
            let '_ := Break in
            tt)
          from
          while in
      Choice::["from"](| cast (bit.["bitand"](| 1 |)) u8 |)
      : Choice)).
  
  Global Instance Method_ct_gt : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : ConstantTimeGreater.Trait Self := {
    ConstantTimeGreater.ct_gt := ct_gt;
  }.
End Impl_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Class Trait (Self : Set) : Set := {
  }.
  
  Global Instance Method_ct_lt `(Trait) : Notation.Dot "ct_lt" := {
    Notation.dot (self : ref Self) (other : ref Self) :=
      (((self.["ct_gt"](| other |)).["not"](||)).["bitand"](|
        (self.["ct_eq"](| other |)).["not"](||)
      |)
      : Choice);
  }.
End ConstantTimeLess.

Module Impl_ConstantTimeLess_for_u8.
  Definition Self := u8.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u8.

Module Impl_ConstantTimeLess_for_u16.
  Definition Self := u16.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u16.

Module Impl_ConstantTimeLess_for_u32.
  Definition Self := u32.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u32.

Module Impl_ConstantTimeLess_for_u64.
  Definition Self := u64.
  
  Global Instance I : ConstantTimeLess.Trait Self :=
    ConstantTimeLess.Build_Class _.
End Impl_ConstantTimeLess_for_u64.
