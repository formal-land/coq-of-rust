(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module Container.
  Record t : Set := { _ : i32; _ : i32;}.
  
  Global Instance Get_0 : Notation.Dot 0 := {
    Notation.dot '(Build_t x0 _) := x0;
  }.
  Global Instance Get_1 : Notation.Dot 1 := {
    Notation.dot '(Build_t _ x1) := x1;
  }.
End Container.
Definition Container := Container.t.

Module Contains.
  Class Trait (Self : Set) : Set := {
    A : Set;
    B : Set;
    contains : (ref Self) -> ((ref ImplSelf.A) -> ((ref ImplSelf.B) -> bool));
    first : (ref Self) -> i32;
    last : (ref Self) -> i32;
  }.
  
  Global Instance Method_A `(Trait) : Notation.Dot "A" := {
    Notation.dot := A;
  }.
  Global Instance Method_B `(Trait) : Notation.Dot "B" := {
    Notation.dot := B;
  }.
  Global Instance Method_contains `(Trait) : Notation.Dot "contains" := {
    Notation.dot := contains;
  }.
  Global Instance Method_first `(Trait) : Notation.Dot "first" := {
    Notation.dot := first;
  }.
  Global Instance Method_last `(Trait) : Notation.Dot "last" := {
    Notation.dot := last;
  }.
End Contains.

Module Impl_Contains_for_Container.
  Definition Self := Container.
  
  Definition A : Set := i32.
  
  Definition B : Set := i32.
  
  Definition contains
      (self : ref Self)
      (number_1 : ref i32)
      (number_2 : ref i32)
      : M bool :=
    let* α0 := (deref (self.[0])).["eq"] number_1 in
    let* α1 := (deref (self.[1])).["eq"] number_2 in
    α0.["andb"] α1.
  
  Global Instance Method_contains : Notation.Dot "contains" := {
    Notation.dot := contains;
  }.
  
  Definition first (self : ref Self) : M i32 := Pure self.[0].
  
  Global Instance Method_first : Notation.Dot "first" := {
    Notation.dot := first;
  }.
  
  Definition last (self : ref Self) : M i32 := Pure self.[1].
  
  Global Instance Method_last : Notation.Dot "last" := {
    Notation.dot := last;
  }.
  
  Global Instance I : Contains.Trait Self := {
    Contains.contains := contains;
    Contains.first := first;
    Contains.last := last;
  }.
End Impl_Contains_for_Container.

Definition difference
    {C : Set}
    `{Contains.Trait C}
    (container : ref C)
    : M i32 :=
  let* α0 := container.["last"] in
  let* α1 := container.["first"] in
  α0.["sub"] α1.

(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (_ : unit) : M unit :=
  let number_1 := 3 in
  let number_2 := 10 in
  let container := Container.Build_t number_1 number_2 in
  let* α0 := format_argument::["new_display"] (deref (deref number_1)) in
  let* α1 := format_argument::["new_display"] (deref (deref number_2)) in
  let* α2 := container.["contains"] (deref number_1) (deref number_2) in
  let* α3 := format_argument::["new_display"] (deref α2) in
  let* α4 :=
    format_arguments::["new_v1"]
      (deref [ "Does container contain "; " and "; ": "; "
" ])
      (deref [ α0; α1; α3 ]) in
  let* _ := _crate.io._print α4 in
  let _ := tt in
  let* α5 := container.["first"] in
  let* α6 := format_argument::["new_display"] (deref α5) in
  let* α7 :=
    format_arguments::["new_v1"]
      (deref [ "First number: "; "
" ])
      (deref [ α6 ]) in
  let* _ := _crate.io._print α7 in
  let _ := tt in
  let* α8 := container.["last"] in
  let* α9 := format_argument::["new_display"] (deref α8) in
  let* α10 :=
    format_arguments::["new_v1"]
      (deref [ "Last number: "; "
" ])
      (deref [ α9 ]) in
  let* _ := _crate.io._print α10 in
  let _ := tt in
  let* α11 := difference (deref container) in
  let* α12 := format_argument::["new_display"] (deref α11) in
  let* α13 :=
    format_arguments::["new_v1"]
      (deref [ "The difference is: "; "
" ])
      (deref [ α12 ]) in
  let* _ := _crate.io._print α13 in
  let _ := tt in
  Pure tt.
