(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import std.prelude.rust_2021.

(** @TODO, use ink_env!? *)
Module Root.
  Module ink.
    Module storage.
      Module traits.
        Module AutoStorableHint.
          Parameter Type_ : Set.
        End AutoStorableHint.
      End traits.
    End storage.

    Module env.
      Parameter DefaultEnvironment : Set.

      Module ContractEnv.
        Class Trait (Self : Set) : Set := {
            (* ??? *)
          }.
        
        Parameter Env : Set.
      End ContractEnv.
      Module Environment.
        Parameter AccountId : Set.
        Parameter Balance : Set.
        Parameter Hash : Set.
        Parameter Timestamp : Set.
        Parameter BlockNumber : Set.
        Parameter ChainExtension : Set.
        Parameter MAX_EVENT_TOPICS : M usize.
      End Environment.
    End env.
    Module reflect.
      Module ConstructorOutput.
        Parameter Error : Set.
        (* @TODO Not sure about this, it is a guess *)
        Parameter IS_RESULT : unit -> M bool.
      End ConstructorOutput.

      Module DispatchableConstructorInfo.
        Class Trait (Self : Set) : Set := {
          IS_RESULT : unit -> M bool;
          CALLABLE : Root.ink.storage.traits.AutoStorableHint.Type_ -> M Self;
          PAYABLE : bool;
          SELECTOR : list Z;
          LABEL : string;
        }.
      End DispatchableConstructorInfo.

      Module DispatchableMessageInfo.
     (* : unit -> ImplFlipper.Self -> unit -> bool *)
        Class Trait (Self : Set) := {
            CALLABLE : Self -> Root.ink.storage.traits.AutoStorableHint.Type_ -> M unit;
            MUTATES : bool;
            PAYABLE : bool;
            SELECTOR : list Z;
            LABEL : string;
          }.
      End DispatchableMessageInfo.
    End reflect.
    Module codegen.
      Module ContractCallBuilder.
        Parameter Type_ : Set.
      End ContractCallBuilder.

      Parameter EventTopics : Set.
      Module EventLenTopics.
        Parameter Type_ : Set.
        
        Class Trait (Self : Set) : Set := {
          }.
      End EventLenTopics.
      Definition EventLenTopics := EventLenTopics.Type_.
    End codegen.
  End ink.
End Root.

Module erc20.
  Module Erc20.
    Record t : Set := {
      total_supply : Root.ink.storage.traits.AutoStorableHint.Type_;
      balances : Root.ink.storage.traits.AutoStorableHint.Type_;
      allowances : Root.ink.storage.traits.AutoStorableHint.Type_;
    }.
    
    Global Instance Get_total_supply : Notation.Dot "total_supply" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_balances : Notation.Dot "balances" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_allowances : Notation.Dot "allowances" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Erc20.
  Definition Erc20 : Set := Erc20.t.
  
  Module Impl_Root_ink_env_ContractEnv_for_Erc20.
    Definition Self := Erc20.
    
    Definition Env : Set := Root.ink.env.DefaultEnvironment.
    
    Global Instance I : Root.ink.env.ContractEnv.Trait Self := {
    }.
  End Impl_Root_ink_env_ContractEnv_for_Erc20.
  
  Definition Environment : Set := Root.ink.env.ContractEnv.Env.
  
  Definition AccountId : Set := Root.ink.env.Environment.AccountId.
  
  Definition Balance : Set := Root.ink.env.Environment.Balance.
  
  Definition Hash : Set := Root.ink.env.Environment.Hash.
  
  Definition Timestamp : Set := Root.ink.env.Environment.Timestamp.
  
  Definition BlockNumber : Set := Root.ink.env.Environment.BlockNumber.
  
  Definition ChainExtension : Set := Root.ink.env.Environment.ChainExtension.
  
  Definition MAX_EVENT_TOPICS : usize :=
    run (Root.ink.env.Environment.MAX_EVENT_TOPICS).
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  Module Impl__crate_default_Default_for_Erc20.
    Definition Self := Erc20.

    (* depends on create default *)
    (* Definition default (_ : unit) : Erc20 := *)
    (*   {| *)
    (*     Erc20.total_supply := _crate.default.Default.default tt; *)
    (*     Erc20.balances := _crate.default.Default.default tt; *)
    (*     Erc20.allowances := _crate.default.Default.default tt; *)
    (*   |}. *)
    
    (* Global Instance AssociatedFunction_default : *)
    (*   Notation.DoubleColon Self "default" := { *)
    (*   Notation.double_colon := default; *)
    (* }. *)
    
    (* Global Instance I : _crate.default.Default.Trait Self := { *)
    (*   _crate.default.Default.default := default; *)
    (* }. *)
  End Impl__crate_default_Default_for_Erc20.
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  Module Transfer.
    Record t : Set := {
      from : core.option.Option AccountId;
      to : core.option.Option AccountId;
      value : Balance;
    }.
    
    Global Instance Get_from : Notation.Dot "from" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_to : Notation.Dot "to" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Transfer.
  Definition Transfer : Set := Transfer.t.

  Module Approval.
    Record t : Set := {
      owner : AccountId;
      spender : AccountId;
      value : Balance;
    }.
    
    Global Instance Get_owner : Notation.Dot "owner" := {
      Notation.dot '(Build_t x0 _ _) := x0;
    }.
    Global Instance Get_spender : Notation.Dot "spender" := {
      Notation.dot '(Build_t _ x1 _) := x1;
    }.
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t _ _ x2) := x2;
    }.
  End Approval.
  Definition Approval : Set := Approval.t.

  Module __ink_EventBase.
    Inductive t : Set :=
    | Transfer (_ : Transfer)
    | Approval (_ : Approval).
  End __ink_EventBase.
  Definition __ink_EventBase := __ink_EventBase.t.
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  Module Impl_Root_ink_codegen_EventLenTopics_for_Transfer.
    Definition Self := Transfer.
    
    Definition LenTopics : Set := Root.ink.codegen.EventTopics.
    
    Global Instance I : Root.ink.codegen.EventLenTopics.Trait Self := {
    }.
  End Impl_Root_ink_codegen_EventLenTopics_for_Transfer.
  
  (* Definition _ : unit := run ((Root.ink.codegen.utils.consume_type tt)). *)
  
  Module Impl_Root_ink_codegen_EventLenTopics_for_Approval.
    Definition Self := Approval.
    
    Definition LenTopics : Set := Root.ink.codegen.EventTopics.
    
    Global Instance I : Root.ink.codegen.EventLenTopics.Trait Self := {
    }.
  End Impl_Root_ink_codegen_EventLenTopics_for_Approval.
  
  (* Definition _ : unit := run ((Root.ink.codegen.utils.consume_type tt)). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  (* Definition _ : unit := run (tt). *)
  
  Module Impl_Root_ink_reflect_DispatchableConstructorInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := Balance.
    
    Definition Output : Set := Self.
    
    Definition Storage : Set := Erc20.
    
    Definition Error : Set := Root.ink.reflect.ConstructorOutput.Error.
    
    Definition IS_RESULT := Root.ink.reflect.ConstructorOutput.IS_RESULT.
    
    Global Instance AssociatedFunction_IS_RESULT :
      Notation.DoubleColon Self "IS_RESULT" := {
      Notation.double_colon := IS_RESULT;
    }.

    Global Instance Erc20_new_method : Notation.DoubleColon Erc20 "new" (T := Root.ink.storage.traits.AutoStorableHint.Type_ -> M Erc20). Admitted.
    
    Definition
      CALLABLE := fun (__ink_binding_0 : _) => Erc20::["new"] __ink_binding_0.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition SELECTOR := [ 155; 174; 157; 94 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition LABEL := "new".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I
        :
        Root.ink.reflect.DispatchableConstructorInfo.Trait
        Self :=
      {
      Root.ink.reflect.DispatchableConstructorInfo.IS_RESULT := IS_RESULT;
      Root.ink.reflect.DispatchableConstructorInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableConstructorInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableConstructorInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableConstructorInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableConstructorInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := unit.
    
    Definition Output : Set := Balance.
    
    Definition Storage : Set := Erc20.

    Global Instance Erc20_total_supply :
      Notation.DoubleColon Erc20 "total_supply"
        (T := Root.ink.storage.traits.AutoStorableHint.Type_ -> M Erc20).
    Admitted.
    
    Definition CALLABLE := fun storage (_ : Root.ink.storage.traits.AutoStorableHint.Type_)  => Erc20::["total_supply"] storage.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 219; 99; 117; 168 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := false.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "total_supply".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    (* WIP *)
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := AccountId.
    
    Definition Output : Set := Balance.
    
    Definition Storage : Set := Erc20.
    
    Definition
      CALLABLE := fun storage __ink_binding_0 =>
        Erc20::["balance_of"] storage __ink_binding_0.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 15; 117; 90; 86 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := false.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "balance_of".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := AccountId * AccountId.
    
    Definition Output : Set := Balance.
    
    Definition Storage : Set := Erc20.
    
    Definition
      CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
        Erc20::["allowance"] storage __ink_binding_0 __ink_binding_1.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 106; 0; 22; 94 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := false.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "allowance".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := AccountId * Balance.
    
    Definition Output : Set := Result unit.
    
    Definition Storage : Set := Erc20.
    
    Definition
      CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
        Erc20::["transfer"] storage __ink_binding_0 __ink_binding_1.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 132; 161; 93; 161 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := true.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "transfer".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := AccountId * Balance.
    
    Definition Output : Set := Result unit.
    
    Definition Storage : Set := Erc20.
    
    Definition
      CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
        Erc20::["approve"] storage __ink_binding_0 __ink_binding_1.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 104; 18; 102; 160 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := true.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "approve".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
    Definition Self := Erc20.
    
    Definition Input : Set := AccountId * AccountId * Balance.
    
    Definition Output : Set := Result unit.
    
    Definition Storage : Set := Erc20.
    
    Definition
      CALLABLE := fun
          storage
          (__ink_binding_0, __ink_binding_1, __ink_binding_2) =>
        Erc20::["transfer_from"]
          storage
          __ink_binding_0
          __ink_binding_1
          __ink_binding_2.
    
    Global Instance AssociatedFunction_CALLABLE :
      Notation.DoubleColon Self "CALLABLE" := {
      Notation.double_colon := CALLABLE;
    }.
    
    Definition SELECTOR := [ 11; 57; 111; 24 ].
    
    Global Instance AssociatedFunction_SELECTOR :
      Notation.DoubleColon Self "SELECTOR" := {
      Notation.double_colon := SELECTOR;
    }.
    
    Definition PAYABLE := false.
    
    Global Instance AssociatedFunction_PAYABLE :
      Notation.DoubleColon Self "PAYABLE" := {
      Notation.double_colon := PAYABLE;
    }.
    
    Definition MUTATES := true.
    
    Global Instance AssociatedFunction_MUTATES :
      Notation.DoubleColon Self "MUTATES" := {
      Notation.double_colon := MUTATES;
    }.
    
    Definition LABEL := "transfer_from".
    
    Global Instance AssociatedFunction_LABEL :
      Notation.DoubleColon Self "LABEL" := {
      Notation.double_colon := LABEL;
    }.
    
    Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
      Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
      Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
      Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
      Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
      Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
    }.
  End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Module Erc20Ref.
    Record t : Set := {
      inner : Root.ink.codegen.ContractCallBuilder.Type;
    }.
    
    Global Instance Get_inner : Notation.Dot "inner" := {
      Notation.dot '(Build_t x0) := x0;
    }.
  End Erc20Ref.
  Definition Erc20Ref : Set := Erc20Ref.t.
  
  Module Impl__crate_fmt_Debug_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref _crate.fmt.Formatter)
        : _crate.fmt.Result :=
      _crate.fmt.Formatter::["debug_struct_field1_finish"]
        f
        "Erc20Ref"
        "inner"
        (addr_of (addr_of self.["inner"])).
    
    Global Instance Method_fmt : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : _crate.fmt.Debug.Trait Self := {
      _crate.fmt.Debug.fmt := fmt;
    }.
  End Impl__crate_fmt_Debug_for_Erc20Ref.
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Module Impl__crate_hash_Hash_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition hash (self : ref Self) (state : mut_ref __H) : unit :=
      _crate.hash.Hash.hash (addr_of self.["inner"]) state.
    
    Global Instance Method_hash : Notation.Dot "hash" := {
      Notation.dot := hash;
    }.
    
    Global Instance I : _crate.hash.Hash.Trait Self := {
      _crate.hash.Hash.hash := hash;
    }.
  End Impl__crate_hash_Hash_for_Erc20Ref.
  
  Module Impl__crate_marker_StructuralPartialEq_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
      _crate.marker.StructuralPartialEq.Build_Class _.
  End Impl__crate_marker_StructuralPartialEq_for_Erc20Ref.
  
  Module Impl__crate_cmp_PartialEq_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition eq (self : ref Self) (other : ref Erc20Ref) : bool :=
      self.["inner"].["eq"] other.["inner"].
    
    Global Instance Method_eq : Notation.Dot "eq" := {
      Notation.dot := eq;
    }.
    
    Global Instance I : _crate.cmp.PartialEq.Trait Self := {
      _crate.cmp.PartialEq.eq := eq;
    }.
  End Impl__crate_cmp_PartialEq_for_Erc20Ref.
  
  Module Impl__crate_marker_StructuralEq_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Global Instance I : _crate.marker.StructuralEq.Trait Self :=
      _crate.marker.StructuralEq.Build_Class _.
  End Impl__crate_marker_StructuralEq_for_Erc20Ref.
  
  Module Impl__crate_cmp_Eq_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition assert_receiver_is_total_eq (self : ref Self) : unit :=
      let _ := tt in
      tt.
    
    Global Instance Method_assert_receiver_is_total_eq :
      Notation.Dot "assert_receiver_is_total_eq" := {
      Notation.dot := assert_receiver_is_total_eq;
    }.
    
    Global Instance I : _crate.cmp.Eq.Trait Self := {
    }.
  End Impl__crate_cmp_Eq_for_Erc20Ref.
  
  Module Impl__crate_clone_Clone_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition clone (self : ref Self) : Erc20Ref :=
      {| Erc20Ref.inner := _crate.clone.Clone.clone (addr_of self.["inner"]);
      |}.
    
    Global Instance Method_clone : Notation.Dot "clone" := {
      Notation.dot := clone;
    }.
    
    Global Instance I : _crate.clone.Clone.Trait Self := {
      _crate.clone.Clone.clone := clone;
    }.
  End Impl__crate_clone_Clone_for_Erc20Ref.
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Module ImplErc20Ref.
    Definition Self := Erc20Ref.
    
    Definition new
        (__ink_binding_0 : Balance)
        :
          Root.ink.env.call.CreateBuilder
            Environment
            Self
            (Root.ink.env.call.utils.Unset Hash)
            (Root.ink.env.call.utils.Unset u64)
            (Root.ink.env.call.utils.Unset Balance)
            (Root.ink.env.call.utils.Set
              (Root.ink.env.call.ExecutionInput
                (Root.ink.env.call.utils.ArgumentList
                  (Root.ink.env.call.utils.Argument Balance)
                  Root.ink.env.call.utils.EmptyArgumentList)))
            (Root.ink.env.call.utils.Unset Root.ink.env.call.state.Salt)
            (Root.ink.env.call.utils.Set
              (Root.ink.env.call.utils.ReturnType Self)) :=
      ((Root.ink.env.call.build_create tt).["exec_input"]
          ((Root.ink.env.call.ExecutionInput::["new"]
              (Root.ink.env.call.Selector::["new"]
                [ 155; 174; 157; 94 ])).["push_arg"]
            __ink_binding_0)).["returns"].
    
    Global Instance AssociatedFunction_new :
      Notation.DoubleColon Self "new" := {
      Notation.double_colon := new;
    }.
    
    Definition total_supply (self : ref Self) : Balance :=
      self.["try_total_supply"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::total_supply: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_total_supply : Notation.Dot "total_supply" := {
      Notation.dot := total_supply;
    }.
    
    Definition try_total_supply
        (self : ref Self)
        : Root.ink.MessageResult Balance :=
      (Root.ink.codegen.TraitCallBuilder.call
              self).["total_supply"].["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::total_supply: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_total_supply :
      Notation.Dot "try_total_supply" := {
      Notation.dot := try_total_supply;
    }.
    
    Definition balance_of (self : ref Self) (owner : AccountId) : Balance :=
      (self.["try_balance_of"] owner).["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::balance_of: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_balance_of : Notation.Dot "balance_of" := {
      Notation.dot := balance_of;
    }.
    
    Definition try_balance_of
        (self : ref Self)
        (owner : AccountId)
        : Root.ink.MessageResult Balance :=
      ((Root.ink.codegen.TraitCallBuilder.call self).["balance_of"]
            owner).["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::balance_of: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_balance_of : Notation.Dot "try_balance_of" := {
      Notation.dot := try_balance_of;
    }.
    
    Definition allowance
        (self : ref Self)
        (owner : AccountId)
        (spender : AccountId)
        : Balance :=
      (self.["try_allowance"] owner spender).["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::allowance: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_allowance : Notation.Dot "allowance" := {
      Notation.dot := allowance;
    }.
    
    Definition try_allowance
        (self : ref Self)
        (owner : AccountId)
        (spender : AccountId)
        : Root.ink.MessageResult Balance :=
      ((Root.ink.codegen.TraitCallBuilder.call self).["allowance"]
            owner
            spender).["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::allowance: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_allowance : Notation.Dot "try_allowance" := {
      Notation.dot := try_allowance;
    }.
    
    Definition transfer
        (self : mut_ref Self)
        (to : AccountId)
        (value : Balance)
        : Result unit :=
      (self.["try_transfer"] to value).["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::transfer: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_transfer : Notation.Dot "transfer" := {
      Notation.dot := transfer;
    }.
    
    Definition try_transfer
        (self : mut_ref Self)
        (to : AccountId)
        (value : Balance)
        : Root.ink.MessageResult (Result unit) :=
      ((Root.ink.codegen.TraitCallBuilder.call_mut self).["transfer"]
            to
            value).["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::transfer: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_transfer : Notation.Dot "try_transfer" := {
      Notation.dot := try_transfer;
    }.
    
    Definition approve
        (self : mut_ref Self)
        (spender : AccountId)
        (value : Balance)
        : Result unit :=
      (self.["try_approve"] spender value).["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::approve: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_approve : Notation.Dot "approve" := {
      Notation.dot := approve;
    }.
    
    Definition try_approve
        (self : mut_ref Self)
        (spender : AccountId)
        (value : Balance)
        : Root.ink.MessageResult (Result unit) :=
      ((Root.ink.codegen.TraitCallBuilder.call_mut self).["approve"]
            spender
            value).["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of [ "encountered error while calling Erc20::approve: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_approve : Notation.Dot "try_approve" := {
      Notation.dot := try_approve;
    }.
    
    Definition transfer_from
        (self : mut_ref Self)
        (from : AccountId)
        (to : AccountId)
        (value : Balance)
        : Result unit :=
      (self.["try_transfer_from"] from to value).["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::transfer_from: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_transfer_from : Notation.Dot "transfer_from" := {
      Notation.dot := transfer_from;
    }.
    
    Definition try_transfer_from
        (self : mut_ref Self)
        (from : AccountId)
        (to : AccountId)
        (value : Balance)
        : Root.ink.MessageResult (Result unit) :=
      ((Root.ink.codegen.TraitCallBuilder.call_mut self).["transfer_from"]
            from
            to
            value).["try_invoke"].["unwrap_or_else"]
        (fun error =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_v1"]
              (addr_of
                [ "encountered error while calling Erc20::transfer_from: " ])
              (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
    
    Global Instance Method_try_transfer_from :
      Notation.Dot "try_transfer_from" := {
      Notation.dot := try_transfer_from;
    }.
  End ImplErc20Ref.
  
  Definition _ : unit := run (tt).
  
  Module Impl_Root_ink_env_call_FromAccountId_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition from_account_id (account_id : AccountId) : Self :=
      {|
        Self.inner :=
          Root.ink.env.call.FromAccountId.from_account_id account_id;
      |}.
    
    Global Instance AssociatedFunction_from_account_id :
      Notation.DoubleColon Self "from_account_id" := {
      Notation.double_colon := from_account_id;
    }.
    
    Global Instance I
        :
        Root.ink.env.call.FromAccountId.Trait
        Self
        Environment :=
      {
      Root.ink.env.call.FromAccountId.from_account_id := from_account_id;
    }.
  End Impl_Root_ink_env_call_FromAccountId_for_Erc20Ref.
  
  Module Impl_Root_ink_ToAccountId_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition to_account_id (self : ref Self) : AccountId :=
      Root.ink.ToAccountId.to_account_id (addr_of self.["inner"]).
    
    Global Instance Method_to_account_id : Notation.Dot "to_account_id" := {
      Notation.dot := to_account_id;
    }.
    
    Global Instance I : Root.ink.ToAccountId.Trait Self Environment := {
      Root.ink.ToAccountId.to_account_id := to_account_id;
    }.
  End Impl_Root_ink_ToAccountId_for_Erc20Ref.
  
  Module Impl_Root_core_convert_AsRef_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition as_ref (self : ref Self) : ref AccountId :=
      Root.core.convert.AsRef.as_ref (addr_of self.["inner"]).
    
    Global Instance Method_as_ref : Notation.Dot "as_ref" := {
      Notation.dot := as_ref;
    }.
    
    Global Instance I : Root.core.convert.AsRef.Trait Self AccountId := {
      Root.core.convert.AsRef.as_ref := as_ref;
    }.
  End Impl_Root_core_convert_AsRef_for_Erc20Ref.
  
  Module Impl_Root_core_convert_AsMut_for_Erc20Ref.
    Definition Self := Erc20Ref.
    
    Definition as_mut (self : mut_ref Self) : mut_ref AccountId :=
      Root.core.convert.AsMut.as_mut (addr_of self.["inner"]).
    
    Global Instance Method_as_mut : Notation.Dot "as_mut" := {
      Notation.dot := as_mut;
    }.
    
    Global Instance I : Root.core.convert.AsMut.Trait Self AccountId := {
      Root.core.convert.AsMut.as_mut := as_mut;
    }.
  End Impl_Root_core_convert_AsMut_for_Erc20Ref.
  
  Definition _ : unit := run (tt).
  
  Module Mapping := ink.storage.Mapping.
  Definition Mapping := Mapping.t.
  
  Module Error.
    Inductive t : Set :=
    | InsufficientBalance
    | InsufficientAllowance.
  End Error.
  Definition Error := Error.t.
  
  Definition _ : unit := run (tt).
  
  Module Impl__crate_fmt_Debug_for_Error.
    Definition Self := Error.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref _crate.fmt.Formatter)
        : _crate.fmt.Result :=
      _crate.fmt.Formatter::["write_str"]
        f
        match self with
        | Error.InsufficientBalance => "InsufficientBalance"
        | Error.InsufficientAllowance => "InsufficientAllowance"
        end.
    
    Global Instance Method_fmt : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : _crate.fmt.Debug.Trait Self := {
      _crate.fmt.Debug.fmt := fmt;
    }.
  End Impl__crate_fmt_Debug_for_Error.
  
  Module Impl__crate_marker_StructuralPartialEq_for_Error.
    Definition Self := Error.
    
    Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
      _crate.marker.StructuralPartialEq.Build_Class _.
  End Impl__crate_marker_StructuralPartialEq_for_Error.
  
  Module Impl__crate_cmp_PartialEq_for_Error.
    Definition Self := Error.
    
    Definition eq (self : ref Self) (other : ref Error) : bool :=
      let __self_tag := _crate.intrinsics.discriminant_value self in
      let __arg1_tag := _crate.intrinsics.discriminant_value other in
      __self_tag.["eq"] __arg1_tag.
    
    Global Instance Method_eq : Notation.Dot "eq" := {
      Notation.dot := eq;
    }.
    
    Global Instance I : _crate.cmp.PartialEq.Trait Self := {
      _crate.cmp.PartialEq.eq := eq;
    }.
  End Impl__crate_cmp_PartialEq_for_Error.
  
  Module Impl__crate_marker_StructuralEq_for_Error.
    Definition Self := Error.
    
    Global Instance I : _crate.marker.StructuralEq.Trait Self :=
      _crate.marker.StructuralEq.Build_Class _.
  End Impl__crate_marker_StructuralEq_for_Error.
  
  Module Impl__crate_cmp_Eq_for_Error.
    Definition Self := Error.
    
    Definition assert_receiver_is_total_eq (self : ref Self) : unit := tt.
    
    Global Instance Method_assert_receiver_is_total_eq :
      Notation.Dot "assert_receiver_is_total_eq" := {
      Notation.dot := assert_receiver_is_total_eq;
    }.
    
    Global Instance I : _crate.cmp.Eq.Trait Self := {
    }.
  End Impl__crate_cmp_Eq_for_Error.
  
  Definition _ : unit := run (tt).
  
  Definition _ : unit := run (tt).
  
  Definition Result : Set := core.result.Result T Error.
End erc20.

Module Impl_Root_ink_env_ContractEnv_for_Erc20.
  Definition Self := Erc20.
  
  Definition Env : Set := Root.ink.env.DefaultEnvironment.
  
  Global Instance I : Root.ink.env.ContractEnv.Trait Self := {
  }.
End Impl_Root_ink_env_ContractEnv_for_Erc20.

Definition Environment : Set := Root.ink.env.ContractEnv.Env.

Definition AccountId : Set := Root.ink.env.Environment.AccountId.

Definition Balance : Set := Root.ink.env.Environment.Balance.

Definition Hash : Set := Root.ink.env.Environment.Hash.

Definition Timestamp : Set := Root.ink.env.Environment.Timestamp.

Definition BlockNumber : Set := Root.ink.env.Environment.BlockNumber.

Definition ChainExtension : Set := Root.ink.env.Environment.ChainExtension.

Definition MAX_EVENT_TOPICS : usize :=
  run (Root.ink.env.Environment.MAX_EVENT_TOPICS).

Definition _ : unit := run (tt).

Module Check.
  Record t : Set := {
    salt : unit;
    field_0 : Balance;
    field_1 : Mapping AccountId Balance;
    field_2 : Mapping (AccountId * AccountId) Balance;
  }.
  
  Global Instance Get_salt : Notation.Dot "salt" := {
    Notation.dot '(Build_t x0 _ _ _) := x0;
  }.
  Global Instance Get_field_0 : Notation.Dot "field_0" := {
    Notation.dot '(Build_t _ x1 _ _) := x1;
  }.
  Global Instance Get_field_1 : Notation.Dot "field_1" := {
    Notation.dot '(Build_t _ _ x2 _) := x2;
  }.
  Global Instance Get_field_2 : Notation.Dot "field_2" := {
    Notation.dot '(Build_t _ _ _ x3) := x3;
  }.
End Check.
Definition Check : Set := Check.t.

Module Erc20.
  Record t : Set := {
    total_supply : Root.ink.storage.traits.AutoStorableHint.Type;
    balances : Root.ink.storage.traits.AutoStorableHint.Type;
    allowances : Root.ink.storage.traits.AutoStorableHint.Type;
  }.
  
  Global Instance Get_total_supply : Notation.Dot "total_supply" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_balances : Notation.Dot "balances" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_allowances : Notation.Dot "allowances" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Erc20.
Definition Erc20 : Set := Erc20.t.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_StorableHint_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := Erc20.
  
  Definition PreferredKey : Set := Root.ink.storage.traits.AutoKey.
  
  Global Instance I
      __ink_generic_salt
      :
      Root.ink.storage.traits.StorableHint.Trait
      Self
      __ink_generic_salt :=
    {
  }.
End Impl_Root_ink_storage_traits_StorableHint_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_StorageKey_for_Erc20.
  Definition Self := Erc20.
  
  Definition KEY := Root.ink.storage.traits.StorageKey.KEY.
  
  Global Instance AssociatedFunction_KEY : Notation.DoubleColon Self "KEY" := {
    Notation.double_colon := KEY;
  }.
  
  Global Instance I : Root.ink.storage.traits.StorageKey.Trait Self := {
    Root.ink.storage.traits.StorageKey.KEY := KEY;
  }.
End Impl_Root_ink_storage_traits_StorageKey_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_Storable_for_Erc20.
  Definition Self := Erc20.
  
  Definition decode
      (__input : mut_ref __ink_I)
      : Root.core.result.Result Self Root.scale.Error :=
    Root.core.result.Result.Ok
      {|
        Erc20.total_supply :=
          match LangItem (Root.ink.storage.traits.Storable.decode __input) with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end;
        Erc20.balances :=
          match LangItem (Root.ink.storage.traits.Storable.decode __input) with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end;
        Erc20.allowances :=
          match LangItem (Root.ink.storage.traits.Storable.decode __input) with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end;
      |}.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Definition encode (self : ref Self) (__dest : mut_ref __ink_O) : unit :=
    match self with
    |
        {|
          Erc20.total_supply := __binding_0;
          Erc20.balances := __binding_1;
          Erc20.allowances := __binding_2;
        |}
        =>
      let _ :=
        let _ := Root.ink.storage.traits.Storable.encode __binding_0 __dest in
        tt in
      let _ :=
        let _ := Root.ink.storage.traits.Storable.encode __binding_1 __dest in
        tt in
      let _ := Root.ink.storage.traits.Storable.encode __binding_2 __dest in
      tt
    end.
  
  Global Instance Method_encode : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Global Instance I : Root.ink.storage.traits.Storable.Trait Self := {
    Root.ink.storage.traits.Storable.encode := encode;
    Root.ink.storage.traits.Storable.decode := decode;
  }.
End Impl_Root_ink_storage_traits_Storable_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_scale_info_TypeInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Identity : Set := Self.
  
  Definition type_info (_ : unit) : Root.scale_info.Type :=
    ((((Root.scale_info.Type::["builder"] tt).["path"]
            (Root.scale_info.Path::["new"]
              "Erc20"
              "erc20::erc20")).["type_params"]
          (_crate.vec.Vec::["new"] tt)).["docs"]
        (addr_of [ "A simple ERC-20 contract." ])).["composite"]
      ((((Root.scale_info.build.Fields::["named"] tt).["field"]
            (fun f =>
              ((f.["ty"].["name"] "total_supply").["type_name"]
                  "<Balance as::ink::storage::traits::AutoStorableHint<::ink::
storage::traits::ManualKey<375105693u32, ()>,>>::Type").["docs"]
                (addr_of [ "Total token supply." ]))).["field"]
          (fun f =>
            ((f.["ty"].["name"] "balances").["type_name"]
                "<Mapping<AccountId, Balance> as::ink::storage::traits::
AutoStorableHint<::ink::storage::traits::ManualKey<639884519u32, ()
>,>>::Type").["docs"]
              (addr_of
                [ "Mapping from owner to number of owned token." ]))).["field"]
        (fun f =>
          ((f.["ty"].["name"] "allowances").["type_name"]
              "<Mapping<(AccountId, AccountId), Balance> as::ink::storage::traits
::AutoStorableHint<::ink::storage::traits::ManualKey<
3969917367u32, ()>,>>::Type").["docs"]
            (addr_of
              [
                "Mapping of the token amount which an account is allowed to withdraw";
                "from another account."
              ]))).
  
  Global Instance AssociatedFunction_type_info :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : Root.scale_info.TypeInfo.Trait Self := {
    Root.scale_info.TypeInfo.type_info := type_info;
  }.
End Impl_Root_scale_info_TypeInfo_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_StorageLayout_for_Erc20.
  Definition Self := Erc20.
  
  Definition layout
      (__key : ref Root.ink.primitives.Key)
      : Root.ink.metadata.layout.Layout :=
    Root.ink.metadata.layout.Layout.Struct
      (Root.ink.metadata.layout.StructLayout::["new"]
        "Erc20"
        [
          Root.ink.metadata.layout.FieldLayout::["new"]
            "total_supply"
            (Root.ink.storage.traits.StorageLayout.layout __key);
          Root.ink.metadata.layout.FieldLayout::["new"]
            "balances"
            (Root.ink.storage.traits.StorageLayout.layout __key);
          Root.ink.metadata.layout.FieldLayout::["new"]
            "allowances"
            (Root.ink.storage.traits.StorageLayout.layout __key)
        ]).
  
  Global Instance AssociatedFunction_layout :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : Root.ink.storage.traits.StorageLayout.Trait Self := {
    Root.ink.storage.traits.StorageLayout.layout := layout;
  }.
End Impl_Root_ink_storage_traits_StorageLayout_for_Erc20.

Module Impl__crate_default_Default_for_Erc20.
  Definition Self := Erc20.
  
  Definition default (_ : unit) : Erc20 :=
    {|
      Erc20.total_supply := _crate.default.Default.default tt;
      Erc20.balances := _crate.default.Default.default tt;
      Erc20.allowances := _crate.default.Default.default tt;
    |}.
  
  Global Instance AssociatedFunction_default :
    Notation.DoubleColon Self "default" := {
    Notation.double_colon := default;
  }.
  
  Global Instance I : _crate.default.Default.Trait Self := {
    _crate.default.Default.default := default;
  }.
End Impl__crate_default_Default_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_ink_reflect_ContractName_for_Erc20.
  Definition Self := Erc20.
  
  Definition NAME := "Erc20".
  
  Global Instance AssociatedFunction_NAME :
    Notation.DoubleColon Self "NAME" := {
    Notation.double_colon := NAME;
  }.
  
  Global Instance I : Root.ink.reflect.ContractName.Trait Self := {
    Root.ink.reflect.ContractName.NAME := NAME;
  }.
End Impl_Root_ink_reflect_ContractName_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_Root_ink_codegen_Env_for_StaticRef_Erc20.
  Definition Self := ref Erc20.
  
  Definition EnvAccess : Set := Root.ink.EnvAccess Root.ink.env.ContractEnv.Env.
  
  Definition env (self : Self) : ImplSelf.EnvAccess :=
    Root.core.default.Default.default tt.
  
  Global Instance Method_env : Notation.Dot "env" := {
    Notation.dot := env;
  }.
  
  Global Instance I : Root.ink.codegen.Env.Trait Self := {
    Root.ink.codegen.Env.env := env;
  }.
End Impl_Root_ink_codegen_Env_for_StaticRef_Erc20.

Module Impl_Root_ink_codegen_StaticEnv_for_Erc20.
  Definition Self := Erc20.
  
  Definition EnvAccess : Set := Root.ink.EnvAccess Root.ink.env.ContractEnv.Env.
  
  Definition env (_ : unit) : ImplSelf.EnvAccess :=
    Root.core.default.Default.default tt.
  
  Global Instance AssociatedFunction_env : Notation.DoubleColon Self "env" := {
    Notation.double_colon := env;
  }.
  
  Global Instance I : Root.ink.codegen.StaticEnv.Trait Self := {
    Root.ink.codegen.StaticEnv.env := env;
  }.
End Impl_Root_ink_codegen_StaticEnv_for_Erc20.

Definition _ : unit := run (tt).

Definition _ : unit := run (tt).

Module Impl_Root_ink_codegen_EmitEvent_for_Root_ink_EnvAccess_Environment.
  Definition Self := Root.ink.EnvAccess Environment.
  
  Definition emit_event (self : Self) (event : E) : unit :=
    let _ := Root.ink.env.emit_event event.["into"] in
    tt.
  
  Global Instance Method_emit_event : Notation.Dot "emit_event" := {
    Notation.dot := emit_event;
  }.
  
  Global Instance I : Root.ink.codegen.EmitEvent.Trait Self Erc20 := {
    Root.ink.codegen.EmitEvent.emit_event := emit_event;
  }.
End Impl_Root_ink_codegen_EmitEvent_for_Root_ink_EnvAccess_Environment.

Module __ink_EventBase.
  Inductive t : Set :=
  | Transfer (_ : Transfer)
  | Approval (_ : Approval).
End __ink_EventBase.
Definition __ink_EventBase := __ink_EventBase.t.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    match self.["deref"] with
    | __ink_EventBase.Transfer aa =>
      let _ :=
        __codec_dest_edqy.["push_byte"] (cast 0 Root.core.primitive.u8) in
      let _ := Root.scale.Encode.encode_to aa __codec_dest_edqy in
      tt
    | __ink_EventBase.Approval aa =>
      let _ :=
        __codec_dest_edqy.["push_byte"] (cast 1 Root.core.primitive.u8) in
      let _ := Root.scale.Encode.encode_to aa __codec_dest_edqy in
      tt
    | _ => tt
    end.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for___ink_EventBase.

Module Impl_Root_scale_EncodeLike_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for___ink_EventBase.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    match
      match
        LangItem
          (__codec_input_edqy.["read_byte"].["map_err"]
            (fun e =>
              e.["chain"]
                "Could not decode `__ink_EventBase`, failed to read variant byte"))
      with
      | Break {| Break.0 := residual; |} => Return (LangItem residual)
      | Continue {| Continue.0 := val; |} => val
      end
    with
    | __codec_x_edqy =>
      Root.core.result.Result.Ok
        (__ink_EventBase.Transfer
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `__ink_EventBase::Transfer.0`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end)
    | __codec_x_edqy =>
      Root.core.result.Result.Ok
        (__ink_EventBase.Approval
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `__ink_EventBase::Approval.0`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end)
    | _ =>
      Root.core.result.Result.Err
        (Root.core.convert.Into.into
          "Could not decode `__ink_EventBase`, variant doesn't exist")
    end.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for___ink_EventBase.

Definition _ : unit := run (tt).

Module Impl_Root_ink_reflect_ContractEventBase_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := __ink_EventBase.
  
  Global Instance I : Root.ink.reflect.ContractEventBase.Trait Self := {
  }.
End Impl_Root_ink_reflect_ContractEventBase_for_Erc20.

Definition _ : unit := run (tt).

Module Impl_From_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Definition from (event : Transfer) : Self := Self::["Transfer"] event.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : From.Trait Self Transfer := {
    From.from := from;
  }.
End Impl_From_for___ink_EventBase.

Definition _ : unit := run (tt).

Module Impl_From_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Definition from (event : Approval) : Self := Self::["Approval"] event.
  
  Global Instance AssociatedFunction_from :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : From.Trait Self Approval := {
    From.from := from;
  }.
End Impl_From_for___ink_EventBase.

Definition _ : unit := run (tt).

Module __ink_UndefinedAmountOfTopics.
  Inductive t : Set :=
  .
End __ink_UndefinedAmountOfTopics.
Definition __ink_UndefinedAmountOfTopics := __ink_UndefinedAmountOfTopics.t.

Module
    Impl_Root_ink_env_topics_EventTopicsAmount_for___ink_UndefinedAmountOfTopics.
  Definition Self := __ink_UndefinedAmountOfTopics.
  
  Definition AMOUNT := 0.
  
  Global Instance AssociatedFunction_AMOUNT :
    Notation.DoubleColon Self "AMOUNT" := {
    Notation.double_colon := AMOUNT;
  }.
  
  Global Instance I : Root.ink.env.topics.EventTopicsAmount.Trait Self := {
    Root.ink.env.topics.EventTopicsAmount.AMOUNT := AMOUNT;
  }.
End
  Impl_Root_ink_env_topics_EventTopicsAmount_for___ink_UndefinedAmountOfTopics.

Module Impl_Root_ink_env_Topics_for___ink_EventBase.
  Definition Self := __ink_EventBase.
  
  Definition RemainingTopics : Set := __ink_UndefinedAmountOfTopics.
  
  Definition topics
      (self : ref Self)
      (builder
        :
        Root.ink.env.topics.TopicsBuilder Root.ink.env.topics.state.Uninit E B)
      : Root.ink.env.topics.TopicsBuilderBackend.Output :=
    match self with
    | ImplSelf.Transfer.Build_t event =>
      Root.ink.env.Topics.topics event builder
    | ImplSelf.Approval.Build_t event =>
      Root.ink.env.Topics.topics event builder
    | _ =>
      _crate.panicking.panic_fmt
        (format_arguments::["new_const"] (addr_of [ "Event does not exist!" ]))
    end.
  
  Global Instance Method_topics : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : Root.ink.env.Topics.Trait Self := {
    Root.ink.env.Topics.topics := topics;
  }.
End Impl_Root_ink_env_Topics_for___ink_EventBase.

Module Impl_Root_ink_codegen_EventLenTopics_for_Transfer.
  Definition Self := Transfer.
  
  Definition LenTopics : Set := Root.ink.codegen.EventTopics.
  
  Global Instance I : Root.ink.codegen.EventLenTopics.Trait Self := {
  }.
End Impl_Root_ink_codegen_EventLenTopics_for_Transfer.

Definition _ : unit := run ((Root.ink.codegen.utils.consume_type tt)).

Module Impl_Root_ink_codegen_EventLenTopics_for_Approval.
  Definition Self := Approval.
  
  Definition LenTopics : Set := Root.ink.codegen.EventTopics.
  
  Global Instance I : Root.ink.codegen.EventLenTopics.Trait Self := {
  }.
End Impl_Root_ink_codegen_EventLenTopics_for_Approval.

Definition _ : unit := run ((Root.ink.codegen.utils.consume_type tt)).

Module Transfer.
  Record t : Set := {
    from : core.option.Option AccountId;
    to : core.option.Option AccountId;
    value : Balance;
  }.
  
  Global Instance Get_from : Notation.Dot "from" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_to : Notation.Dot "to" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Transfer.
Definition Transfer : Set := Transfer.t.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for_Transfer.
  Definition Self := Transfer.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    let _ :=
      Root.scale.Encode.encode_to (addr_of self.["from"]) __codec_dest_edqy in
    let _ :=
      Root.scale.Encode.encode_to (addr_of self.["to"]) __codec_dest_edqy in
    let _ :=
      Root.scale.Encode.encode_to (addr_of self.["value"]) __codec_dest_edqy in
    tt.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for_Transfer.

Module Impl_Root_scale_EncodeLike_for_Transfer.
  Definition Self := Transfer.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for_Transfer.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for_Transfer.
  Definition Self := Transfer.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    Root.core.result.Result.Ok
      {|
        Transfer.from :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Transfer::from`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
        Transfer.to :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Transfer::to`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
        Transfer.value :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Transfer::value`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
      |}.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for_Transfer.

Module Approval.
  Record t : Set := {
    owner : AccountId;
    spender : AccountId;
    value : Balance;
  }.
  
  Global Instance Get_owner : Notation.Dot "owner" := {
    Notation.dot '(Build_t x0 _ _) := x0;
  }.
  Global Instance Get_spender : Notation.Dot "spender" := {
    Notation.dot '(Build_t _ x1 _) := x1;
  }.
  Global Instance Get_value : Notation.Dot "value" := {
    Notation.dot '(Build_t _ _ x2) := x2;
  }.
End Approval.
Definition Approval : Set := Approval.t.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for_Approval.
  Definition Self := Approval.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    let _ :=
      Root.scale.Encode.encode_to (addr_of self.["owner"]) __codec_dest_edqy in
    let _ :=
      Root.scale.Encode.encode_to
        (addr_of self.["spender"])
        __codec_dest_edqy in
    let _ :=
      Root.scale.Encode.encode_to (addr_of self.["value"]) __codec_dest_edqy in
    tt.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for_Approval.

Module Impl_Root_scale_EncodeLike_for_Approval.
  Definition Self := Approval.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for_Approval.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for_Approval.
  Definition Self := Approval.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    Root.core.result.Result.Ok
      {|
        Approval.owner :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Approval::owner`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
        Approval.spender :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Approval::spender`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
        Approval.value :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Approval::value`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
      |}.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for_Approval.

Definition _ : unit := run (tt).

Module Impl_Root_ink_env_Topics_for_Transfer.
  Definition Self := Transfer.
  
  Definition RemainingTopics : Set :=
    list Root.ink.env.topics.state.HasRemainingTopics.
  
  Definition topics
      (self : ref Self)
      (builder
        :
        Root.ink.env.topics.TopicsBuilder Root.ink.env.topics.state.Uninit E B)
      : Root.ink.env.topics.TopicsBuilderBackend.Output :=
    (((builder.["build"].["push_topic"]
            (addr_of
              {|
                Root.ink.env.topics.PrefixedValue.value :=
                  [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114];
                Root.ink.env.topics.PrefixedValue.prefix := [];
              |})).["push_topic"]
          (addr_of
            {|
              Root.ink.env.topics.PrefixedValue.value := addr_of self.["from"];
              Root.ink.env.topics.PrefixedValue.prefix :=
                [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114, 58, 58, 102, 114, 111, 109];
            |})).["push_topic"]
        (addr_of
          {|
            Root.ink.env.topics.PrefixedValue.value := addr_of self.["to"];
            Root.ink.env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 84, 114, 97, 110, 115, 102, 101, 114, 58, 58, 116, 111];
          |})).["finish"].
  
  Global Instance Method_topics : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : Root.ink.env.Topics.Trait Self := {
    Root.ink.env.Topics.topics := topics;
  }.
End Impl_Root_ink_env_Topics_for_Transfer.

Definition _ : unit := run (tt).

Module Impl_Root_ink_env_Topics_for_Approval.
  Definition Self := Approval.
  
  Definition RemainingTopics : Set :=
    list Root.ink.env.topics.state.HasRemainingTopics.
  
  Definition topics
      (self : ref Self)
      (builder
        :
        Root.ink.env.topics.TopicsBuilder Root.ink.env.topics.state.Uninit E B)
      : Root.ink.env.topics.TopicsBuilderBackend.Output :=
    (((builder.["build"].["push_topic"]
            (addr_of
              {|
                Root.ink.env.topics.PrefixedValue.value :=
                  [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108];
                Root.ink.env.topics.PrefixedValue.prefix := [];
              |})).["push_topic"]
          (addr_of
            {|
              Root.ink.env.topics.PrefixedValue.value := addr_of self.["owner"];
              Root.ink.env.topics.PrefixedValue.prefix :=
                [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108, 58, 58, 111, 119, 110, 101, 114];
            |})).["push_topic"]
        (addr_of
          {|
            Root.ink.env.topics.PrefixedValue.value := addr_of self.["spender"];
            Root.ink.env.topics.PrefixedValue.prefix :=
              [69, 114, 99, 50, 48, 58, 58, 65, 112, 112, 114, 111, 118, 97, 108, 58, 58, 115, 112, 101, 110, 100, 101, 114];
          |})).["finish"].
  
  Global Instance Method_topics : Notation.Dot "topics" := {
    Notation.dot := topics;
  }.
  
  Global Instance I : Root.ink.env.Topics.Trait Self := {
    Root.ink.env.Topics.topics := topics;
  }.
End Impl_Root_ink_env_Topics_for_Approval.

Module Impl_Root_ink_reflect_DispatchableConstructorInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := Balance.
  
  Definition Output : Set := Self.
  
  Definition Storage : Set := Erc20.
  
  Definition Error : Set := Root.ink.reflect.ConstructorOutput.Error.
  
  Definition IS_RESULT := Root.ink.reflect.ConstructorOutput.IS_RESULT.
  
  Global Instance AssociatedFunction_IS_RESULT :
    Notation.DoubleColon Self "IS_RESULT" := {
    Notation.double_colon := IS_RESULT;
  }.
  
  Definition CALLABLE := fun __ink_binding_0 => Erc20::["new"] __ink_binding_0.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition SELECTOR := [ 155; 174; 157; 94 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition LABEL := "new".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableConstructorInfo.Trait Self :=
    {
    Root.ink.reflect.DispatchableConstructorInfo.IS_RESULT := IS_RESULT;
    Root.ink.reflect.DispatchableConstructorInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableConstructorInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableConstructorInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableConstructorInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableConstructorInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := unit.
  
  Definition Output : Set := Balance.
  
  Definition Storage : Set := Erc20.
  
  Definition CALLABLE := fun storage _ => Erc20::["total_supply"] storage.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 219; 99; 117; 168 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := false.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "total_supply".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := AccountId.
  
  Definition Output : Set := Balance.
  
  Definition Storage : Set := Erc20.
  
  Definition
    CALLABLE := fun storage __ink_binding_0 =>
      Erc20::["balance_of"] storage __ink_binding_0.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 15; 117; 90; 86 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := false.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "balance_of".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := AccountId * AccountId.
  
  Definition Output : Set := Balance.
  
  Definition Storage : Set := Erc20.
  
  Definition
    CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
      Erc20::["allowance"] storage __ink_binding_0 __ink_binding_1.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 106; 0; 22; 94 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := false.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "allowance".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := AccountId * Balance.
  
  Definition Output : Set := Result unit.
  
  Definition Storage : Set := Erc20.
  
  Definition
    CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
      Erc20::["transfer"] storage __ink_binding_0 __ink_binding_1.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 132; 161; 93; 161 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := true.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "transfer".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := AccountId * Balance.
  
  Definition Output : Set := Result unit.
  
  Definition Storage : Set := Erc20.
  
  Definition
    CALLABLE := fun storage (__ink_binding_0, __ink_binding_1) =>
      Erc20::["approve"] storage __ink_binding_0 __ink_binding_1.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 104; 18; 102; 160 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := true.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "approve".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Module Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.
  Definition Self := Erc20.
  
  Definition Input : Set := AccountId * AccountId * Balance.
  
  Definition Output : Set := Result unit.
  
  Definition Storage : Set := Erc20.
  
  Definition
    CALLABLE := fun
        storage
        (__ink_binding_0, __ink_binding_1, __ink_binding_2) =>
      Erc20::["transfer_from"]
        storage
        __ink_binding_0
        __ink_binding_1
        __ink_binding_2.
  
  Global Instance AssociatedFunction_CALLABLE :
    Notation.DoubleColon Self "CALLABLE" := {
    Notation.double_colon := CALLABLE;
  }.
  
  Definition SELECTOR := [ 11; 57; 111; 24 ].
  
  Global Instance AssociatedFunction_SELECTOR :
    Notation.DoubleColon Self "SELECTOR" := {
    Notation.double_colon := SELECTOR;
  }.
  
  Definition PAYABLE := false.
  
  Global Instance AssociatedFunction_PAYABLE :
    Notation.DoubleColon Self "PAYABLE" := {
    Notation.double_colon := PAYABLE;
  }.
  
  Definition MUTATES := true.
  
  Global Instance AssociatedFunction_MUTATES :
    Notation.DoubleColon Self "MUTATES" := {
    Notation.double_colon := MUTATES;
  }.
  
  Definition LABEL := "transfer_from".
  
  Global Instance AssociatedFunction_LABEL :
    Notation.DoubleColon Self "LABEL" := {
    Notation.double_colon := LABEL;
  }.
  
  Global Instance I : Root.ink.reflect.DispatchableMessageInfo.Trait Self := {
    Root.ink.reflect.DispatchableMessageInfo.CALLABLE := CALLABLE;
    Root.ink.reflect.DispatchableMessageInfo.MUTATES := MUTATES;
    Root.ink.reflect.DispatchableMessageInfo.PAYABLE := PAYABLE;
    Root.ink.reflect.DispatchableMessageInfo.SELECTOR := SELECTOR;
    Root.ink.reflect.DispatchableMessageInfo.LABEL := LABEL;
  }.
End Impl_Root_ink_reflect_DispatchableMessageInfo_for_Erc20.

Definition _ : unit := run (tt).

Module __ink_ConstructorDecoder.
  Inductive t : Set :=
  | Constructor0 (_ : Root.ink.reflect.DispatchableConstructorInfo.Input).
End __ink_ConstructorDecoder.
Definition __ink_ConstructorDecoder := __ink_ConstructorDecoder.t.

Module Impl_Root_ink_reflect_DecodeDispatch_for___ink_ConstructorDecoder.
  Definition Self := __ink_ConstructorDecoder.
  
  Definition decode_dispatch
      (input : mut_ref I)
      : Root.core.result.Result Self Root.ink.reflect.DispatchError :=
    match
      match
        LangItem
          ((Root.scale.Decode.decode input).["map_err"]
            (fun _ => Root.ink.reflect.DispatchError.InvalidSelector))
      with
      | Break {| Break.0 := residual; |} => Return (LangItem residual)
      | Continue {| Continue.0 := val; |} => val
      end
    with
    | CONSTRUCTOR_0 =>
      Root.core.result.Result.Ok
        (Self::["Constructor0"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | _invalid =>
      Root.core.result.Result.Err Root.ink.reflect.DispatchError.UnknownSelector
    end.
  
  Global Instance AssociatedFunction_decode_dispatch :
    Notation.DoubleColon Self "decode_dispatch" := {
    Notation.double_colon := decode_dispatch;
  }.
  
  Global Instance I : Root.ink.reflect.DecodeDispatch.Trait Self := {
    Root.ink.reflect.DecodeDispatch.decode_dispatch := decode_dispatch;
  }.
End Impl_Root_ink_reflect_DecodeDispatch_for___ink_ConstructorDecoder.

Definition CONSTRUCTOR_0 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableConstructorInfo.SELECTOR).

Module Impl_Root_scale_Decode_for___ink_ConstructorDecoder.
  Definition Self := __ink_ConstructorDecoder.
  
  Definition decode
      (input : mut_ref I)
      : Root.core.result.Result Self Root.scale.Error :=
    (Root.ink.reflect.DecodeDispatch.decode_dispatch input).["map_err"]
      Root.core.convert.Into.into.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for___ink_ConstructorDecoder.

Module Impl_Root_ink_reflect_ExecuteDispatchable_for___ink_ConstructorDecoder.
  Definition Self := __ink_ConstructorDecoder.
  
  Definition execute_dispatchable
      (self : Self)
      : Root.core.result.Result unit Root.ink.reflect.DispatchError :=
    match self with
    | ImplSelf.Constructor0.Build_t input =>
      let _ :=
        if
          (false.["or"]
              let constructor_0 := false in
              let constructor_0 :=
                Root.ink.reflect.DispatchableConstructorInfo.PAYABLE in
              constructor_0.["andb"]
            Root.ink.reflect.DispatchableConstructorInfo.PAYABLE.["not"]
          : bool)
        then
          let _ :=
            match LangItem (Root.ink.codegen.deny_payment tt) with
            | Break {| Break.0 := residual; |} => Return (LangItem residual)
            | Continue {| Continue.0 := val; |} => val
            end in
          tt
        else
          tt in
      let result :=
        Root.ink.reflect.DispatchableConstructorInfo.CALLABLE input in
      let output_value :=
        Root.ink.reflect.ConstructorOutputValue::["new"] result in
      let output_result :=
        Root.ink.reflect.ConstructorOutput.as_result (addr_of output_value) in
      let _ :=
        if
          (let_if
          Root.core.result.Result.Ok contract
          :=
          output_result.["as_ref"]
          : bool)
        then
          let _ :=
            Root.ink.env.set_contract_storage
              (addr_of Root.ink.storage.traits.StorageKey.KEY)
              contract in
          tt
        else
          tt in
      let _ :=
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"]
            output_result.["is_err"])
          (addr_of
            (Root.ink.ConstructorResult::["Ok"]
              (output_result.["map"] (fun _ => tt)))) in
      tt
    end.
  
  Global Instance Method_execute_dispatchable :
    Notation.Dot "execute_dispatchable" := {
    Notation.dot := execute_dispatchable;
  }.
  
  Global Instance I : Root.ink.reflect.ExecuteDispatchable.Trait Self := {
    Root.ink.reflect.ExecuteDispatchable.execute_dispatchable
      :=
      execute_dispatchable;
  }.
End Impl_Root_ink_reflect_ExecuteDispatchable_for___ink_ConstructorDecoder.

Module Impl_Root_ink_reflect_ContractConstructorDecoder_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := __ink_ConstructorDecoder.
  
  Global Instance I : Root.ink.reflect.ContractConstructorDecoder.Trait Self :=
    {
  }.
End Impl_Root_ink_reflect_ContractConstructorDecoder_for_Erc20.

Definition _ : unit := run (tt).

Module __ink_MessageDecoder.
  Inductive t : Set :=
  | Message0 (_ : Root.ink.reflect.DispatchableMessageInfo.Input)
  | Message1 (_ : Root.ink.reflect.DispatchableMessageInfo.Input)
  | Message2 (_ : Root.ink.reflect.DispatchableMessageInfo.Input)
  | Message3 (_ : Root.ink.reflect.DispatchableMessageInfo.Input)
  | Message4 (_ : Root.ink.reflect.DispatchableMessageInfo.Input)
  | Message5 (_ : Root.ink.reflect.DispatchableMessageInfo.Input).
End __ink_MessageDecoder.
Definition __ink_MessageDecoder := __ink_MessageDecoder.t.

Module Impl_Root_ink_reflect_DecodeDispatch_for___ink_MessageDecoder.
  Definition Self := __ink_MessageDecoder.
  
  Definition decode_dispatch
      (input : mut_ref I)
      : Root.core.result.Result Self Root.ink.reflect.DispatchError :=
    match
      match
        LangItem
          ((Root.scale.Decode.decode input).["map_err"]
            (fun _ => Root.ink.reflect.DispatchError.InvalidSelector))
      with
      | Break {| Break.0 := residual; |} => Return (LangItem residual)
      | Continue {| Continue.0 := val; |} => val
      end
    with
    | MESSAGE_0 =>
      Root.core.result.Result.Ok
        (Self::["Message0"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | MESSAGE_1 =>
      Root.core.result.Result.Ok
        (Self::["Message1"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | MESSAGE_2 =>
      Root.core.result.Result.Ok
        (Self::["Message2"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | MESSAGE_3 =>
      Root.core.result.Result.Ok
        (Self::["Message3"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | MESSAGE_4 =>
      Root.core.result.Result.Ok
        (Self::["Message4"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | MESSAGE_5 =>
      Root.core.result.Result.Ok
        (Self::["Message5"]
          match
            LangItem
              ((Root.scale.Decode.decode input).["map_err"]
                (fun _ => Root.ink.reflect.DispatchError.InvalidParameters))
          with
          | Break {| Break.0 := residual; |} => Return (LangItem residual)
          | Continue {| Continue.0 := val; |} => val
          end)
    | _invalid =>
      Root.core.result.Result.Err Root.ink.reflect.DispatchError.UnknownSelector
    end.
  
  Global Instance AssociatedFunction_decode_dispatch :
    Notation.DoubleColon Self "decode_dispatch" := {
    Notation.double_colon := decode_dispatch;
  }.
  
  Global Instance I : Root.ink.reflect.DecodeDispatch.Trait Self := {
    Root.ink.reflect.DecodeDispatch.decode_dispatch := decode_dispatch;
  }.
End Impl_Root_ink_reflect_DecodeDispatch_for___ink_MessageDecoder.

Definition MESSAGE_0 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_1 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_2 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_3 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_4 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Definition MESSAGE_5 : list Root.core.primitive.u8 :=
  run (Root.ink.reflect.DispatchableMessageInfo.SELECTOR).

Module Impl_Root_scale_Decode_for___ink_MessageDecoder.
  Definition Self := __ink_MessageDecoder.
  
  Definition decode
      (input : mut_ref I)
      : Root.core.result.Result Self Root.scale.Error :=
    (Root.ink.reflect.DecodeDispatch.decode_dispatch input).["map_err"]
      Root.core.convert.Into.into.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for___ink_MessageDecoder.

Definition push_contract
    (contract : Root.core.mem.ManuallyDrop Erc20)
    (mutates : bool)
    : unit :=
  if (mutates : bool) then
    let _ :=
      Root.ink.env.set_contract_storage
        (addr_of Root.ink.storage.traits.StorageKey.KEY)
        (addr_of contract) in
    tt
  else
    tt.

Module Impl_Root_ink_reflect_ExecuteDispatchable_for___ink_MessageDecoder.
  Definition Self := __ink_MessageDecoder.
  
  Definition execute_dispatchable
      (self : Self)
      : Root.core.result.Result unit Root.ink.reflect.DispatchError :=
    let key := Root.ink.storage.traits.StorageKey.KEY in
    let contract :=
      Root.core.mem.ManuallyDrop::["new"]
        match Root.ink.env.get_contract_storage (addr_of key) with
        | Root.core.result.Result.Ok Root.core.option.core.option.Option.Some value => value
        | Root.core.result.Result.Ok Root.core.option.core.option.Option.None =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_const"]
              (addr_of [ "storage entry was empty" ]))
        | Root.core.result.Result.Err _ =>
          _crate.panicking.panic_fmt
            (format_arguments::["new_const"]
              (addr_of [ "could not properly decode storage entry" ]))
        end in
    let _ :=
      match self with
      | ImplSelf.Message0.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      | ImplSelf.Message1.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      | ImplSelf.Message2.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      | ImplSelf.Message3.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      | ImplSelf.Message4.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      | ImplSelf.Message5.Build_t input =>
        let _ :=
          if
            ((((((false.["or"]
                          let message_0 := false in
                          let message_0 :=
                            Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                          message_0).["or"]
                        let message_1 := false in
                        let message_1 :=
                          Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                        message_1).["or"]
                      let message_2 := false in
                      let message_2 :=
                        Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                      message_2).["or"]
                    let message_3 := false in
                    let message_3 :=
                      Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                    message_3).["or"]
                  let message_4 := false in
                  let message_4 :=
                    Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                  message_4).["or"]
                let message_5 := false in
                let message_5 :=
                  Root.ink.reflect.DispatchableMessageInfo.PAYABLE in
                message_5.["andb"]
              Root.ink.reflect.DispatchableMessageInfo.PAYABLE.["not"]
            : bool)
          then
            let _ :=
              match LangItem (Root.ink.codegen.deny_payment tt) with
              | Break {| Break.0 := residual; |} => Return (LangItem residual)
              | Continue {| Continue.0 := val; |} => val
              end in
            tt
          else
            tt in
        let result :=
          Root.ink.reflect.DispatchableMessageInfo.CALLABLE
            (addr_of contract)
            input in
        let is_reverted :=
          (_crate.result_info.IsResultType
                Root.ink.reflect.DispatchableMessageInfo.Output)::["VALUE"].["andb"]
            (_crate.result_info.IsResultErr.Build_t
                (addr_of result)).["value"] in
        let _ :=
          if (is_reverted.["not"] : bool) then
            let _ :=
              push_contract
                contract
                Root.ink.reflect.DispatchableMessageInfo.MUTATES in
            tt
          else
            tt in
        Root.ink.env.return_value
          (Root.ink.env.ReturnFlags::["new_with_reverted"] is_reverted)
          (addr_of (Root.ink.MessageResult::["Ok"] result))
      end in
    tt.
  
  Global Instance Method_execute_dispatchable :
    Notation.Dot "execute_dispatchable" := {
    Notation.dot := execute_dispatchable;
  }.
  
  Global Instance I : Root.ink.reflect.ExecuteDispatchable.Trait Self := {
    Root.ink.reflect.ExecuteDispatchable.execute_dispatchable
      :=
      execute_dispatchable;
  }.
End Impl_Root_ink_reflect_ExecuteDispatchable_for___ink_MessageDecoder.

Module Impl_Root_ink_reflect_ContractMessageDecoder_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := __ink_MessageDecoder.
  
  Global Instance I : Root.ink.reflect.ContractMessageDecoder.Trait Self := {
  }.
End Impl_Root_ink_reflect_ContractMessageDecoder_for_Erc20.

Definition _ : unit := run (tt).

Definition _ : Root.ink.codegen.utils.IsSameType Erc20 :=
  run (((Root.ink.codegen.utils.IsSameType Erc20)::["new"] tt)).

Module ImplErc20.
  Definition Self := Erc20.
  
  Definition new (total_supply : Balance) : Self :=
    let balances := Mapping::["default"] tt in
    let caller := (Self::["env"] tt).["caller"] in
    let _ := balances.["insert"] caller (addr_of total_supply) in
    let _ :=
      (Self::["env"] tt).["emit_event"]
        {|
          Transfer.from := None;
          Transfer.to := Some caller;
          Transfer.value := total_supply;
        |} in
    {|
      Self.total_supply := total_supply;
      Self.balances := balances;
      Self.allowances := Default.default tt;
    |}.
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition total_supply (self : ref Self) : Balance := self.["total_supply"].
  
  Global Instance Method_total_supply : Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition balance_of (self : ref Self) (owner : AccountId) : Balance :=
    self.["balance_of_impl"] (addr_of owner).
  
  Global Instance Method_balance_of : Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition allowance
      (self : ref Self)
      (owner : AccountId)
      (spender : AccountId)
      : Balance :=
    self.["allowance_impl"] (addr_of owner) (addr_of spender).
  
  Global Instance Method_allowance : Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition transfer
      (self : mut_ref Self)
      (to : AccountId)
      (value : Balance)
      : Result unit :=
    let from := self.["env"].["caller"] in
    self.["transfer_from_to"] (addr_of from) (addr_of to) value.
  
  Global Instance Method_transfer : Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition approve
      (self : mut_ref Self)
      (spender : AccountId)
      (value : Balance)
      : Result unit :=
    let owner := self.["env"].["caller"] in
    let _ :=
      self.["allowances"].["insert"]
        (addr_of owner, addr_of spender)
        (addr_of value) in
    let _ :=
      self.["env"].["emit_event"]
        {|
          Approval.owner := owner;
          Approval.spender := spender;
          Approval.value := value;
        |} in
    Ok tt.
  
  Global Instance Method_approve : Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition transfer_from
      (self : mut_ref Self)
      (from : AccountId)
      (to : AccountId)
      (value : Balance)
      : Result unit :=
    let caller := self.["env"].["caller"] in
    let allowance := self.["allowance_impl"] (addr_of from) (addr_of caller) in
    let _ :=
      if (allowance.["lt"] value : bool) then
        Return (Err Error.InsufficientAllowance)
      else
        tt in
    let _ :=
      match
        LangItem (self.["transfer_from_to"] (addr_of from) (addr_of to) value)
      with
      | Break {| Break.0 := residual; |} => Return (LangItem residual)
      | Continue {| Continue.0 := val; |} => val
      end in
    let _ :=
      self.["allowances"].["insert"]
        (addr_of from, addr_of caller)
        (addr_of (allowance.["sub"] value)) in
    Ok tt.
  
  Global Instance Method_transfer_from : Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
  
  Definition balance_of_impl
      (self : ref Self)
      (owner : ref AccountId)
      : Balance :=
    (self.["balances"].["get"] owner).["unwrap_or_default"].
  
  Global Instance Method_balance_of_impl : Notation.Dot "balance_of_impl" := {
    Notation.dot := balance_of_impl;
  }.
  
  Definition allowance_impl
      (self : ref Self)
      (owner : ref AccountId)
      (spender : ref AccountId)
      : Balance :=
    (self.["allowances"].["get"] (owner, spender)).["unwrap_or_default"].
  
  Global Instance Method_allowance_impl : Notation.Dot "allowance_impl" := {
    Notation.dot := allowance_impl;
  }.
  
  Definition transfer_from_to
      (self : mut_ref Self)
      (from : ref AccountId)
      (to : ref AccountId)
      (value : Balance)
      : Result unit :=
    let from_balance := self.["balance_of_impl"] from in
    let _ :=
      if (from_balance.["lt"] value : bool) then
        Return (Err Error.InsufficientBalance)
      else
        tt in
    let _ :=
      self.["balances"].["insert"]
        from
        (addr_of (from_balance.["sub"] value)) in
    let to_balance := self.["balance_of_impl"] to in
    let _ :=
      self.["balances"].["insert"] to (addr_of (to_balance.["add"] value)) in
    let _ :=
      self.["env"].["emit_event"]
        {|
          Transfer.from := Some from.["deref"];
          Transfer.to := Some to.["deref"];
          Transfer.value := value;
        |} in
    Ok tt.
  
  Global Instance Method_transfer_from_to : Notation.Dot "transfer_from_to" := {
    Notation.dot := transfer_from_to;
  }.
End ImplErc20.

Definition _ : unit :=
  run
    (let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    let _ := Root.ink.codegen.utils.consume_type tt in
    tt).

Definition _ : unit := run (tt).

Module CallBuilder.
  Record t : Set := {
    account_id : AccountId;
  }.
  
  Global Instance Get_account_id : Notation.Dot "account_id" := {
    Notation.dot '(Build_t x0) := x0;
  }.
End CallBuilder.
Definition CallBuilder : Set := CallBuilder.t.

Module Impl__crate_fmt_Debug_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : _crate.fmt.Result :=
    _crate.fmt.Formatter::["debug_struct_field1_finish"]
      f
      "CallBuilder"
      "account_id"
      (addr_of (addr_of self.["account_id"])).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_CallBuilder.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    Root.scale.Encode.encode_to
      (addr_of (addr_of self.["account_id"]))
      __codec_dest_edqy.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Definition encode
      (self : ref Self)
      : Root.scale.alloc.vec.Vec Root.core.primitive.u8 :=
    Root.scale.Encode.encode (addr_of (addr_of self.["account_id"])).
  
  Global Instance Method_encode : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Definition using_encoded (self : ref Self) (f : F) : R :=
    Root.scale.Encode.using_encoded (addr_of (addr_of self.["account_id"])) f.
  
  Global Instance Method_using_encoded : Notation.Dot "using_encoded" := {
    Notation.dot := using_encoded;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for_CallBuilder.

Module Impl_Root_scale_EncodeLike_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for_CallBuilder.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    Root.core.result.Result.Ok
      {|
        CallBuilder.account_id :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `CallBuilder::account_id`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
      |}.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for_CallBuilder.

Module Impl__crate_hash_Hash_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition hash (self : ref Self) (state : mut_ref __H) : unit :=
    _crate.hash.Hash.hash (addr_of self.["account_id"]) state.
  
  Global Instance Method_hash : Notation.Dot "hash" := {
    Notation.dot := hash;
  }.
  
  Global Instance I : _crate.hash.Hash.Trait Self := {
    _crate.hash.Hash.hash := hash;
  }.
End Impl__crate_hash_Hash_for_CallBuilder.

Module Impl__crate_marker_StructuralPartialEq_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
    _crate.marker.StructuralPartialEq.Build_Class _.
End Impl__crate_marker_StructuralPartialEq_for_CallBuilder.

Module Impl__crate_cmp_PartialEq_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition eq (self : ref Self) (other : ref CallBuilder) : bool :=
    self.["account_id"].["eq"] other.["account_id"].
  
  Global Instance Method_eq : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : _crate.cmp.PartialEq.Trait Self := {
    _crate.cmp.PartialEq.eq := eq;
  }.
End Impl__crate_cmp_PartialEq_for_CallBuilder.

Module Impl__crate_marker_StructuralEq_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Global Instance I : _crate.marker.StructuralEq.Trait Self :=
    _crate.marker.StructuralEq.Build_Class _.
End Impl__crate_marker_StructuralEq_for_CallBuilder.

Module Impl__crate_cmp_Eq_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition assert_receiver_is_total_eq (self : ref Self) : unit :=
    let _ := tt in
    tt.
  
  Global Instance Method_assert_receiver_is_total_eq :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : _crate.cmp.Eq.Trait Self := {
  }.
End Impl__crate_cmp_Eq_for_CallBuilder.

Module Impl__crate_clone_Clone_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition clone (self : ref Self) : CallBuilder :=
    {|
      CallBuilder.account_id :=
        _crate.clone.Clone.clone (addr_of self.["account_id"]);
    |}.
  
  Global Instance Method_clone : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : _crate.clone.Clone.Trait Self := {
    _crate.clone.Clone.clone := clone;
  }.
End Impl__crate_clone_Clone_for_CallBuilder.

Definition _ : unit := run (tt).

Module Impl_Root_scale_info_TypeInfo_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition Identity : Set := Self.
  
  Definition type_info (_ : unit) : Root.scale_info.Type :=
    ((((Root.scale_info.Type::["builder"] tt).["path"]
            (Root.scale_info.Path::["new"]
              "CallBuilder"
              "erc20::erc20")).["type_params"]
          (_crate.vec.Vec::["new"] tt)).["docs"]
        (addr_of
          [
            "The ink! smart contract's call builder.";
            "";
            "Implements the underlying on-chain calling of the ink! smart contract";
            "messages and trait implementations in a type safe way."
          ])).["composite"]
      ((Root.scale_info.build.Fields::["named"] tt).["field"]
        (fun f => (f.["ty"].["name"] "account_id").["type_name"] "AccountId")).
  
  Global Instance AssociatedFunction_type_info :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : Root.scale_info.TypeInfo.Trait Self := {
    Root.scale_info.TypeInfo.type_info := type_info;
  }.
End Impl_Root_scale_info_TypeInfo_for_CallBuilder.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_StorageLayout_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition layout
      (__key : ref Root.ink.primitives.Key)
      : Root.ink.metadata.layout.Layout :=
    Root.ink.metadata.layout.Layout.Struct
      (Root.ink.metadata.layout.StructLayout::["new"]
        "CallBuilder"
        [
          Root.ink.metadata.layout.FieldLayout::["new"]
            "account_id"
            (Root.ink.storage.traits.StorageLayout.layout __key)
        ]).
  
  Global Instance AssociatedFunction_layout :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : Root.ink.storage.traits.StorageLayout.Trait Self := {
    Root.ink.storage.traits.StorageLayout.layout := layout;
  }.
End Impl_Root_ink_storage_traits_StorageLayout_for_CallBuilder.

Definition _ : unit := run (tt).

Module Impl_Root_ink_codegen_ContractCallBuilder_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := CallBuilder.
  
  Global Instance I : Root.ink.codegen.ContractCallBuilder.Trait Self := {
  }.
End Impl_Root_ink_codegen_ContractCallBuilder_for_Erc20.

Module Impl_Root_ink_env_ContractEnv_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition Env : Set := Root.ink.env.ContractEnv.Env.
  
  Global Instance I : Root.ink.env.ContractEnv.Trait Self := {
  }.
End Impl_Root_ink_env_ContractEnv_for_CallBuilder.

Module Impl_Root_ink_env_call_FromAccountId_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition from_account_id (account_id : AccountId) : Self :=
    {| Self.account_id := account_id; |}.
  
  Global Instance AssociatedFunction_from_account_id :
    Notation.DoubleColon Self "from_account_id" := {
    Notation.double_colon := from_account_id;
  }.
  
  Global Instance I : Root.ink.env.call.FromAccountId.Trait Self Environment :=
    {
    Root.ink.env.call.FromAccountId.from_account_id := from_account_id;
  }.
End Impl_Root_ink_env_call_FromAccountId_for_CallBuilder.

Module Impl_Root_ink_ToAccountId_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition to_account_id (self : ref Self) : AccountId :=
    Root.core.clone.Clone.clone (addr_of self.["account_id"]).
  
  Global Instance Method_to_account_id : Notation.Dot "to_account_id" := {
    Notation.dot := to_account_id;
  }.
  
  Global Instance I : Root.ink.ToAccountId.Trait Self Environment := {
    Root.ink.ToAccountId.to_account_id := to_account_id;
  }.
End Impl_Root_ink_ToAccountId_for_CallBuilder.

Module Impl_Root_core_convert_AsRef_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition as_ref (self : ref Self) : ref AccountId :=
    addr_of self.["account_id"].
  
  Global Instance Method_as_ref : Notation.Dot "as_ref" := {
    Notation.dot := as_ref;
  }.
  
  Global Instance I : Root.core.convert.AsRef.Trait Self AccountId := {
    Root.core.convert.AsRef.as_ref := as_ref;
  }.
End Impl_Root_core_convert_AsRef_for_CallBuilder.

Module Impl_Root_core_convert_AsMut_for_CallBuilder.
  Definition Self := CallBuilder.
  
  Definition as_mut (self : mut_ref Self) : mut_ref AccountId :=
    addr_of self.["account_id"].
  
  Global Instance Method_as_mut : Notation.Dot "as_mut" := {
    Notation.dot := as_mut;
  }.
  
  Global Instance I : Root.core.convert.AsMut.Trait Self AccountId := {
    Root.core.convert.AsMut.as_mut := as_mut;
  }.
End Impl_Root_core_convert_AsMut_for_CallBuilder.

Module ImplCallBuilder.
  Definition Self := CallBuilder.
  
  Definition total_supply
      (self : ref Self)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              Root.ink.env.call.utils.EmptyArgumentList))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType Balance)) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        (Root.ink.env.call.ExecutionInput::["new"]
          (Root.ink.env.call.Selector::["new"]
            [ 219; 99; 117; 168 ]))).["returns"].
  
  Global Instance Method_total_supply : Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition balance_of
      (self : ref Self)
      (__ink_binding_0 : AccountId)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument AccountId)
                Root.ink.env.call.utils.EmptyArgumentList)))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType Balance)) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        ((Root.ink.env.call.ExecutionInput::["new"]
            (Root.ink.env.call.Selector::["new"]
              [ 15; 117; 90; 86 ])).["push_arg"]
          __ink_binding_0)).["returns"].
  
  Global Instance Method_balance_of : Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition allowance
      (self : ref Self)
      (__ink_binding_0 : AccountId)
      (__ink_binding_1 : AccountId)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument AccountId)
                (Root.ink.env.call.utils.ArgumentList
                  (Root.ink.env.call.utils.Argument AccountId)
                  Root.ink.env.call.utils.EmptyArgumentList))))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType Balance)) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        (((Root.ink.env.call.ExecutionInput::["new"]
              (Root.ink.env.call.Selector::["new"]
                [ 106; 0; 22; 94 ])).["push_arg"]
            __ink_binding_0).["push_arg"]
          __ink_binding_1)).["returns"].
  
  Global Instance Method_allowance : Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition transfer
      (self : mut_ref Self)
      (__ink_binding_0 : AccountId)
      (__ink_binding_1 : Balance)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument Balance)
                (Root.ink.env.call.utils.ArgumentList
                  (Root.ink.env.call.utils.Argument AccountId)
                  Root.ink.env.call.utils.EmptyArgumentList))))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType (Result unit))) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        (((Root.ink.env.call.ExecutionInput::["new"]
              (Root.ink.env.call.Selector::["new"]
                [ 132; 161; 93; 161 ])).["push_arg"]
            __ink_binding_0).["push_arg"]
          __ink_binding_1)).["returns"].
  
  Global Instance Method_transfer : Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition approve
      (self : mut_ref Self)
      (__ink_binding_0 : AccountId)
      (__ink_binding_1 : Balance)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument Balance)
                (Root.ink.env.call.utils.ArgumentList
                  (Root.ink.env.call.utils.Argument AccountId)
                  Root.ink.env.call.utils.EmptyArgumentList))))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType (Result unit))) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        (((Root.ink.env.call.ExecutionInput::["new"]
              (Root.ink.env.call.Selector::["new"]
                [ 104; 18; 102; 160 ])).["push_arg"]
            __ink_binding_0).["push_arg"]
          __ink_binding_1)).["returns"].
  
  Global Instance Method_approve : Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition transfer_from
      (self : mut_ref Self)
      (__ink_binding_0 : AccountId)
      (__ink_binding_1 : AccountId)
      (__ink_binding_2 : Balance)
      :
        Root.ink.env.call.CallBuilder
          Environment
          (Root.ink.env.call.utils.Set (Root.ink.env.call.Call Environment))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument Balance)
                (Root.ink.env.call.utils.ArgumentList
                  (Root.ink.env.call.utils.Argument AccountId)
                  (Root.ink.env.call.utils.ArgumentList
                    (Root.ink.env.call.utils.Argument AccountId)
                    Root.ink.env.call.utils.EmptyArgumentList)))))
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType (Result unit))) :=
    (((Root.ink.env.call.build_call tt).["call"]
          (Root.ink.ToAccountId.to_account_id self)).["exec_input"]
        ((((Root.ink.env.call.ExecutionInput::["new"]
                (Root.ink.env.call.Selector::["new"]
                  [ 11; 57; 111; 24 ])).["push_arg"]
              __ink_binding_0).["push_arg"]
            __ink_binding_1).["push_arg"]
          __ink_binding_2)).["returns"].
  
  Global Instance Method_transfer_from : Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
End ImplCallBuilder.

Module Erc20Ref.
  Record t : Set := {
    inner : Root.ink.codegen.ContractCallBuilder.Type;
  }.
  
  Global Instance Get_inner : Notation.Dot "inner" := {
    Notation.dot '(Build_t x0) := x0;
  }.
End Erc20Ref.
Definition Erc20Ref : Set := Erc20Ref.t.

Module Impl__crate_fmt_Debug_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : _crate.fmt.Result :=
    _crate.fmt.Formatter::["debug_struct_field1_finish"]
      f
      "Erc20Ref"
      "inner"
      (addr_of (addr_of self.["inner"])).
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_Erc20Ref.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    Root.scale.Encode.encode_to
      (addr_of (addr_of self.["inner"]))
      __codec_dest_edqy.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Definition encode
      (self : ref Self)
      : Root.scale.alloc.vec.Vec Root.core.primitive.u8 :=
    Root.scale.Encode.encode (addr_of (addr_of self.["inner"])).
  
  Global Instance Method_encode : Notation.Dot "encode" := {
    Notation.dot := encode;
  }.
  
  Definition using_encoded (self : ref Self) (f : F) : R :=
    Root.scale.Encode.using_encoded (addr_of (addr_of self.["inner"])) f.
  
  Global Instance Method_using_encoded : Notation.Dot "using_encoded" := {
    Notation.dot := using_encoded;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for_Erc20Ref.

Module Impl_Root_scale_EncodeLike_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for_Erc20Ref.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    Root.core.result.Result.Ok
      {|
        Erc20Ref.inner :=
          let __codec_res_edqy := Root.scale.Decode.decode __codec_input_edqy in
          match __codec_res_edqy with
          | Root.core.result.Result.Err e =>
            Return
              (Root.core.result.Result.Err
                (e.["chain"] "Could not decode `Erc20Ref::inner`"))
          | Root.core.result.Result.Ok __codec_res_edqy => __codec_res_edqy
          end;
      |}.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for_Erc20Ref.

Module Impl__crate_hash_Hash_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition hash (self : ref Self) (state : mut_ref __H) : unit :=
    _crate.hash.Hash.hash (addr_of self.["inner"]) state.
  
  Global Instance Method_hash : Notation.Dot "hash" := {
    Notation.dot := hash;
  }.
  
  Global Instance I : _crate.hash.Hash.Trait Self := {
    _crate.hash.Hash.hash := hash;
  }.
End Impl__crate_hash_Hash_for_Erc20Ref.

Module Impl__crate_marker_StructuralPartialEq_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
    _crate.marker.StructuralPartialEq.Build_Class _.
End Impl__crate_marker_StructuralPartialEq_for_Erc20Ref.

Module Impl__crate_cmp_PartialEq_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition eq (self : ref Self) (other : ref Erc20Ref) : bool :=
    self.["inner"].["eq"] other.["inner"].
  
  Global Instance Method_eq : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : _crate.cmp.PartialEq.Trait Self := {
    _crate.cmp.PartialEq.eq := eq;
  }.
End Impl__crate_cmp_PartialEq_for_Erc20Ref.

Module Impl__crate_marker_StructuralEq_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Global Instance I : _crate.marker.StructuralEq.Trait Self :=
    _crate.marker.StructuralEq.Build_Class _.
End Impl__crate_marker_StructuralEq_for_Erc20Ref.

Module Impl__crate_cmp_Eq_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition assert_receiver_is_total_eq (self : ref Self) : unit :=
    let _ := tt in
    tt.
  
  Global Instance Method_assert_receiver_is_total_eq :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : _crate.cmp.Eq.Trait Self := {
  }.
End Impl__crate_cmp_Eq_for_Erc20Ref.

Module Impl__crate_clone_Clone_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition clone (self : ref Self) : Erc20Ref :=
    {| Erc20Ref.inner := _crate.clone.Clone.clone (addr_of self.["inner"]); |}.
  
  Global Instance Method_clone : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : _crate.clone.Clone.Trait Self := {
    _crate.clone.Clone.clone := clone;
  }.
End Impl__crate_clone_Clone_for_Erc20Ref.

Definition _ : unit := run (tt).

Module Impl_Root_scale_info_TypeInfo_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition Identity : Set := Self.
  
  Definition type_info (_ : unit) : Root.scale_info.Type :=
    ((((Root.scale_info.Type::["builder"] tt).["path"]
            (Root.scale_info.Path::["new"]
              "Erc20Ref"
              "erc20::erc20")).["type_params"]
          (_crate.vec.Vec::["new"] tt)).["docs"]
        (addr_of [ "A simple ERC-20 contract." ])).["composite"]
      ((Root.scale_info.build.Fields::["named"] tt).["field"]
        (fun f =>
          (f.["ty"].["name"] "inner").["type_name"]
            "<Erc20 as::ink::codegen::ContractCallBuilder>::Type")).
  
  Global Instance AssociatedFunction_type_info :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : Root.scale_info.TypeInfo.Trait Self := {
    Root.scale_info.TypeInfo.type_info := type_info;
  }.
End Impl_Root_scale_info_TypeInfo_for_Erc20Ref.

Definition _ : unit := run (tt).

Module Impl_Root_ink_storage_traits_StorageLayout_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition layout
      (__key : ref Root.ink.primitives.Key)
      : Root.ink.metadata.layout.Layout :=
    Root.ink.metadata.layout.Layout.Struct
      (Root.ink.metadata.layout.StructLayout::["new"]
        "Erc20Ref"
        [
          Root.ink.metadata.layout.FieldLayout::["new"]
            "inner"
            (Root.ink.storage.traits.StorageLayout.layout __key)
        ]).
  
  Global Instance AssociatedFunction_layout :
    Notation.DoubleColon Self "layout" := {
    Notation.double_colon := layout;
  }.
  
  Global Instance I : Root.ink.storage.traits.StorageLayout.Trait Self := {
    Root.ink.storage.traits.StorageLayout.layout := layout;
  }.
End Impl_Root_ink_storage_traits_StorageLayout_for_Erc20Ref.

Definition _ : unit := run (tt).

Module Impl_Root_ink_env_ContractReference_for_Erc20.
  Definition Self := Erc20.
  
  Definition Type : Set := Erc20Ref.
  
  Global Instance I : Root.ink.env.ContractReference.Trait Self := {
  }.
End Impl_Root_ink_env_ContractReference_for_Erc20.

Module Impl_Root_ink_env_call_ConstructorReturnType_for_Erc20.
  Definition Self := Erc20.
  
  Definition Output : Set := Erc20Ref.
  
  Definition Error : Set := unit.
  
  Definition ok (value : Erc20Ref) : ImplSelf.Output := value.
  
  Global Instance AssociatedFunction_ok : Notation.DoubleColon Self "ok" := {
    Notation.double_colon := ok;
  }.
  
  Global Instance I
      :
      Root.ink.env.call.ConstructorReturnType.Trait
      Self
      Erc20Ref :=
    {
    Root.ink.env.call.ConstructorReturnType.ok := ok;
  }.
End Impl_Root_ink_env_call_ConstructorReturnType_for_Erc20.

Module
    Impl_Root_ink_env_call_ConstructorReturnType_for_Root_core_result_Result_Erc20_E.
  Definition Self := Root.core.result.Result Erc20 E.
  
  Definition IS_RESULT := true.
  
  Global Instance AssociatedFunction_IS_RESULT :
    Notation.DoubleColon Self "IS_RESULT" := {
    Notation.double_colon := IS_RESULT;
  }.
  
  Definition Output : Set := Root.core.result.Result Erc20Ref E.
  
  Definition Error : Set := E.
  
  Definition ok (value : Erc20Ref) : ImplSelf.Output :=
    Root.core.result.Result.Ok value.
  
  Global Instance AssociatedFunction_ok : Notation.DoubleColon Self "ok" := {
    Notation.double_colon := ok;
  }.
  
  Definition err
      (err : ImplSelf.Error)
      : Root.core.option.Option ImplSelf.Output :=
    Root.core.option.Option.Some (Root.core.result.Result.Err err).
  
  Global Instance AssociatedFunction_err : Notation.DoubleColon Self "err" := {
    Notation.double_colon := err;
  }.
  
  Global Instance I
      E
      :
      Root.ink.env.call.ConstructorReturnType.Trait
      Self
      Erc20Ref :=
    {
    Root.ink.env.call.ConstructorReturnType.ok := ok;
  }.
End
  Impl_Root_ink_env_call_ConstructorReturnType_for_Root_core_result_Result_Erc20_E.

Module Impl_Root_ink_env_ContractEnv_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition Env : Set := Root.ink.env.ContractEnv.Env.
  
  Global Instance I : Root.ink.env.ContractEnv.Trait Self := {
  }.
End Impl_Root_ink_env_ContractEnv_for_Erc20Ref.

Module ImplErc20Ref_2.
  Definition Self := Erc20Ref.
  
  Definition new
      (__ink_binding_0 : Balance)
      :
        Root.ink.env.call.CreateBuilder
          Environment
          Self
          (Root.ink.env.call.utils.Unset Hash)
          (Root.ink.env.call.utils.Unset u64)
          (Root.ink.env.call.utils.Unset Balance)
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.ExecutionInput
              (Root.ink.env.call.utils.ArgumentList
                (Root.ink.env.call.utils.Argument Balance)
                Root.ink.env.call.utils.EmptyArgumentList)))
          (Root.ink.env.call.utils.Unset Root.ink.env.call.state.Salt)
          (Root.ink.env.call.utils.Set
            (Root.ink.env.call.utils.ReturnType Self)) :=
    ((Root.ink.env.call.build_create tt).["exec_input"]
        ((Root.ink.env.call.ExecutionInput::["new"]
            (Root.ink.env.call.Selector::["new"]
              [ 155; 174; 157; 94 ])).["push_arg"]
          __ink_binding_0)).["returns"].
  
  Global Instance AssociatedFunction_new : Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition total_supply (self : ref Self) : Balance :=
    self.["try_total_supply"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::total_supply: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_total_supply : Notation.Dot "total_supply" := {
    Notation.dot := total_supply;
  }.
  
  Definition try_total_supply
      (self : ref Self)
      : Root.ink.MessageResult Balance :=
    (Root.ink.codegen.TraitCallBuilder.call
            self).["total_supply"].["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::total_supply: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_total_supply : Notation.Dot "try_total_supply" := {
    Notation.dot := try_total_supply;
  }.
  
  Definition balance_of (self : ref Self) (owner : AccountId) : Balance :=
    (self.["try_balance_of"] owner).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::balance_of: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_balance_of : Notation.Dot "balance_of" := {
    Notation.dot := balance_of;
  }.
  
  Definition try_balance_of
      (self : ref Self)
      (owner : AccountId)
      : Root.ink.MessageResult Balance :=
    ((Root.ink.codegen.TraitCallBuilder.call self).["balance_of"]
          owner).["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::balance_of: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_balance_of : Notation.Dot "try_balance_of" := {
    Notation.dot := try_balance_of;
  }.
  
  Definition allowance
      (self : ref Self)
      (owner : AccountId)
      (spender : AccountId)
      : Balance :=
    (self.["try_allowance"] owner spender).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::allowance: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_allowance : Notation.Dot "allowance" := {
    Notation.dot := allowance;
  }.
  
  Definition try_allowance
      (self : ref Self)
      (owner : AccountId)
      (spender : AccountId)
      : Root.ink.MessageResult Balance :=
    ((Root.ink.codegen.TraitCallBuilder.call self).["allowance"]
          owner
          spender).["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::allowance: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_allowance : Notation.Dot "try_allowance" := {
    Notation.dot := try_allowance;
  }.
  
  Definition transfer
      (self : mut_ref Self)
      (to : AccountId)
      (value : Balance)
      : Result unit :=
    (self.["try_transfer"] to value).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::transfer: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_transfer : Notation.Dot "transfer" := {
    Notation.dot := transfer;
  }.
  
  Definition try_transfer
      (self : mut_ref Self)
      (to : AccountId)
      (value : Balance)
      : Root.ink.MessageResult (Result unit) :=
    ((Root.ink.codegen.TraitCallBuilder.call_mut self).["transfer"]
          to
          value).["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::transfer: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_transfer : Notation.Dot "try_transfer" := {
    Notation.dot := try_transfer;
  }.
  
  Definition approve
      (self : mut_ref Self)
      (spender : AccountId)
      (value : Balance)
      : Result unit :=
    (self.["try_approve"] spender value).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::approve: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_approve : Notation.Dot "approve" := {
    Notation.dot := approve;
  }.
  
  Definition try_approve
      (self : mut_ref Self)
      (spender : AccountId)
      (value : Balance)
      : Root.ink.MessageResult (Result unit) :=
    ((Root.ink.codegen.TraitCallBuilder.call_mut self).["approve"]
          spender
          value).["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "encountered error while calling Erc20::approve: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_approve : Notation.Dot "try_approve" := {
    Notation.dot := try_approve;
  }.
  
  Definition transfer_from
      (self : mut_ref Self)
      (from : AccountId)
      (to : AccountId)
      (value : Balance)
      : Result unit :=
    (self.["try_transfer_from"] from to value).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::transfer_from: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_transfer_from : Notation.Dot "transfer_from" := {
    Notation.dot := transfer_from;
  }.
  
  Definition try_transfer_from
      (self : mut_ref Self)
      (from : AccountId)
      (to : AccountId)
      (value : Balance)
      : Root.ink.MessageResult (Result unit) :=
    ((Root.ink.codegen.TraitCallBuilder.call_mut self).["transfer_from"]
          from
          to
          value).["try_invoke"].["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of
              [ "encountered error while calling Erc20::transfer_from: " ])
            (addr_of [ format_argument::["new_debug"] (addr_of error) ]))).
  
  Global Instance Method_try_transfer_from :
    Notation.Dot "try_transfer_from" := {
    Notation.dot := try_transfer_from;
  }.
End ImplErc20Ref_2.

Definition _ : unit := run (tt).

Module Impl_Root_ink_codegen_TraitCallBuilder_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition Builder : Set := Root.ink.codegen.ContractCallBuilder.Type.
  
  Definition call (self : ref Self) : ref ImplSelf.Builder :=
    addr_of self.["inner"].
  
  Global Instance Method_call : Notation.Dot "call" := {
    Notation.dot := call;
  }.
  
  Definition call_mut (self : mut_ref Self) : mut_ref ImplSelf.Builder :=
    addr_of self.["inner"].
  
  Global Instance Method_call_mut : Notation.Dot "call_mut" := {
    Notation.dot := call_mut;
  }.
  
  Global Instance I : Root.ink.codegen.TraitCallBuilder.Trait Self := {
    Root.ink.codegen.TraitCallBuilder.call := call;
    Root.ink.codegen.TraitCallBuilder.call_mut := call_mut;
  }.
End Impl_Root_ink_codegen_TraitCallBuilder_for_Erc20Ref.

Module Impl_Root_ink_env_call_FromAccountId_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition from_account_id (account_id : AccountId) : Self :=
    {| Self.inner := Root.ink.env.call.FromAccountId.from_account_id account_id;
    |}.
  
  Global Instance AssociatedFunction_from_account_id :
    Notation.DoubleColon Self "from_account_id" := {
    Notation.double_colon := from_account_id;
  }.
  
  Global Instance I : Root.ink.env.call.FromAccountId.Trait Self Environment :=
    {
    Root.ink.env.call.FromAccountId.from_account_id := from_account_id;
  }.
End Impl_Root_ink_env_call_FromAccountId_for_Erc20Ref.

Module Impl_Root_ink_ToAccountId_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition to_account_id (self : ref Self) : AccountId :=
    Root.ink.ToAccountId.to_account_id (addr_of self.["inner"]).
  
  Global Instance Method_to_account_id : Notation.Dot "to_account_id" := {
    Notation.dot := to_account_id;
  }.
  
  Global Instance I : Root.ink.ToAccountId.Trait Self Environment := {
    Root.ink.ToAccountId.to_account_id := to_account_id;
  }.
End Impl_Root_ink_ToAccountId_for_Erc20Ref.

Module Impl_Root_core_convert_AsRef_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition as_ref (self : ref Self) : ref AccountId :=
    Root.core.convert.AsRef.as_ref (addr_of self.["inner"]).
  
  Global Instance Method_as_ref : Notation.Dot "as_ref" := {
    Notation.dot := as_ref;
  }.
  
  Global Instance I : Root.core.convert.AsRef.Trait Self AccountId := {
    Root.core.convert.AsRef.as_ref := as_ref;
  }.
End Impl_Root_core_convert_AsRef_for_Erc20Ref.

Module Impl_Root_core_convert_AsMut_for_Erc20Ref.
  Definition Self := Erc20Ref.
  
  Definition as_mut (self : mut_ref Self) : mut_ref AccountId :=
    Root.core.convert.AsMut.as_mut (addr_of self.["inner"]).
  
  Global Instance Method_as_mut : Notation.Dot "as_mut" := {
    Notation.dot := as_mut;
  }.
  
  Global Instance I : Root.core.convert.AsMut.Trait Self AccountId := {
    Root.core.convert.AsMut.as_mut := as_mut;
  }.
End Impl_Root_core_convert_AsMut_for_Erc20Ref.

Definition _ : unit := run (tt).

Definition __ink_generate_metadata (_ : unit) : Root.ink.metadata.InkProject :=
  let layout :=
    Root.ink.metadata.layout.Layout.Root
      (Root.ink.metadata.layout.RootLayout::["new"]
        (Root.core.convert.From.from Root.ink.storage.traits.StorageKey.KEY)
        (Root.ink.storage.traits.StorageLayout.layout
          (addr_of Root.ink.storage.traits.StorageKey.KEY))) in
  let _ :=
    (Root.ink.metadata.layout.ValidateLayout::["validate"]
        (addr_of layout)).["unwrap_or_else"]
      (fun error =>
        _crate.panicking.panic_fmt
          (format_arguments::["new_v1"]
            (addr_of [ "metadata ink! generation failed: " ])
            (addr_of [ format_argument::["new_display"] (addr_of error) ]))) in
  Root.ink.metadata.InkProject::["new"]
    layout
    (((((((Root.ink.metadata.ContractSpec::["new"] tt).["constructors"]
                  [
                    (((((((Root.ink.metadata.ConstructorSpec::["from_label"]
                                    "new").["selector"]
                                  [ 155; 174; 157; 94 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "total_supply").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "Balance" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["payable"]
                              false).["default"]
                            false).["returns"]
                          (Root.ink.metadata.ReturnTypeSpec::["new"]
                            (if
                              (Root.ink.reflect.DispatchableConstructorInfo.IS_RESULT
                              : bool)
                            then
                              Root.core.option.Option.Some
                                (Root.ink.metadata.TypeSpec::["with_name_str"]
                                  "ink_primitives::ConstructorResult")
                            else
                              Root.core.option.Option.Some
                                (Root.ink.metadata.TypeSpec::["with_name_str"]
                                  "ink_primitives::ConstructorResult")))).["docs"]
                        [
                          " Creates a new ERC-20 contract with the specified initial supply."
                        ]).["done"]
                  ]).["messages"]
                [
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "total_supply").["selector"]
                                  [ 219; 99; 117; 168 ]).["args"]
                                [ ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            false).["payable"]
                          false).["default"]
                        false).["docs"]
                      [ " Returns the total token supply." ]).["done"];
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "balance_of").["selector"]
                                  [ 15; 117; 90; 86 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "owner").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            false).["payable"]
                          false).["default"]
                        false).["docs"]
                      [
                        " Returns the account balance for the specified `owner`.";
                        "";
                        " Returns `0` if the account is non-existent."
                      ]).["done"];
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "allowance").["selector"]
                                  [ 106; 0; 22; 94 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "owner").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"];
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "spender").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            false).["payable"]
                          false).["default"]
                        false).["docs"]
                      [
                        " Returns the amount which `spender` is still allowed to withdraw from `owner`.";
                        "";
                        " Returns `0` if no allowance has been set."
                      ]).["done"];
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "transfer").["selector"]
                                  [ 132; 161; 93; 161 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "to").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"];
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "value").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "Balance" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            true).["payable"]
                          false).["default"]
                        false).["docs"]
                      [
                        " Transfers `value` amount of tokens from the caller's account to account `to`.";
                        "";
                        " On success a `Transfer` event is emitted.";
                        "";
                        " # Errors";
                        "";
                        " Returns `InsufficientBalance` error if there are not enough tokens on";
                        " the caller's account balance."
                      ]).["done"];
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "approve").["selector"]
                                  [ 104; 18; 102; 160 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "spender").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"];
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "value").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "Balance" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            true).["payable"]
                          false).["default"]
                        false).["docs"]
                      [
                        " Allows `spender` to withdraw from the caller's account multiple times, up to";
                        " the `value` amount.";
                        "";
                        " If this function is called again it overwrites the current allowance with";
                        " `value`.";
                        "";
                        " An `Approval` event is emitted."
                      ]).["done"];
                  ((((((((Root.ink.metadata.MessageSpec::["from_label"]
                                    "transfer_from").["selector"]
                                  [ 11; 57; 111; 24 ]).["args"]
                                [
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "from").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"];
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "to").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "AccountId" ])
                                          Root.core.convert.AsRef.as_ref))).["done"];
                                  ((Root.ink.metadata.MessageParamSpec::["new"]
                                        "value").["of_type"]
                                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                        (Root.core.iter.Iterator.map
                                          (Root.core.iter.IntoIterator.into_iter
                                            [ "Balance" ])
                                          Root.core.convert.AsRef.as_ref))).["done"]
                                ]).["returns"]
                              (Root.ink.metadata.ReturnTypeSpec::["new"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "ink"; "MessageResult" ])
                                    Root.core.convert.AsRef.as_ref)))).["mutates"]
                            true).["payable"]
                          false).["default"]
                        false).["docs"]
                      [
                        " Transfers `value` tokens on the behalf of `from` to the account `to`.";
                        "";
                        " This can be used to allow a contract to transfer tokens on ones behalf and/or";
                        " to charge fees in sub-currencies, for example.";
                        "";
                        " On success a `Transfer` event is emitted.";
                        "";
                        " # Errors";
                        "";
                        " Returns `InsufficientAllowance` error if there are not enough tokens allowed";
                        " for the caller to withdraw from `from`.";
                        "";
                        " Returns `InsufficientBalance` error if there are not enough tokens on";
                        " the account balance of `from`."
                      ]).["done"]
                ]).["events"]
              [
                (((Root.ink.metadata.EventSpec::["new"] "Transfer").["args"]
                      [
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "from").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "Option" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              true).["docs"]
                            [ ]).["done"];
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "to").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "Option" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              true).["docs"]
                            [ ]).["done"];
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "value").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "Balance" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              false).["docs"]
                            [ ]).["done"]
                      ]).["docs"]
                    [ " Event emitted when a token transfer occurs."
                    ]).["done"];
                (((Root.ink.metadata.EventSpec::["new"] "Approval").["args"]
                      [
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "owner").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "AccountId" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              true).["docs"]
                            [ ]).["done"];
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "spender").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "AccountId" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              true).["docs"]
                            [ ]).["done"];
                        ((((Root.ink.metadata.EventParamSpec::["new"]
                                  "value").["of_type"]
                                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                                  (Root.core.iter.Iterator.map
                                    (Root.core.iter.IntoIterator.into_iter
                                      [ "Balance" ])
                                    Root.core.convert.AsRef.as_ref))).["indexed"]
                              false).["docs"]
                            [ ]).["done"]
                      ]).["docs"]
                    [
                      " Event emitted when an approval occurs that `spender` is allowed to withdraw";
                      " up to the amount of `value` tokens from `owner`."
                    ]).["done"]
              ]).["docs"]
            [ ]).["lang_error"]
          (Root.ink.metadata.TypeSpec::["with_name_segs"]
            (Root.core.iter.Iterator.map
              (Root.core.iter.IntoIterator.into_iter [ "ink"; "LangError" ])
              Root.core.convert.AsRef.as_ref))).["environment"]
        ((((((((Root.ink.metadata.EnvironmentSpec::["new"] tt).["account_id"]
                        (Root.ink.metadata.TypeSpec::["with_name_segs"]
                          (Root.core.iter.Iterator.map
                            (Root.core.iter.IntoIterator.into_iter
                              [ "AccountId" ])
                            Root.core.convert.AsRef.as_ref))).["balance"]
                      (Root.ink.metadata.TypeSpec::["with_name_segs"]
                        (Root.core.iter.Iterator.map
                          (Root.core.iter.IntoIterator.into_iter [ "Balance" ])
                          Root.core.convert.AsRef.as_ref))).["hash"]
                    (Root.ink.metadata.TypeSpec::["with_name_segs"]
                      (Root.core.iter.Iterator.map
                        (Root.core.iter.IntoIterator.into_iter [ "Hash" ])
                        Root.core.convert.AsRef.as_ref))).["timestamp"]
                  (Root.ink.metadata.TypeSpec::["with_name_segs"]
                    (Root.core.iter.Iterator.map
                      (Root.core.iter.IntoIterator.into_iter [ "Timestamp" ])
                      Root.core.convert.AsRef.as_ref))).["block_number"]
                (Root.ink.metadata.TypeSpec::["with_name_segs"]
                  (Root.core.iter.Iterator.map
                    (Root.core.iter.IntoIterator.into_iter [ "BlockNumber" ])
                    Root.core.convert.AsRef.as_ref))).["chain_extension"]
              (Root.ink.metadata.TypeSpec::["with_name_segs"]
                (Root.core.iter.Iterator.map
                  (Root.core.iter.IntoIterator.into_iter [ "ChainExtension" ])
                  Root.core.convert.AsRef.as_ref))).["max_event_topics"]
            MAX_EVENT_TOPICS).["done"]).["done"].

Module Mapping := ink.storage.Mapping.
Definition Mapping := Mapping.t.

Module Error.
  Inductive t : Set :=
  | InsufficientBalance
  | InsufficientAllowance.
End Error.
Definition Error := Error.t.

Definition _ : unit := run (tt).

Module Impl_Root_scale_info_TypeInfo_for_Error.
  Definition Self := Error.
  
  Definition Identity : Set := Self.
  
  Definition type_info (_ : unit) : Root.scale_info.Type :=
    ((((Root.scale_info.Type::["builder"] tt).["path"]
            (Root.scale_info.Path::["new"]
              "Error"
              "erc20::erc20")).["type_params"]
          (_crate.vec.Vec::["new"] tt)).["docs"]
        (addr_of [ "The ERC-20 error types." ])).["variant"]
      (((Root.scale_info.build.Variants::["new"] tt).["variant"]
          "InsufficientBalance"
          (fun v =>
            (v.["index"] (cast 0 Root.core.primitive.u8)).["docs"]
              (addr_of
                [
                  "Returned if not enough balance to fulfill a request is available."
                ]))).["variant"]
        "InsufficientAllowance"
        (fun v =>
          (v.["index"] (cast 1 Root.core.primitive.u8)).["docs"]
            (addr_of
              [
                "Returned if not enough allowance to fulfill a request is available."
              ]))).
  
  Global Instance AssociatedFunction_type_info :
    Notation.DoubleColon Self "type_info" := {
    Notation.double_colon := type_info;
  }.
  
  Global Instance I : Root.scale_info.TypeInfo.Trait Self := {
    Root.scale_info.TypeInfo.type_info := type_info;
  }.
End Impl_Root_scale_info_TypeInfo_for_Error.

Module Impl__crate_fmt_Debug_for_Error.
  Definition Self := Error.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : _crate.fmt.Result :=
    _crate.fmt.Formatter::["write_str"]
      f
      match self with
      | Error.InsufficientBalance => "InsufficientBalance"
      | Error.InsufficientAllowance => "InsufficientAllowance"
      end.
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_Error.

Module Impl__crate_marker_StructuralPartialEq_for_Error.
  Definition Self := Error.
  
  Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
    _crate.marker.StructuralPartialEq.Build_Class _.
End Impl__crate_marker_StructuralPartialEq_for_Error.

Module Impl__crate_cmp_PartialEq_for_Error.
  Definition Self := Error.
  
  Definition eq (self : ref Self) (other : ref Error) : bool :=
    let __self_tag := _crate.intrinsics.discriminant_value self in
    let __arg1_tag := _crate.intrinsics.discriminant_value other in
    __self_tag.["eq"] __arg1_tag.
  
  Global Instance Method_eq : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : _crate.cmp.PartialEq.Trait Self := {
    _crate.cmp.PartialEq.eq := eq;
  }.
End Impl__crate_cmp_PartialEq_for_Error.

Module Impl__crate_marker_StructuralEq_for_Error.
  Definition Self := Error.
  
  Global Instance I : _crate.marker.StructuralEq.Trait Self :=
    _crate.marker.StructuralEq.Build_Class _.
End Impl__crate_marker_StructuralEq_for_Error.

Module Impl__crate_cmp_Eq_for_Error.
  Definition Self := Error.
  
  Definition assert_receiver_is_total_eq (self : ref Self) : unit := tt.
  
  Global Instance Method_assert_receiver_is_total_eq :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : _crate.cmp.Eq.Trait Self := {
  }.
End Impl__crate_cmp_Eq_for_Error.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Encode_for_Error.
  Definition Self := Error.
  
  Definition encode_to
      (self : ref Self)
      (__codec_dest_edqy : mut_ref __CodecOutputEdqy)
      : unit :=
    match self.["deref"] with
    | Error.InsufficientBalance =>
      let _ :=
        __codec_dest_edqy.["push_byte"] (cast 0 Root.core.primitive.u8) in
      tt
    | Error.InsufficientAllowance =>
      let _ :=
        __codec_dest_edqy.["push_byte"] (cast 1 Root.core.primitive.u8) in
      tt
    | _ => tt
    end.
  
  Global Instance Method_encode_to : Notation.Dot "encode_to" := {
    Notation.dot := encode_to;
  }.
  
  Global Instance I : Root.scale.Encode.Trait Self := {
  }.
End Impl_Root_scale_Encode_for_Error.

Module Impl_Root_scale_EncodeLike_for_Error.
  Definition Self := Error.
  
  Global Instance I : Root.scale.EncodeLike.Trait Self :=
    Root.scale.EncodeLike.Build_Class _.
End Impl_Root_scale_EncodeLike_for_Error.

Definition _ : unit := run (tt).

Module Impl_Root_scale_Decode_for_Error.
  Definition Self := Error.
  
  Definition decode
      (__codec_input_edqy : mut_ref __CodecInputEdqy)
      : Root.core.result.Result Self Root.scale.Error :=
    match
      match
        LangItem
          (__codec_input_edqy.["read_byte"].["map_err"]
            (fun e =>
              e.["chain"]
                "Could not decode `Error`, failed to read variant byte"))
      with
      | Break {| Break.0 := residual; |} => Return (LangItem residual)
      | Continue {| Continue.0 := val; |} => val
      end
    with
    | __codec_x_edqy => Root.core.result.Result.Ok Error.InsufficientBalance
    | __codec_x_edqy => Root.core.result.Result.Ok Error.InsufficientAllowance
    | _ =>
      Root.core.result.Result.Err
        (Root.core.convert.Into.into
          "Could not decode `Error`, variant doesn't exist")
    end.
  
  Global Instance AssociatedFunction_decode :
    Notation.DoubleColon Self "decode" := {
    Notation.double_colon := decode;
  }.
  
  Global Instance I : Root.scale.Decode.Trait Self := {
    Root.scale.Decode.decode := decode;
  }.
End Impl_Root_scale_Decode_for_Error.

Definition Result : Set := core.result.Result T Error.
