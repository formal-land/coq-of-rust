(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module mem := std.mem.

Definition analyze_slice (slice : ref Slice) : unit :=
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "first element of the slice: "; "
" ]
          [ format_argument::["new_display"] slice[0] ]) in
    tt in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "the slice has "; " elements
" ]
          [ format_argument::["new_display"] slice.["len"] ]) in
    tt in
  tt.

(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (_ : unit) : unit :=
  let xs := [ 1; 2; 3; 4; 5 ] in
  let ys := repeat 0 in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "first element of the array: "; "
" ]
          [ format_argument::["new_display"] xs[0] ]) in
    tt in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "second element of the array: "; "
" ]
          [ format_argument::["new_display"] xs[1] ]) in
    tt in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "number of elements in array: "; "
" ]
          [ format_argument::["new_display"] xs.["len"] ]) in
    tt in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_v1"]
          [ "array occupies "; " bytes
" ]
          [ format_argument::["new_display"] (mem.size_of_val xs) ]) in
    tt in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_const"]
          [ "borrow the whole array as a slice
" ]) in
    tt in
  let _ := analyze_slice xs in
  let _ :=
    let _ :=
      _crate.io._print
        (format_arguments::["new_const"]
          [ "borrow a section of the array as a slice
" ]) in
    tt in
  let _ := analyze_slice ys[Range {| Range.start := 1; Range.end := 4; |}] in
  let empty_array := [ ] in
  let _ :=
    match (empty_array, [ ]) with
    | (left_val, right_val) =>
      if ((left_val.["deref"].["eq"] right_val.["deref"]).["not"] : bool) then
        let kind := _crate.panicking.AssertKind.Eq in
        let _ :=
          _crate.panicking.assert_failed
            kind
            left_val.["deref"]
            right_val.["deref"]
            _crate.option.Option.None in
        tt
      else
        tt
    end in
  let _ :=
    match (empty_array, [ ][RangeFull {|  |}]) with
    | (left_val, right_val) =>
      if ((left_val.["deref"].["eq"] right_val.["deref"]).["not"] : bool) then
        let kind := _crate.panicking.AssertKind.Eq in
        let _ :=
          _crate.panicking.assert_failed
            kind
            left_val.["deref"]
            right_val.["deref"]
            _crate.option.Option.None in
        tt
      else
        tt
    end in
  match
    LangItem Range {| Range.start := 0; Range.end := xs.["len"].["add"] 1; |}
  with
  | iter =>
    loop
      let _ :=
        match LangItem iter with
        | None => Break
        | Some {| Some.0 := i; |} =>
          match xs.["get"] i with
          | Some xval =>
            let _ :=
              _crate.io._print
                (format_arguments::["new_v1"]
                  [ ""; ": "; "
" ]
                  [
                    format_argument::["new_display"] i;
                    format_argument::["new_display"] xval
                  ]) in
            tt
          | None =>
            let _ :=
              _crate.io._print
                (format_arguments::["new_v1"]
                  [ "Slow down! "; " is too far!
" ]
                  [ format_argument::["new_display"] i ]) in
            tt
          end
        end in
      tt
      from
      for
  end.
