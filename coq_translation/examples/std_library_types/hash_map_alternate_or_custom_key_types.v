(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module Account.
  Record t : Set := {
    username : ref str;
    password : ref str;
  }.
  
  Global Instance Get_username : Notation.Dot "username" := {
    Notation.dot '(Build_t x0 _) := x0;
  }.
  Global Instance Get_password : Notation.Dot "password" := {
    Notation.dot '(Build_t _ x1) := x1;
  }.
End Account.
Definition Account : Set := Account.t.

Module Impl__crate_marker_StructuralPartialEq_for_Account.
  Definition Self := Account.
  
  Global Instance I : _crate.marker.StructuralPartialEq.Trait Self :=
    _crate.marker.StructuralPartialEq.Build_Class _.
End Impl__crate_marker_StructuralPartialEq_for_Account.

Module Impl__crate_cmp_PartialEq_for_Account.
  Definition Self := Account.
  
  Definition eq (self : ref Self) (other : ref Account) : M bool :=
    let* α0 := self.["username"].["eq"] other.["username"] in
    let* α1 := self.["password"].["eq"] other.["password"] in
    α0.["andb"] α1.
  
  Global Instance Method_eq : Notation.Dot "eq" := {
    Notation.dot := eq;
  }.
  
  Global Instance I : _crate.cmp.PartialEq.Trait Self := {
    _crate.cmp.PartialEq.eq := eq;
  }.
End Impl__crate_cmp_PartialEq_for_Account.

Module Impl__crate_marker_StructuralEq_for_Account.
  Definition Self := Account.
  
  Global Instance I : _crate.marker.StructuralEq.Trait Self :=
    _crate.marker.StructuralEq.Build_Class _.
End Impl__crate_marker_StructuralEq_for_Account.

Module Impl__crate_cmp_Eq_for_Account.
  Definition Self := Account.
  
  Definition assert_receiver_is_total_eq (self : ref Self) : M unit :=
    let _ := tt in
    let _ := tt in
    Pure tt.
  
  Global Instance Method_assert_receiver_is_total_eq :
    Notation.Dot "assert_receiver_is_total_eq" := {
    Notation.dot := assert_receiver_is_total_eq;
  }.
  
  Global Instance I : _crate.cmp.Eq.Trait Self := {
  }.
End Impl__crate_cmp_Eq_for_Account.

Module Impl__crate_hash_Hash_for_Account.
  Definition Self := Account.
  
  Definition hash (self : ref Self) (state : mut_ref __H) : M unit :=
    let* _ := _crate.hash.Hash.hash (addr_of self.["username"]) state in
    _crate.hash.Hash.hash (addr_of self.["password"]) state.
  
  Global Instance Method_hash : Notation.Dot "hash" := {
    Notation.dot := hash;
  }.
  
  Global Instance I : _crate.hash.Hash.Trait Self := {
    _crate.hash.Hash.hash := hash;
  }.
End Impl__crate_hash_Hash_for_Account.

Module AccountInfo.
  Record t : Set := {
    name : ref str;
    email : ref str;
  }.
  
  Global Instance Get_name : Notation.Dot "name" := {
    Notation.dot '(Build_t x0 _) := x0;
  }.
  Global Instance Get_email : Notation.Dot "email" := {
    Notation.dot '(Build_t _ x1) := x1;
  }.
End AccountInfo.
Definition AccountInfo : Set := AccountInfo.t.

Definition Accounts : Set := std.collections.HashMap Account AccountInfo.

Definition try_logon
    (accounts : ref Accounts)
    (username : ref str)
    (password : ref str)
    : M unit :=
  let* _ :=
    let* _ :=
      let* α0 := format_argument::["new_display"] (addr_of username) in
      let* α1 :=
        format_arguments::["new_v1"]
          (addr_of [ "Username: "; "
" ])
          (addr_of [ α0 ]) in
      _crate.io._print α1 in
    Pure tt in
  let* _ :=
    let* _ :=
      let* α0 := format_argument::["new_display"] (addr_of password) in
      let* α1 :=
        format_arguments::["new_v1"]
          (addr_of [ "Password: "; "
" ])
          (addr_of [ α0 ]) in
      _crate.io._print α1 in
    Pure tt in
  let* _ :=
    let* _ :=
      let* α0 :=
        format_arguments::["new_const"] (addr_of [ "Attempting logon...
" ]) in
      _crate.io._print α0 in
    Pure tt in
  let logon :=
    {| Account.username := username; Account.password := password; |} in
  let* α0 := accounts.["get"] (addr_of logon) in
  match α0 with
  | Some account_info =>
    let* _ :=
      let* _ :=
        let* α0 :=
          format_arguments::["new_const"] (addr_of [ "Successful logon!
" ]) in
        _crate.io._print α0 in
      Pure tt in
    let* _ :=
      let* _ :=
        let* α0 :=
          format_argument::["new_display"] (addr_of account_info.["name"]) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "Name: "; "
" ])
            (addr_of [ α0 ]) in
        _crate.io._print α1 in
      Pure tt in
    let* _ :=
      let* _ :=
        let* α0 :=
          format_argument::["new_display"] (addr_of account_info.["email"]) in
        let* α1 :=
          format_arguments::["new_v1"]
            (addr_of [ "Email: "; "
" ])
            (addr_of [ α0 ]) in
        _crate.io._print α1 in
      Pure tt in
    Pure tt
  | _ =>
    let* _ :=
      let* α0 :=
        format_arguments::["new_const"] (addr_of [ "Login failed!
" ]) in
      _crate.io._print α0 in
    Pure tt
  end.

(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (_ : unit) : M unit :=
  let* accounts := std.collections.HashMap::["new"] tt in
  let account :=
    {| Account.username := "j.everyman"; Account.password := "password123";
    |} in
  let account_info :=
    {|
      AccountInfo.name := "John Everyman";
      AccountInfo.email := "j.everyman@email.com";
    |} in
  let* _ := accounts.["insert"] account account_info in
  let* _ := try_logon (addr_of accounts) "j.everyman" "psasword123" in
  let* _ := try_logon (addr_of accounts) "j.everyman" "password123" in
  Pure tt.
