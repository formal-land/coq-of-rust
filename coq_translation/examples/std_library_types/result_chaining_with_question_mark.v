(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Import Root.std.prelude.rust_2015.

Module checked.
  Module MathError.
    Inductive t : Set :=
    | DivisionByZero
    | NonPositiveLogarithm
    | NegativeSquareRoot.
  End MathError.
  Definition MathError := MathError.t.
  
  Module Impl__crate_fmt_Debug_for_MathError.
    Definition Self := MathError.
    
    Definition fmt
        (self : ref Self)
        (f : mut_ref _crate.fmt.Formatter)
        : M _crate.fmt.Result :=
      let* α0 :=
        match self with
        | MathError.DivisionByZero => Pure "DivisionByZero"
        | MathError.NonPositiveLogarithm => Pure "NonPositiveLogarithm"
        | MathError.NegativeSquareRoot => Pure "NegativeSquareRoot"
        end in
      _crate.fmt.Formatter::["write_str"] f α0.
    
    Global Instance Method_fmt : Notation.Dot "fmt" := {
      Notation.dot := fmt;
    }.
    
    Global Instance I : _crate.fmt.Debug.Trait Self := {
      _crate.fmt.Debug.fmt := fmt;
    }.
  End Impl__crate_fmt_Debug_for_MathError.
  
  Definition MathResult : Set := Result f64 MathError.
  
  Definition div (x : f64) (y : f64) : M MathResult :=
    let* α0 := y.["eq"] 0 (* 0.0 *) in
    if (α0 : bool) then
      Err MathError.DivisionByZero
    else
      let* α0 := x.["div"] y in
      Ok α0.
  
  Definition sqrt (x : f64) : M MathResult :=
    let* α0 := x.["lt"] 0 (* 0.0 *) in
    if (α0 : bool) then
      Err MathError.NegativeSquareRoot
    else
      let* α0 := x.["sqrt"] in
      Ok α0.
  
  Definition ln (x : f64) : M MathResult :=
    let* α0 := x.["le"] 0 (* 0.0 *) in
    if (α0 : bool) then
      Err MathError.NonPositiveLogarithm
    else
      let* α0 := x.["ln"] in
      Ok α0.
  
  Definition op_ (x : f64) (y : f64) : M MathResult :=
    let* α0 := div x y in
    let* α1 := LangItem α0 in
    let* ratio :=
      match α1 with
      | Break {| Break.0 := residual; |} =>
        let* α0 := LangItem residual in
        Return α0
      | Continue {| Continue.0 := val; |} => Pure val
      end in
    let* α2 := ln ratio in
    let* α3 := LangItem α2 in
    let* ln :=
      match α3 with
      | Break {| Break.0 := residual; |} =>
        let* α0 := LangItem residual in
        Return α0
      | Continue {| Continue.0 := val; |} => Pure val
      end in
    sqrt ln.
  
  Definition op (x : f64) (y : f64) : M unit :=
    let* α0 := op_ x y in
    match α0 with
    | Err why =>
      let* α0 :=
        match why with
        | MathError.NonPositiveLogarithm =>
          Pure "logarithm of non-positive number"
        | MathError.DivisionByZero => Pure "division by zero"
        | MathError.NegativeSquareRoot => Pure "square root of negative number"
        end in
      _crate.rt.panic_display (deref α0)
    | Ok value =>
      let* α0 := format_argument::["new_display"] (deref value) in
      let* α1 :=
        format_arguments::["new_v1"] (deref [ ""; "
" ]) (deref [ α0 ]) in
      let* _ := _crate.io._print α1 in
      Pure tt
    end.
End checked.

Module MathError.
  Inductive t : Set :=
  | DivisionByZero
  | NonPositiveLogarithm
  | NegativeSquareRoot.
End MathError.
Definition MathError := MathError.t.

Module Impl__crate_fmt_Debug_for_MathError.
  Definition Self := MathError.
  
  Definition fmt
      (self : ref Self)
      (f : mut_ref _crate.fmt.Formatter)
      : M _crate.fmt.Result :=
    let* α0 :=
      match self with
      | MathError.DivisionByZero => Pure "DivisionByZero"
      | MathError.NonPositiveLogarithm => Pure "NonPositiveLogarithm"
      | MathError.NegativeSquareRoot => Pure "NegativeSquareRoot"
      end in
    _crate.fmt.Formatter::["write_str"] f α0.
  
  Global Instance Method_fmt : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : _crate.fmt.Debug.Trait Self := {
    _crate.fmt.Debug.fmt := fmt;
  }.
End Impl__crate_fmt_Debug_for_MathError.

Definition MathResult : Set := Result f64 MathError.

Definition div (x : f64) (y : f64) : M MathResult :=
  let* α0 := y.["eq"] 0 (* 0.0 *) in
  if (α0 : bool) then
    Err MathError.DivisionByZero
  else
    let* α0 := x.["div"] y in
    Ok α0.

Definition sqrt (x : f64) : M MathResult :=
  let* α0 := x.["lt"] 0 (* 0.0 *) in
  if (α0 : bool) then
    Err MathError.NegativeSquareRoot
  else
    let* α0 := x.["sqrt"] in
    Ok α0.

Definition ln (x : f64) : M MathResult :=
  let* α0 := x.["le"] 0 (* 0.0 *) in
  if (α0 : bool) then
    Err MathError.NonPositiveLogarithm
  else
    let* α0 := x.["ln"] in
    Ok α0.

Definition op_ (x : f64) (y : f64) : M MathResult :=
  let* α0 := div x y in
  let* α1 := LangItem α0 in
  let* ratio :=
    match α1 with
    | Break {| Break.0 := residual; |} =>
      let* α0 := LangItem residual in
      Return α0
    | Continue {| Continue.0 := val; |} => Pure val
    end in
  let* α2 := ln ratio in
  let* α3 := LangItem α2 in
  let* ln :=
    match α3 with
    | Break {| Break.0 := residual; |} =>
      let* α0 := LangItem residual in
      Return α0
    | Continue {| Continue.0 := val; |} => Pure val
    end in
  sqrt ln.

Definition op (x : f64) (y : f64) : M unit :=
  let* α0 := op_ x y in
  match α0 with
  | Err why =>
    let* α0 :=
      match why with
      | MathError.NonPositiveLogarithm =>
        Pure "logarithm of non-positive number"
      | MathError.DivisionByZero => Pure "division by zero"
      | MathError.NegativeSquareRoot => Pure "square root of negative number"
      end in
    _crate.rt.panic_display (deref α0)
  | Ok value =>
    let* α0 := format_argument::["new_display"] (deref value) in
    let* α1 :=
      format_arguments::["new_v1"] (deref [ ""; "
" ]) (deref [ α0 ]) in
    let* _ := _crate.io._print α1 in
    Pure tt
  end.

(* #[allow(dead_code)] - function was ignored by the compiler *)
Definition main (_ : unit) : M unit :=
  let* _ := checked.op 1 (* 1.0 *) 10 (* 10.0 *) in
  Pure tt.
