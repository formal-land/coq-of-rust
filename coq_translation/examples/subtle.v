(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Choice.
  Unset Primitive Projections.
  Record t : Set := {
    _ : u8;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_0 : Notation.Dot 0 := {
    Notation.dot '(Build_t x0) := x0;
  }.
End Choice.
Definition Choice := @Choice.t.

Module Impl_core_marker_Copy_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Global Instance I : core.marker.Copy.Trait Self :=
    core.marker.Copy.Build_Trait _.
End Impl_core_marker_Copy_for_subtle_Choice.

Module Impl_core_clone_Clone_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition clone
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) subtle.Choice :=
    let _ : core.clone.AssertParamIsClone u8 := tt in
    self.["deref"].
  
  Global Instance Method_clone `{H : State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone `{H : State.Trait} := clone;
  }.
End Impl_core_clone_Clone_for_subtle_Choice.

Module Impl_core_fmt_Debug_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition fmt
      `{H : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H) core.fmt.Result :=
    core.fmt.Formatter::["debug_tuple_field1_finish"]
      f
      "Choice"
      (addr_of (addr_of (self.[0]))).
  
  Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H : State.Trait} := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_Choice.

Module Impl_subtle_Choice_4.
  Definition Self := subtle.Choice.
  
  Definition unwrap_u8 `{H : State.Trait} (self : ref Self) : M (H := H) u8 :=
    Pure (self.[0]).
  
  Global Instance Method_unwrap_u8 `{H : State.Trait} :
    Notation.Dot "unwrap_u8" := {
    Notation.dot := unwrap_u8;
  }.
End Impl_subtle_Choice_4.

Module Impl_core_convert_From_for_bool.
  Definition Self := bool.
  
  Definition from
      `{H : State.Trait}
      (source : subtle.Choice)
      : M (H := H) bool :=
    let* _ :=
      if (true : bool) then
        let* _ :=
          let* α0 := (source.[0]).["eq"] 0 in
          let* α1 := (source.[0]).["eq"] 1 in
          let* α2 := α0.["bitor"] α1 in
          let* α3 := α2.["not"] in
          if (α3 : bool) then
            core.panicking.panic
              "assertion failed: (source.0 == 0u8) | (source.0 == 1u8)"
          else
            Pure tt in
        Pure tt
      else
        Pure tt in
    (source.[0]).["ne"] 0.
  
  Global Instance AssociatedFunction_from `{H : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : core.convert.From.Trait Self (T := subtle.Choice) := {
    core.convert.From.from `{H : State.Trait} := from;
  }.
End Impl_core_convert_From_for_bool.

Module Impl_core_ops_bit_BitAnd_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitand
      `{H : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H) subtle.Choice :=
    let* α0 := (self.[0]).["bitand"] (rhs.[0]) in
    α0.["into"].
  
  Global Instance Method_bitand `{H : State.Trait} : Notation.Dot "bitand" := {
    Notation.dot := bitand;
  }.
  
  Global Instance I : core.ops.bit.BitAnd.Trait Self (Rhs := None) := {
    core.ops.bit.BitAnd.bitand `{H : State.Trait} := bitand;
  }.
End Impl_core_ops_bit_BitAnd_for_subtle_Choice.

Module Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitand_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H) unit :=
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := α1.["bitand"] rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitand_assign `{H : State.Trait} :
    Notation.Dot "bitand_assign" := {
    Notation.dot := bitand_assign;
  }.
  
  Global Instance I : core.ops.bit.BitAndAssign.Trait Self (Rhs := None) := {
    core.ops.bit.BitAndAssign.bitand_assign `{H : State.Trait} := bitand_assign;
  }.
End Impl_core_ops_bit_BitAndAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitOr_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitor
      `{H : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H) subtle.Choice :=
    let* α0 := (self.[0]).["bitor"] (rhs.[0]) in
    α0.["into"].
  
  Global Instance Method_bitor `{H : State.Trait} : Notation.Dot "bitor" := {
    Notation.dot := bitor;
  }.
  
  Global Instance I : core.ops.bit.BitOr.Trait Self (Rhs := None) := {
    core.ops.bit.BitOr.bitor `{H : State.Trait} := bitor;
  }.
End Impl_core_ops_bit_BitOr_for_subtle_Choice.

Module Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitor_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H) unit :=
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := α1.["bitor"] rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitor_assign `{H : State.Trait} :
    Notation.Dot "bitor_assign" := {
    Notation.dot := bitor_assign;
  }.
  
  Global Instance I : core.ops.bit.BitOrAssign.Trait Self (Rhs := None) := {
    core.ops.bit.BitOrAssign.bitor_assign `{H : State.Trait} := bitor_assign;
  }.
End Impl_core_ops_bit_BitOrAssign_for_subtle_Choice.

Module Impl_core_ops_bit_BitXor_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition bitxor
      `{H : State.Trait}
      (self : Self)
      (rhs : subtle.Choice)
      : M (H := H) subtle.Choice :=
    let* α0 := (self.[0]).["bitxor"] (rhs.[0]) in
    α0.["into"].
  
  Global Instance Method_bitxor `{H : State.Trait} : Notation.Dot "bitxor" := {
    Notation.dot := bitxor;
  }.
  
  Global Instance I : core.ops.bit.BitXor.Trait Self (Rhs := None) := {
    core.ops.bit.BitXor.bitxor `{H : State.Trait} := bitxor;
  }.
End Impl_core_ops_bit_BitXor_for_subtle_Choice.

Module Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition bitxor_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (rhs : subtle.Choice)
      : M (H := H) unit :=
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := α1.["bitxor"] rhs in
      assign α0 α2 in
    Pure tt.
  
  Global Instance Method_bitxor_assign `{H : State.Trait} :
    Notation.Dot "bitxor_assign" := {
    Notation.dot := bitxor_assign;
  }.
  
  Global Instance I : core.ops.bit.BitXorAssign.Trait Self (Rhs := None) := {
    core.ops.bit.BitXorAssign.bitxor_assign `{H : State.Trait} := bitxor_assign;
  }.
End Impl_core_ops_bit_BitXorAssign_for_subtle_Choice.

Module Impl_core_ops_bit_Not_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition Output : Set := subtle.Choice.
  
  Definition not `{H : State.Trait} (self : Self) : M (H := H) subtle.Choice :=
    let* α0 := (self.[0]).["not"] in
    let* α1 := 1.["bitand"] α0 in
    α1.["into"].
  
  Global Instance Method_not `{H : State.Trait} : Notation.Dot "not" := {
    Notation.dot := not;
  }.
  
  Global Instance I : core.ops.bit.Not.Trait Self := {
    core.ops.bit.Not.not `{H : State.Trait} := not;
  }.
End Impl_core_ops_bit_Not_for_subtle_Choice.

Definition black_box `{H : State.Trait} (input : u8) : M (H := H) u8 :=
  let* _ :=
    if (true : bool) then
      let* _ :=
        let* α0 := input.["eq"] 0 in
        let* α1 := input.["eq"] 1 in
        let* α2 := α0.["bitor"] α1 in
        let* α3 := α2.["not"] in
        if (α3 : bool) then
          core.panicking.panic
            "assertion failed: (input == 0u8) | (input == 1u8)"
        else
          Pure tt in
      Pure tt
    else
      Pure tt in
  core.ptr.read_volatile (cast (addr_of input) (ref u8)).

Module Impl_core_convert_From_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition from `{H : State.Trait} (input : u8) : M (H := H) subtle.Choice :=
    let* α0 := subtle.black_box input in
    Pure (subtle.Choice.Build_t α0).
  
  Global Instance AssociatedFunction_from `{H : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : core.convert.From.Trait Self (T := u8) := {
    core.convert.From.from `{H : State.Trait} := from;
  }.
End Impl_core_convert_From_for_subtle_Choice.

Module ConstantTimeEq.
  Class Trait (Self : Set) : Set := {
    ct_eq
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) subtle.Choice);
  }.
  
  Global Instance Method_ct_eq `{H : State.Trait} `(Trait)
    : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  Global Instance Method_ct_ne `{H : State.Trait} `(Trait)
    : Notation.Dot "ct_ne" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := self.["ct_eq"] other in
      α0.["not"]
      : M (H := H) subtle.Choice);
  }.
End ConstantTimeEq.

Module Impl_subtle_ConstantTimeEq_for_Slice_T.
Section Impl_subtle_ConstantTimeEq_for_Slice_T.
  Context {T : Set}.
  
  Definition Self := Slice T.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (_rhs : ref (Slice T))
      : M (H := H) subtle.Choice :=
    let* len := self.["len"] in
    let* _ :=
      let* α0 := _rhs.["len"] in
      let* α1 := len.["ne"] α0 in
      if (α1 : bool) then
        let* _ :=
          let* α0 := subtle.Choice::["from"] 0 in
          Return α0 in
        Pure tt
      else
        Pure tt in
    let x := 1 in
    let* _ :=
      let* α0 := self.["iter"] in
      let* α1 := _rhs.["iter"] in
      let* α2 := α0.["zip"] α1 in
      let* α3 := α2.["into_iter"] in
      match α3 with
      | iter =>
        loop
          (let* _ :=
            let* α0 := (addr_of iter).["next"] in
            match α0 with
            | core.option.Option.None  => Break
            | core.option.Option.Some (ai, bi) =>
              let* _ :=
                let* α0 := ai.["ct_eq"] bi in
                let* α1 := α0.["unwrap_u8"] in
                x.["bitand_assign"] α1 in
              Pure tt
            end in
          Pure tt)
      end in
    x.["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_Slice_T.
End Impl_subtle_ConstantTimeEq_for_Slice_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (rhs : ref subtle.Choice)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := rhs.["deref"] in
    let* α2 := α0.["bitxor"] α1 in
    α2.["not"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_Choice.

Module Impl_subtle_ConstantTimeEq_for_u8.
  Definition Self := u8.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M (H := H) subtle.Choice :=
    let* x := self.["bitxor"] other in
    let* y :=
      let* α0 := x.["wrapping_neg"] in
      let* α1 := x.["bitor"] α0 in
      let* α2 := 8.["sub"] 1 in
      α1.["shr"] α2 in
    let* α0 := y.["bitxor"] (cast 1 u8) in
    (cast α0 u8).["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_u8.

Module Impl_subtle_ConstantTimeEq_for_i8.
  Definition Self := i8.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref i8)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := other.["deref"] in
    (cast α0 u8).["ct_eq"] (addr_of (cast α1 u8)).
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_i8.

Module Impl_subtle_ConstantTimeEq_for_u16.
  Definition Self := u16.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M (H := H) subtle.Choice :=
    let* x := self.["bitxor"] other in
    let* y :=
      let* α0 := x.["wrapping_neg"] in
      let* α1 := x.["bitor"] α0 in
      let* α2 := 16.["sub"] 1 in
      α1.["shr"] α2 in
    let* α0 := y.["bitxor"] (cast 1 u16) in
    (cast α0 u8).["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_u16.

Module Impl_subtle_ConstantTimeEq_for_i16.
  Definition Self := i16.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref i16)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := other.["deref"] in
    (cast α0 u16).["ct_eq"] (addr_of (cast α1 u16)).
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_i16.

Module Impl_subtle_ConstantTimeEq_for_u32.
  Definition Self := u32.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M (H := H) subtle.Choice :=
    let* x := self.["bitxor"] other in
    let* y :=
      let* α0 := x.["wrapping_neg"] in
      let* α1 := x.["bitor"] α0 in
      let* α2 := 32.["sub"] 1 in
      α1.["shr"] α2 in
    let* α0 := y.["bitxor"] (cast 1 u32) in
    (cast α0 u8).["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_u32.

Module Impl_subtle_ConstantTimeEq_for_i32.
  Definition Self := i32.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref i32)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := other.["deref"] in
    (cast α0 u32).["ct_eq"] (addr_of (cast α1 u32)).
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_i32.

Module Impl_subtle_ConstantTimeEq_for_u64.
  Definition Self := u64.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M (H := H) subtle.Choice :=
    let* x := self.["bitxor"] other in
    let* y :=
      let* α0 := x.["wrapping_neg"] in
      let* α1 := x.["bitor"] α0 in
      let* α2 := 64.["sub"] 1 in
      α1.["shr"] α2 in
    let* α0 := y.["bitxor"] (cast 1 u64) in
    (cast α0 u8).["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_u64.

Module Impl_subtle_ConstantTimeEq_for_i64.
  Definition Self := i64.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref i64)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := other.["deref"] in
    (cast α0 u64).["ct_eq"] (addr_of (cast α1 u64)).
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_i64.

Module Impl_subtle_ConstantTimeEq_for_usize.
  Definition Self := usize.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref usize)
      : M (H := H) subtle.Choice :=
    let* x := self.["bitxor"] other in
    let* y :=
      let* α0 := x.["wrapping_neg"] in
      let* α1 := x.["bitor"] α0 in
      let* α2 := core.mem.size_of in
      let* α3 := α2.["mul"] 8 in
      let* α4 := α3.["sub"] 1 in
      α1.["shr"] α4 in
    let* α0 := y.["bitxor"] (cast 1 usize) in
    (cast α0 u8).["into"].
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_usize.

Module Impl_subtle_ConstantTimeEq_for_isize.
  Definition Self := isize.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (other : ref isize)
      : M (H := H) subtle.Choice :=
    let* α0 := self.["deref"] in
    let* α1 := other.["deref"] in
    (cast α0 usize).["ct_eq"] (addr_of (cast α1 usize)).
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_isize.

Module ConditionallySelectable.
  Class Trait (Self : Set) `{core.marker.Copy.Trait Self} : Set := {
    conditional_select
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> subtle.Choice -> (M (H := H) Self);
  }.
  
  Global Instance Method_conditional_select `{H : State.Trait} `(Trait)
    : Notation.Dot "conditional_select" := {
    Notation.dot := conditional_select;
  }.
  Global Instance Method_conditional_assign `{H : State.Trait} `(Trait)
    : Notation.Dot "conditional_assign" := {
    Notation.dot (self : mut_ref Self) (other : ref Self)
          (choice
          : subtle.Choice)
      :=
      (let* _ :=
        let* α0 := self.["deref"] in
        let* α1 := Self::["conditional_select"] self other choice in
        assign α0 α1 in
      Pure tt
      : M (H := H) unit);
  }.
  Global Instance Method_conditional_swap `{H : State.Trait} `(Trait)
    : Notation.Dot "conditional_swap" := {
    Notation.dot (a : mut_ref Self) (b : mut_ref Self) (choice : subtle.Choice)
      :=
      (let* t := a.["deref"] in
      let* _ := a.["conditional_assign"] (addr_of b) choice in
      let* _ := b.["conditional_assign"] (addr_of t) choice in
      Pure tt
      : M (H := H) unit);
  }.
End ConditionallySelectable.

Module Impl_subtle_ConditionallySelectable_for_u8.
  Definition Self := u8.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 u8) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 u8) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 u8) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_u8.

Module Impl_subtle_ConditionallySelectable_for_i8.
  Definition Self := i8.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 i8) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 i8) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i8).["neg"] in
      Pure (cast α1 i8) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_i8.

Module Impl_subtle_ConditionallySelectable_for_u16.
  Definition Self := u16.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 u16) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 u16) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 u16) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_u16.

Module Impl_subtle_ConditionallySelectable_for_i16.
  Definition Self := i16.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 i16) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 i16) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i16).["neg"] in
      Pure (cast α1 i16) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_i16.

Module Impl_subtle_ConditionallySelectable_for_u32.
  Definition Self := u32.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 u32) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 u32) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 u32) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_u32.

Module Impl_subtle_ConditionallySelectable_for_i32.
  Definition Self := i32.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 i32) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 i32) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i32).["neg"] in
      Pure (cast α1 i32) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_i32.

Module Impl_subtle_ConditionallySelectable_for_u64.
  Definition Self := u64.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 u64) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 u64) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 u64) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_u64.

Module Impl_subtle_ConditionallySelectable_for_i64.
  Definition Self := i64.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 i64) in
    let* α0 := a.["bitxor"] b in
    let* α1 := mask.["bitand"] α0 in
    a.["bitxor"] α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Definition conditional_assign
      `{H : State.Trait}
      (self : mut_ref Self)
      (other : ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 i64) in
    let* _ :=
      let* α0 := self.["deref"] in
      let* α1 := self.["deref"] in
      let* α2 := other.["deref"] in
      let* α3 := α1.["bitxor"] α2 in
      let* α4 := mask.["bitand"] α3 in
      α0.["bitxor_assign"] α4 in
    Pure tt.
  
  Global Instance Method_conditional_assign `{H : State.Trait} :
    Notation.Dot "conditional_assign" := {
    Notation.dot := conditional_assign;
  }.
  
  Definition conditional_swap
      `{H : State.Trait}
      (a : mut_ref Self)
      (b : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* mask :=
      let* α0 := choice.["unwrap_u8"] in
      let* α1 := (cast α0 i64).["neg"] in
      Pure (cast α1 i64) in
    let* t :=
      let* α0 := a.["deref"] in
      let* α1 := b.["deref"] in
      let* α2 := α0.["bitxor"] α1 in
      mask.["bitand"] α2 in
    let* _ :=
      let* α0 := a.["deref"] in
      α0.["bitxor_assign"] t in
    let* _ :=
      let* α0 := b.["deref"] in
      α0.["bitxor_assign"] t in
    Pure tt.
  
  Global Instance AssociatedFunction_conditional_swap `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_swap" := {
    Notation.double_colon := conditional_swap;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_i64.

Module Impl_subtle_ConditionallySelectable_for_subtle_Choice.
  Definition Self := subtle.Choice.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* α0 :=
      u8::["conditional_select"] (addr_of (a.[0])) (addr_of (b.[0])) choice in
    Pure (subtle.Choice.Build_t α0).
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_Choice.

Module ConditionallyNegatable.
  Class Trait (Self : Set) : Set := {
    conditional_negate
      `{H : State.Trait}
      :
      (mut_ref Self) -> subtle.Choice -> (M (H := H) unit);
  }.
  
  Global Instance Method_conditional_negate `{H : State.Trait} `(Trait)
    : Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
End ConditionallyNegatable.

Module Impl_subtle_ConditionallyNegatable_for_T.
Section Impl_subtle_ConditionallyNegatable_for_T.
  Context {T : Set}.
  
  Definition Self := T.
  
  Definition conditional_negate
      `{H : State.Trait}
      (self : mut_ref Self)
      (choice : subtle.Choice)
      : M (H := H) unit :=
    let* self_neg := (cast self (ref T)).["neg"] in
    let* _ := self.["conditional_assign"] (addr_of self_neg) choice in
    Pure tt.
  
  Global Instance Method_conditional_negate `{H : State.Trait} :
    Notation.Dot "conditional_negate" := {
    Notation.dot := conditional_negate;
  }.
  
  Global Instance I : subtle.ConditionallyNegatable.Trait Self := {
    subtle.ConditionallyNegatable.conditional_negate
      `{H : State.Trait}
      :=
      conditional_negate;
  }.
End Impl_subtle_ConditionallyNegatable_for_T.
End Impl_subtle_ConditionallyNegatable_for_T.

Module CtOption.
  Section CtOption.
    Context {T : Set}.
    Unset Primitive Projections.
    Record t : Set := {
      value : T;
      is_some : subtle.Choice;
    }.
    Global Set Primitive Projections.
    
    Global Instance Get_value : Notation.Dot "value" := {
      Notation.dot '(Build_t x0 _) := x0;
    }.
    Global Instance Get_is_some : Notation.Dot "is_some" := {
      Notation.dot '(Build_t _ x1) := x1;
    }.
  End CtOption.
End CtOption.
Definition CtOption : Set := @CtOption.t.

Module Impl_core_clone_Clone_for_subtle_CtOption_T.
Section Impl_core_clone_Clone_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self := subtle.CtOption T.
  
  Definition clone
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) (subtle.CtOption T) :=
    let* α0 := core.clone.Clone.clone (addr_of self.["value"]) in
    let* α1 := core.clone.Clone.clone (addr_of self.["is_some"]) in
    Pure {| subtle.CtOption.value := α0; subtle.CtOption.is_some := α1; |}.
  
  Global Instance Method_clone `{H : State.Trait} : Notation.Dot "clone" := {
    Notation.dot := clone;
  }.
  
  Global Instance I : core.clone.Clone.Trait Self := {
    core.clone.Clone.clone `{H : State.Trait} := clone;
  }.
End Impl_core_clone_Clone_for_subtle_CtOption_T.
End Impl_core_clone_Clone_for_subtle_CtOption_T.

Module Impl_core_marker_Copy_for_subtle_CtOption_T.
Section Impl_core_marker_Copy_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self := subtle.CtOption T.
  
  Global Instance I : core.marker.Copy.Trait Self :=
    core.marker.Copy.Build_Trait _.
End Impl_core_marker_Copy_for_subtle_CtOption_T.
End Impl_core_marker_Copy_for_subtle_CtOption_T.

Module Impl_core_fmt_Debug_for_subtle_CtOption_T.
Section Impl_core_fmt_Debug_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self := subtle.CtOption T.
  
  Definition fmt
      `{H : State.Trait}
      (self : ref Self)
      (f : mut_ref core.fmt.Formatter)
      : M (H := H) core.fmt.Result :=
    core.fmt.Formatter::["debug_struct_field2_finish"]
      f
      "CtOption"
      "value"
      (addr_of self.["value"])
      "is_some"
      (addr_of (addr_of self.["is_some"])).
  
  Global Instance Method_fmt `{H : State.Trait} : Notation.Dot "fmt" := {
    Notation.dot := fmt;
  }.
  
  Global Instance I : core.fmt.Debug.Trait Self := {
    core.fmt.Debug.fmt `{H : State.Trait} := fmt;
  }.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.
End Impl_core_fmt_Debug_for_subtle_CtOption_T.

Module Impl_core_convert_From_for_core_option_Option_T.
Section Impl_core_convert_From_for_core_option_Option_T.
  Context {T : Set}.
  
  Definition Self := core.option.Option T.
  
  Definition from
      `{H : State.Trait}
      (source : subtle.CtOption T)
      : M (H := H) (core.option.Option T) :=
    let* α0 := source.["is_some"] in
    let* α1 := α0.["unwrap_u8"] in
    let* α2 := α1.["eq"] 1 in
    if (α2 : bool) then
      Pure (core.option.Option.Some source.["value"])
    else
      Pure core.option.Option.None.
  
  Global Instance AssociatedFunction_from `{H : State.Trait} :
    Notation.DoubleColon Self "from" := {
    Notation.double_colon := from;
  }.
  
  Global Instance I : core.convert.From.Trait Self (T := subtle.CtOption T) := {
    core.convert.From.from `{H : State.Trait} := from;
  }.
End Impl_core_convert_From_for_core_option_Option_T.
End Impl_core_convert_From_for_core_option_Option_T.

Module Impl_subtle_CtOption_T_4.
  Definition Self := subtle.CtOption T.
  
  Definition new
      `{H : State.Trait}
      (value : T)
      (is_some : subtle.Choice)
      : M (H := H) (subtle.CtOption T) :=
    Pure
      {| subtle.CtOption.value := value; subtle.CtOption.is_some := is_some; |}.
  
  Global Instance AssociatedFunction_new `{H : State.Trait} :
    Notation.DoubleColon Self "new" := {
    Notation.double_colon := new;
  }.
  
  Definition expect
      `{H : State.Trait}
      (self : Self)
      (msg : ref str)
      : M (H := H) T :=
    let* _ :=
      let* α0 := self.["is_some"].["unwrap_u8"] in
      match (addr_of α0, addr_of 1) with
      | (left_val, right_val) =>
        let* α0 := left_val.["deref"] in
        let* α1 := right_val.["deref"] in
        let* α2 := α0.["eq"] α1 in
        let* α3 := α2.["not"] in
        if (α3 : bool) then
          let kind := core.panicking.AssertKind.Eq in
          let* _ :=
            let* α0 := left_val.["deref"] in
            let* α1 := right_val.["deref"] in
            let* α2 := format_argument::["new_display"] (addr_of msg) in
            let* α3 :=
              format_arguments::["new_v1"] (addr_of [ "" ]) (addr_of [ α2 ]) in
            core.panicking.assert_failed
              kind
              (addr_of α0)
              (addr_of α1)
              (core.option.Option.Some α3) in
          Pure tt
        else
          Pure tt
      end in
    Pure self.["value"].
  
  Global Instance Method_expect `{H : State.Trait} : Notation.Dot "expect" := {
    Notation.dot := expect;
  }.
  
  Definition unwrap `{H : State.Trait} (self : Self) : M (H := H) T :=
    let* _ :=
      let* α0 := self.["is_some"].["unwrap_u8"] in
      match (addr_of α0, addr_of 1) with
      | (left_val, right_val) =>
        let* α0 := left_val.["deref"] in
        let* α1 := right_val.["deref"] in
        let* α2 := α0.["eq"] α1 in
        let* α3 := α2.["not"] in
        if (α3 : bool) then
          let kind := core.panicking.AssertKind.Eq in
          let* _ :=
            let* α0 := left_val.["deref"] in
            let* α1 := right_val.["deref"] in
            core.panicking.assert_failed
              kind
              (addr_of α0)
              (addr_of α1)
              core.option.Option.None in
          Pure tt
        else
          Pure tt
      end in
    Pure self.["value"].
  
  Global Instance Method_unwrap `{H : State.Trait} : Notation.Dot "unwrap" := {
    Notation.dot := unwrap;
  }.
  
  Definition unwrap_or
      `{H : State.Trait}
      `{subtle.ConditionallySelectable.Trait T}
      (self : Self)
      (def : T)
      : M (H := H) T :=
    T::["conditional_select"]
      (addr_of def)
      (addr_of self.["value"])
      self.["is_some"].
  
  Global Instance Method_unwrap_or `{H : State.Trait} :
    Notation.Dot "unwrap_or" := {
    Notation.dot := unwrap_or;
  }.
  
  Definition unwrap_or_else
      `{H : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (H := H) T :=
    let* α0 := f in
    T::["conditional_select"]
      (addr_of α0)
      (addr_of self.["value"])
      self.["is_some"].
  
  Global Instance Method_unwrap_or_else `{H : State.Trait} :
    Notation.Dot "unwrap_or_else" := {
    Notation.dot := unwrap_or_else;
  }.
  
  Definition is_some
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) subtle.Choice :=
    Pure self.["is_some"].
  
  Global Instance Method_is_some `{H : State.Trait} :
    Notation.Dot "is_some" := {
    Notation.dot := is_some;
  }.
  
  Definition is_none
      `{H : State.Trait}
      (self : ref Self)
      : M (H := H) subtle.Choice :=
    self.["is_some"].["not"].
  
  Global Instance Method_is_none `{H : State.Trait} :
    Notation.Dot "is_none" := {
    Notation.dot := is_none;
  }.
  
  Definition map
      `{H : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (H := H) (subtle.CtOption U) :=
    let* α0 := T::["default"] in
    let* α1 :=
      T::["conditional_select"]
        (addr_of α0)
        (addr_of self.["value"])
        self.["is_some"] in
    let* α2 := f α1 in
    subtle.CtOption::["new"] α2 self.["is_some"].
  
  Global Instance Method_map `{H : State.Trait} : Notation.Dot "map" := {
    Notation.dot := map;
  }.
  
  Definition and_then
      `{H : State.Trait}
      {U F : Set}
      `{core.default.Default.Trait T}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := T)}
      (self : Self)
      (f : F)
      : M (H := H) (subtle.CtOption U) :=
    let* tmp :=
      let* α0 := T::["default"] in
      let* α1 :=
        T::["conditional_select"]
          (addr_of α0)
          (addr_of self.["value"])
          self.["is_some"] in
      f α1 in
    let* _ := tmp.["is_some"].["bitand_assign"] self.["is_some"] in
    Pure tmp.
  
  Global Instance Method_and_then `{H : State.Trait} :
    Notation.Dot "and_then" := {
    Notation.dot := and_then;
  }.
  
  Definition or_else
      `{H : State.Trait}
      {F : Set}
      `{subtle.ConditionallySelectable.Trait T}
      `{core.ops.function.FnOnce.Trait F (Args := unit)}
      (self : Self)
      (f : F)
      : M (H := H) (subtle.CtOption T) :=
    let* is_none := self.["is_none"] in
    let* f := f in
    Self::["conditional_select"] (addr_of self) (addr_of f) is_none.
  
  Global Instance Method_or_else `{H : State.Trait} :
    Notation.Dot "or_else" := {
    Notation.dot := or_else;
  }.
End Impl_subtle_CtOption_T_4.

Module Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
Section Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self := subtle.CtOption T.
  
  Definition conditional_select
      `{H : State.Trait}
      (a : ref Self)
      (b : ref Self)
      (choice : subtle.Choice)
      : M (H := H) Self :=
    let* α0 :=
      T::["conditional_select"]
        (addr_of a.["value"])
        (addr_of b.["value"])
        choice in
    let* α1 :=
      subtle.Choice::["conditional_select"]
        (addr_of a.["is_some"])
        (addr_of b.["is_some"])
        choice in
    subtle.CtOption::["new"] α0 α1.
  
  Global Instance AssociatedFunction_conditional_select `{H : State.Trait} :
    Notation.DoubleColon Self "conditional_select" := {
    Notation.double_colon := conditional_select;
  }.
  
  Global Instance I : subtle.ConditionallySelectable.Trait Self := {
    subtle.ConditionallySelectable.conditional_select
      `{H : State.Trait}
      :=
      conditional_select;
  }.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.
End Impl_subtle_ConditionallySelectable_for_subtle_CtOption_T.

Module Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
Section Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
  Context {T : Set}.
  
  Definition Self := subtle.CtOption T.
  
  Definition ct_eq
      `{H : State.Trait}
      (self : ref Self)
      (rhs : ref (subtle.CtOption T))
      : M (H := H) subtle.Choice :=
    let* a := self.["is_some"] in
    let* b := rhs.["is_some"] in
    let* α0 := a.["bitand"] b in
    let* α1 := self.["value"].["ct_eq"] (addr_of rhs.["value"]) in
    let* α2 := α0.["bitand"] α1 in
    let* α3 := a.["not"] in
    let* α4 := b.["not"] in
    let* α5 := α3.["bitand"] α4 in
    α2.["bitor"] α5.
  
  Global Instance Method_ct_eq `{H : State.Trait} : Notation.Dot "ct_eq" := {
    Notation.dot := ct_eq;
  }.
  
  Global Instance I : subtle.ConstantTimeEq.Trait Self := {
    subtle.ConstantTimeEq.ct_eq `{H : State.Trait} := ct_eq;
  }.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.
End Impl_subtle_ConstantTimeEq_for_subtle_CtOption_T.

Module ConstantTimeGreater.
  Class Trait (Self : Set) : Set := {
    ct_gt
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) subtle.Choice);
  }.
  
  Global Instance Method_ct_gt `{H : State.Trait} `(Trait)
    : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
End ConstantTimeGreater.

Module Impl_subtle_ConstantTimeGreater_for_u8.
  Definition Self := u8.
  
  Definition ct_gt
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u8)
      : M (H := H) subtle.Choice :=
    let* gtb :=
      let* α0 := other.["not"] in
      self.["bitand"] α0 in
    let* ltb :=
      let* α0 := self.["not"] in
      α0.["bitand"] other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 8 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := ltb.["shr"] pow in
            ltb.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* bit :=
      let* α0 := ltb.["not"] in
      gtb.["bitand"] α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 8 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := bit.["shr"] pow in
            bit.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* α0 := bit.["bitand"] 1 in
    subtle.Choice::["from"] (cast α0 u8).
  
  Global Instance Method_ct_gt `{H : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H : State.Trait} := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u8.

Module Impl_subtle_ConstantTimeGreater_for_u16.
  Definition Self := u16.
  
  Definition ct_gt
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u16)
      : M (H := H) subtle.Choice :=
    let* gtb :=
      let* α0 := other.["not"] in
      self.["bitand"] α0 in
    let* ltb :=
      let* α0 := self.["not"] in
      α0.["bitand"] other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 16 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := ltb.["shr"] pow in
            ltb.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* bit :=
      let* α0 := ltb.["not"] in
      gtb.["bitand"] α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 16 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := bit.["shr"] pow in
            bit.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* α0 := bit.["bitand"] 1 in
    subtle.Choice::["from"] (cast α0 u8).
  
  Global Instance Method_ct_gt `{H : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H : State.Trait} := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u16.

Module Impl_subtle_ConstantTimeGreater_for_u32.
  Definition Self := u32.
  
  Definition ct_gt
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u32)
      : M (H := H) subtle.Choice :=
    let* gtb :=
      let* α0 := other.["not"] in
      self.["bitand"] α0 in
    let* ltb :=
      let* α0 := self.["not"] in
      α0.["bitand"] other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 32 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := ltb.["shr"] pow in
            ltb.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* bit :=
      let* α0 := ltb.["not"] in
      gtb.["bitand"] α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 32 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := bit.["shr"] pow in
            bit.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* α0 := bit.["bitand"] 1 in
    subtle.Choice::["from"] (cast α0 u8).
  
  Global Instance Method_ct_gt `{H : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H : State.Trait} := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u32.

Module Impl_subtle_ConstantTimeGreater_for_u64.
  Definition Self := u64.
  
  Definition ct_gt
      `{H : State.Trait}
      (self : ref Self)
      (other : ref u64)
      : M (H := H) subtle.Choice :=
    let* gtb :=
      let* α0 := other.["not"] in
      self.["bitand"] α0 in
    let* ltb :=
      let* α0 := self.["not"] in
      α0.["bitand"] other in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 64 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := ltb.["shr"] pow in
            ltb.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* bit :=
      let* α0 := ltb.["not"] in
      gtb.["bitand"] α0 in
    let pow := 1 in
    let* _ :=
      loop
        (let* α0 := pow.["lt"] 64 in
        if (α0 : bool) then
          let* _ :=
            let* α0 := bit.["shr"] pow in
            bit.["bitor_assign"] α0 in
          let* _ := pow.["add_assign"] pow in
          Pure tt
        else
          let* _ := Break in
          Pure tt) in
    let* α0 := bit.["bitand"] 1 in
    subtle.Choice::["from"] (cast α0 u8).
  
  Global Instance Method_ct_gt `{H : State.Trait} : Notation.Dot "ct_gt" := {
    Notation.dot := ct_gt;
  }.
  
  Global Instance I : subtle.ConstantTimeGreater.Trait Self := {
    subtle.ConstantTimeGreater.ct_gt `{H : State.Trait} := ct_gt;
  }.
End Impl_subtle_ConstantTimeGreater_for_u64.

Module ConstantTimeLess.
  Class Trait
      (Self : Set)
        `{subtle.ConstantTimeEq.Trait Self}
        `{subtle.ConstantTimeGreater.Trait Self} :
      Set := {
  }.
  
  Global Instance Method_ct_lt `{H : State.Trait} `(Trait)
    : Notation.Dot "ct_lt" := {
    Notation.dot (self : ref Self) (other : ref Self)
      :=
      (let* α0 := self.["ct_gt"] other in
      let* α1 := α0.["not"] in
      let* α2 := self.["ct_eq"] other in
      let* α3 := α2.["not"] in
      α1.["bitand"] α3
      : M (H := H) subtle.Choice);
  }.
End ConstantTimeLess.

Module Impl_subtle_ConstantTimeLess_for_u8.
  Definition Self := u8.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self :=
    subtle.ConstantTimeLess.Build_Trait _.
End Impl_subtle_ConstantTimeLess_for_u8.

Module Impl_subtle_ConstantTimeLess_for_u16.
  Definition Self := u16.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self :=
    subtle.ConstantTimeLess.Build_Trait _.
End Impl_subtle_ConstantTimeLess_for_u16.

Module Impl_subtle_ConstantTimeLess_for_u32.
  Definition Self := u32.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self :=
    subtle.ConstantTimeLess.Build_Trait _.
End Impl_subtle_ConstantTimeLess_for_u32.

Module Impl_subtle_ConstantTimeLess_for_u64.
  Definition Self := u64.
  
  Global Instance I : subtle.ConstantTimeLess.Trait Self :=
    subtle.ConstantTimeLess.Build_Trait _.
End Impl_subtle_ConstantTimeLess_for_u64.
