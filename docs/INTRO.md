# 🐓🦀 coq-of-rust project

https://github.com/formal-land/coq-of-rust

> 🎯 Goal: have a clean translation of Rust code to the Coq language to formally verify Rust code using a high-level proof language.

Alternative project that we are looking at: [Creusot](https://github.com/xldenis/creusot), that is more oriented towards automatic proving and uses the Why3 backend instead of Coq.

One of the main challenge in representing Rust programs in Coq are the mutations of variables. This feature is heavily used in order to have close performance to C. The Rust type-system with the exclusive `&mut` references may help us as it prevents aliases of pointers, but we will still need to do some work to translate the mutations to a state monad or other encodings.

There are several intermediate languages in Rust:
* syntax AST
* HIR: a cleaned version of the syntax AST with more semantics information (like the handling of the variables names)
* THIR: like HIR + types, although some type information are available from HIR
* MIR: low-level representation

These languages are described in [Rust dev guide: Source Code Representation](https://rustc-dev-guide.rust-lang.org/part-3-intro.html) We start the translation from the HIR level. The Creusot project relies on the MIR language.

## Step 1: Coq that type-checks
The first goal is to be able to translate Rust code to Coq code that type-checks, even if we axiomatize the side-effects. **This step should already take a lot of time.**

For example we can translate:
```rust
fn main() {
    let mut n = 0;
    n = n + 1;
    println!("{n}");
}
```
to the Coq code:
```coq
Definition main (_ : unit) : unit :=
  let n := 0 in
  let _ := assign n (n + 1) in
  println "{}" n.
```
with:
```coq
Parameter assign : forall {A : Set}, A -> A -> unit.
```
and the code will type-check in Coq, even if we cannot give a concrete definition of `assign`.

There are the Rust examples in https://github.com/formal-land/coq-of-rust/tree/main/coq_translation/examples-from-rust-book that can guide us in the task. We can try to translate successfully each example one by one. The instructions to translate the examples and verify the corresponding Coq code are in https://github.com/formal-land/coq-of-rust/blob/main/.github/workflows/rust.yml (the Coq type-checking is commented out for now, at it does not work on all examples, but the goal of this first step is to fix that).

For definitions that are part of the standard library of Rust, we have the file https://github.com/formal-land/coq-of-rust/blob/main/coq_translation/examples-from-rust-book/CoqOfRust.v to provide corresponding Coq definitions.

We have already done some effort for the translation, especially for the translation of traits. But basically everything need to be improved.

The way the translation works is the following:
1) We read the HIR tree generated by the `rustc` compiler.
2) We translate it in our own AST, ready to be printed in Coq, in a single pass. Keeping the translation simple is one of our design goals, in order to generate a Coq code that is similar to the original Rust code, and also to have a translator that is simple to maintain. We should avoid generated new variable names, so that user Coq proofs and lemma statements do not break too much.
3) We pretty-print our AST to Coq using the pretty-printer https://github.com/Marwes/pretty.rs The code is quite verbose for this part.

One of the challenges is to handle the name-binding rules in Coq in the same way as in Rust. There are a lot of differences, for example it is possible to overload definitions in Rust making new implementations with `impl`. When we call a method in Rust:
```rust
data.foo(arg1, arg2);
```
it can be unclear to which function `foo` is referencing, as it can be one of the implementations or trait implementations of the type of `foo`.

As overloading does not exist in Coq, a technique we use is the following:
```coq
(** A generic class to represent methods by name. *)
Class Method (name : string) (T : Set) : Set := {
  method : T;
}.
Arguments method name {T Method}.
```
We use a type-classe to represent the overloading of a method name, the name of the method being a string given as a parameter to the type-class `Method`. Then, given a method name, the inference mechanism of the type-classes can infer which implementation to choose to have an expected type `T`. There are a few variations of this technique to handle overloading in the generated Coq code right now that you should encounter, and better understand with existing examples.

## Step 2: Coq that runs
The goal here will be to:
* Make a monad to reprentation a reasonable set of mutations for Rust (or any other ways to represent mutations, but monad are probably the default choice).
* Have a monadic translation of the Coq code that we generate using this monad, and some notations to make it less verbose.
* Use this state monad in the translation with a code that behaves the same in Coq and in Rust (meaning the evaluation of the two should give the same result).
* Additionnaly, there are other side-effects like:
    * errors (there are non-recoverable in Rust, and can be raise by many primitives including integer overflows)
    * async
    * basic IOs
that we can/should handle.

## Step 3: Actual proofs
The final step is about writting actual proofs on Rust code, for example to verify the Solana smart contract https://github.com/solana-labs/solana-program-library/tree/master/token/program that is one of the most used on the Solana blockchain (smart contract that implements stable coins and NFTs).
